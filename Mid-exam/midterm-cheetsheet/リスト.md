
# データ構造チートシート: 配列とリンクリスト

## 1. 配列

- **概要**: 配列はメモリ上にデータを順番に隣り合わせて並べるデータ構造です。
- **特徴**:
  - 各要素は連続したメモリの場所を占有。
  - 固定サイズで初期化され、サイズ変更には再確保が必要です。
  - ランダムアクセスが可能（O(1)の時間で特定のインデックスの要素にアクセスできます）。

## 2. リンクリスト

- **概要**: リンクリストは各要素が次の要素へのリンクを持つデータ構造です。メモリ上でデータは隣り合ってはいません。
- **特徴**:
  - サイズを動的に変更可能。
  - 要素の追加や削除が容易ですが、指定した位置へのアクセスはO(n)の時間がかかります。

## 3. Pythonでのリンクリストの実装

```python
class Node:
    def __init__(self, value):
        self.value = value
        self.next = None

class LinkedList:
    def __init__(self):
        self.head = None

    def append(self, value):
        new_node = Node(value)
        if not self.head:
            self.head = new_node
            return
        last_node = self.head
        while last_node.next:
            last_node = last_node.next
        last_node.next = new_node

    def display(self):
        current = self.head
        while current:
            print(current.value, end=" -> ")
            current = current.next
        print("None")
```

4. 計算量
配列によるリスト:

任意の要素へのアクセス: O(1)
末尾への追加・削除: O(1) （ただし場所が足りない場合はO(n)）
指定された位置への追加・削除: O(n)


リンクリスト:

任意の要素へのアクセス: O(n)
末尾への追加: O(n)（末尾までの探索が必要）
末尾への削除: O(n)（末尾までの探索が必要）
指定された位置への追加・削除: O(1)


5. 動作原理

配列:

個々の要素はメモリの隣接ブロックに格納され、インデックスを使用してアクセスします。
必要に応じて、再確保して新しいメモリブロックを確保します。



リンクリスト:

各ノードはデータを保持し、次のノードへのポインタを持ちます。
リストの先頭から次ノードにたどることで、全要素にアクセスします。


6. 動作の流れ

配列の場合:

データを順番に格納。
インデックスを使用して直接アクセス。
サイズ変更時には再確保を行う。



リンクリストの場合:

新しいノードを作成し、次のポインタをリンク。
最初のノードから次へと順にたどる。
要素の追加や削除はポインタの操作で管理。

