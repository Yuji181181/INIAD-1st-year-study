<!DOCTYPE html>

<html lang="ja" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>モデル &#8212; Django 5.1.6.dev20250122212402 ドキュメント</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=34bb78ad" />
    <link rel="stylesheet" type="text/css" href="../../_static/default.css?v=bf4d74af" />
    <script src="../../_static/documentation_options.js?v=d2885b0a"></script>
    <script src="../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/translations.js?v=4755f45a"></script>
    <link rel="index" title="索引" href="../../genindex.html" />
    <link rel="search" title="検索" href="../../search.html" />
    <link rel="next" title="クエリを作成する" href="queries.html" />
    <link rel="prev" title="モデルとデータベース" href="index.html" />



 
<script src="../../templatebuiltins.js"></script>
<script>
(function($) {
    if (!django_template_builtins) {
       // templatebuiltins.js missing, do nothing.
       return;
    }
    $(document).ready(function() {
        // Hyperlink Django template tags and filters
        var base = "../../ref/templates/builtins.html";
        if (base == "#") {
            // Special case for builtins.html itself
            base = "";
        }
        // Tags are keywords, class '.k'
        $("div.highlight\\-html\\+django span.k").each(function(i, elem) {
             var tagname = $(elem).text();
             if ($.inArray(tagname, django_template_builtins.ttags) != -1) {
                 var fragment = tagname.replace(/_/, '-');
                 $(elem).html("<a href='" + base + "#" + fragment + "'>" + tagname + "</a>");
             }
        });
        // Filters are functions, class '.nf'
        $("div.highlight\\-html\\+django span.nf").each(function(i, elem) {
             var filtername = $(elem).text();
             if ($.inArray(filtername, django_template_builtins.tfilters) != -1) {
                 var fragment = filtername.replace(/_/, '-');
                 $(elem).html("<a href='" + base + "#" + fragment + "'>" + filtername + "</a>");
             }
        });
    });
})(jQuery);</script>

  </head><body>

    <div class="document">
  <div id="custom-doc" class="yui-t6">
    <div id="hd">
      <h1><a href="../../index.html">Django 5.1.6.dev20250122212402 ドキュメント</a></h1>
      <div id="global-nav">
        <a title="Home page" href="../../index.html">Home</a>  |
        <a title="Table of contents" href="../../contents.html">Table of contents</a>  |
        <a title="Global index" href="../../genindex.html">Index</a>  |
        <a title="Module index" href="../../py-modindex.html">Modules</a>
      </div>
      <div class="nav">
    &laquo; <a href="index.html" title="モデルとデータベース">previous</a>
     |
    <a href="../index.html" title="Django を使う" accesskey="U">up</a>
   |
    <a href="queries.html" title="クエリを作成する">next</a> &raquo;</div>
    </div>

    <div id="bd">
      <div id="yui-main">
        <div class="yui-b">
          <div class="yui-g" id="topics-db-models">
            
  <section id="s-module-django.db.models">
<span id="s-models"></span><span id="module-django.db.models"></span><span id="models"></span><h1>モデル<a class="headerlink" href="#module-django.db.models" title="Link to this heading">¶</a></h1>
<p>モデルは、データに関する唯一かつ決定的な情報源です。あなたが保持するデータが必要とするフィールドとその動作を定義します。一般的に、各モデルは単一のデータベースのテーブルに対応付けられます。</p>
<p>基本:</p>
<ul class="simple">
<li><p>モデルは各々 Python のクラスであり <a class="reference internal" href="../../ref/models/instances.html#django.db.models.Model" title="django.db.models.Model"><code class="xref py py-class docutils literal notranslate"><span class="pre">django.db.models.Model</span></code></a> のサブクラスです。</p></li>
<li><p>モデルの属性はそれぞれがデータベースのフィールドを表します。</p></li>
<li><p>これら全てを用いて、Django はデータベースにアクセスする自動生成された API を提供します。 <a class="reference internal" href="queries.html"><span class="doc">クエリを作成する</span></a> を参照してください。</p></li>
</ul>
<section id="s-quick-example">
<span id="quick-example"></span><h2>簡単な例<a class="headerlink" href="#quick-example" title="Link to this heading">¶</a></h2>
<p>次の例では <code class="docutils literal notranslate"><span class="pre">first_name</span></code> と <code class="docutils literal notranslate"><span class="pre">last_name</span></code> を持つ <code class="docutils literal notranslate"><span class="pre">Person</span></code> というモデルを定義しています。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">django.db</span><span class="w"> </span><span class="kn">import</span> <span class="n">models</span>


<span class="k">class</span><span class="w"> </span><span class="nc">Person</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">first_name</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span>
    <span class="n">last_name</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">first_name</span></code> および <code class="docutils literal notranslate"><span class="pre">last_name</span></code> はこのモデルの <a class="reference internal" href="#fields">フィールド</a> です。各フィールドはクラスの属性として定義され、各属性はデータベースのカラムに関連付けられます。</p>
<p>上記の <code class="docutils literal notranslate"><span class="pre">Person</span></code> モデルは以下のようなデータベースのテーブルを作成します:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">myapp_person</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="ss">&quot;id&quot;</span><span class="w"> </span><span class="nb">bigint</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="w"> </span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span><span class="w"> </span><span class="k">GENERATED</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="k">DEFAULT</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="k">IDENTITY</span><span class="p">,</span>
<span class="w">    </span><span class="ss">&quot;first_name&quot;</span><span class="w"> </span><span class="nb">varchar</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="p">,</span>
<span class="w">    </span><span class="ss">&quot;last_name&quot;</span><span class="w"> </span><span class="nb">varchar</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span>
<span class="p">);</span>
</pre></div>
</div>
<p>技術的な注意点:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">myapp_person</span></code> というテーブル名は、いくつかのモデルのメタデータから自動的に生成されますが、それを無効化することもできます。詳細は <a class="reference internal" href="../../ref/models/options.html#table-names"><span class="std std-ref">テーブル名</span></a> を参照ください。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">id</span></code> フィールドは自動的に追加されますが、この処理は無効化することもできます。<a class="reference internal" href="#automatic-primary-key-fields"><span class="std std-ref">自動インクリメントのプライマリーキーフィールド</span></a> を参照ください。</p></li>
<li><p>この例における <code class="docutils literal notranslate"><span class="pre">CREATE</span> <span class="pre">TABLE</span></code> の SQL は PostgreSQL の文法に準拠していますが、Django は <a class="reference internal" href="../settings.html"><span class="doc">設定ファイル</span></a> 内に定義されたデータベースバックエンドに合わせた SQL を適切に生成してくれるということを覚えておくとよいでしょう。</p></li>
</ul>
</section>
<section id="s-using-models">
<span id="using-models"></span><h2>モデルの利用<a class="headerlink" href="#using-models" title="Link to this heading">¶</a></h2>
<p>一度モデルを定義した後は、Django にこれらのモデルを <em>利用する</em> ということを知らせる必要があります。そのためには、設定ファイルを編集して、設定値 <a class="reference internal" href="../../ref/settings.html#std-setting-INSTALLED_APPS"><code class="xref std std-setting docutils literal notranslate"><span class="pre">INSTALLED_APPS</span></code></a> に、定義した <code class="docutils literal notranslate"><span class="pre">models.py</span></code> を含むモジュール名を追加します。</p>
<p>たとえば、アプリケーションのモデルが <code class="docutils literal notranslate"><span class="pre">myapp.models</span></code> モジュール内に存在する場合 (このパッケージ構造は <a class="reference internal" href="../../ref/django-admin.html#django-admin-startapp"><code class="xref std std-djadmin docutils literal notranslate"><span class="pre">manage.py</span> <span class="pre">startapp</span></code></a> スクリプトによってアプリケーション内に構築されるものです)、<a class="reference internal" href="../../ref/settings.html#std-setting-INSTALLED_APPS"><code class="xref std std-setting docutils literal notranslate"><span class="pre">INSTALLED_APPS</span></code></a> の部分を次のように定義します。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">INSTALLED_APPS</span> <span class="o">=</span> <span class="p">[</span>
    <span class="c1"># ...</span>
    <span class="s2">&quot;myapp&quot;</span><span class="p">,</span>
    <span class="c1"># ...</span>
<span class="p">]</span>
</pre></div>
</div>
<p><a class="reference internal" href="../../ref/settings.html#std-setting-INSTALLED_APPS"><code class="xref std std-setting docutils literal notranslate"><span class="pre">INSTALLED_APPS</span></code></a> 内に新たなアプリケーションを追加した場合、<a class="reference internal" href="../../ref/django-admin.html#django-admin-migrate"><code class="xref std std-djadmin docutils literal notranslate"><span class="pre">manage.py</span> <span class="pre">migrate</span></code></a> を、初回は必要に応じて <a class="reference internal" href="../../ref/django-admin.html#django-admin-makemigrations"><code class="xref std std-djadmin docutils literal notranslate"><span class="pre">manage.py</span> <span class="pre">makemigrations</span></code></a> を忘れずに実行してください。</p>
</section>
<section id="s-fields">
<span id="fields"></span><h2>フィールド<a class="headerlink" href="#fields" title="Link to this heading">¶</a></h2>
<p>モデルの最も重要な部分であり、モデルにとって唯一必須のもの、それはモデルが定義するデータベースフィールドのリストです。フィールドはクラスの属性として定義します。 <code class="docutils literal notranslate"><span class="pre">clean</span></code>, <code class="docutils literal notranslate"><span class="pre">save</span></code>, <code class="docutils literal notranslate"><span class="pre">delete</span></code> のような <a class="reference internal" href="../../ref/models/instances.html"><span class="doc">モデル API</span></a> と衝突するフィールド名は付けられないことに注意してください。</p>
<p>実装例:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">django.db</span><span class="w"> </span><span class="kn">import</span> <span class="n">models</span>


<span class="k">class</span><span class="w"> </span><span class="nc">Musician</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">first_name</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">50</span><span class="p">)</span>
    <span class="n">last_name</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">50</span><span class="p">)</span>
    <span class="n">instrument</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>


<span class="k">class</span><span class="w"> </span><span class="nc">Album</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">artist</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">ForeignKey</span><span class="p">(</span><span class="n">Musician</span><span class="p">,</span> <span class="n">on_delete</span><span class="o">=</span><span class="n">models</span><span class="o">.</span><span class="n">CASCADE</span><span class="p">)</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
    <span class="n">release_date</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">DateField</span><span class="p">()</span>
    <span class="n">num_stars</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">IntegerField</span><span class="p">()</span>
</pre></div>
</div>
<section id="s-field-types">
<span id="field-types"></span><h3>フィールドの型<a class="headerlink" href="#field-types" title="Link to this heading">¶</a></h3>
<p>モデル内の各フィールドは、適切な <a class="reference internal" href="../../ref/models/fields.html#django.db.models.Field" title="django.db.models.Field"><code class="xref py py-class docutils literal notranslate"><span class="pre">Field</span></code></a> クラスのインスタンスである必要があります。Django はフィールドクラスの型に応じて以下のような挙動を決定します。</p>
<ul class="simple">
<li><p>カラムの型。これはデータベースにどの種類のデータを格納するかを示します (例: <code class="docutils literal notranslate"><span class="pre">INTEGER</span></code>、<code class="docutils literal notranslate"><span class="pre">VARCHAR</span></code>、<code class="docutils literal notranslate"><span class="pre">TEXT</span></code>)。</p></li>
<li><p>フォーム領域をレンダリングする際に使用するデフォルトの HTML <a class="reference internal" href="../../ref/forms/widgets.html"><span class="doc">ウィジェット</span></a> (例: <code class="docutils literal notranslate"><span class="pre">&lt;input</span> <span class="pre">type=&quot;text&quot;&gt;</span></code>、 <code class="docutils literal notranslate"><span class="pre">&lt;select&gt;</span></code>)。</p></li>
<li><p>Django 管理サイトや自動生成フォームで使用される最小限のバリデーション要件。</p></li>
</ul>
<p>Django は多くのフィールド型を内蔵しています。完全なリストは <a class="reference internal" href="../../ref/models/fields.html#model-field-types"><span class="std std-ref">モデルフィールドのリファレンス</span></a> から確認できます。もし Django に内蔵のフィールド型では実現できない機能を実装したい場合は、独自のフィールドを簡単に作成できます。詳細は <a class="reference internal" href="../../howto/custom-model-fields.html"><span class="doc">カスタムのモデルフィールドを作成する</span></a> を参照してください。</p>
</section>
<section id="s-field-options">
<span id="field-options"></span><h3>フィールドオプション<a class="headerlink" href="#field-options" title="Link to this heading">¶</a></h3>
<p>フィールドはそれぞれあらかじめ定められたフィールド特有の引数 ( <a class="reference internal" href="../../ref/models/fields.html#model-field-types"><span class="std std-ref">モデルのフィールド型一覧</span></a> にまとめられています) を受け取ります。例えば、<a class="reference internal" href="../../ref/models/fields.html#django.db.models.CharField" title="django.db.models.CharField"><code class="xref py py-class docutils literal notranslate"><span class="pre">CharField</span></code></a> (およびそのサブクラス) はそのデータを保持するためにデータベース上に定義される <code class="docutils literal notranslate"><span class="pre">VARCHAR</span></code> 領域の長さを定義する引数 <a class="reference internal" href="../../ref/models/fields.html#django.db.models.CharField.max_length" title="django.db.models.CharField.max_length"><code class="xref py py-attr docutils literal notranslate"><span class="pre">max_length</span></code></a> を必要とします。</p>
<p>全てのフィールドの型で利用できる共通の引数も存在します。すべてオプションの引数です。これらの引数についてはこちらの <a class="reference internal" href="../../ref/models/fields.html#common-model-field-options"><span class="std std-ref">リファレンス</span></a> 内で全て説明されていますが、ここでは、特に頻繁に使われるものについて簡単な概要を説明します。</p>
<dl>
<dt><a class="reference internal" href="../../ref/models/fields.html#django.db.models.Field.null" title="django.db.models.Field.null"><code class="xref py py-attr docutils literal notranslate"><span class="pre">null</span></code></a></dt><dd><p><code class="docutils literal notranslate"><span class="pre">True</span></code> の場合、Django は空の値をデータベース内に <code class="docutils literal notranslate"><span class="pre">NULL</span></code> として保持します。デフォルトは <code class="docutils literal notranslate"><span class="pre">False</span></code> です。</p>
</dd>
<dt><a class="reference internal" href="../../ref/models/fields.html#django.db.models.Field.blank" title="django.db.models.Field.blank"><code class="xref py py-attr docutils literal notranslate"><span class="pre">blank</span></code></a></dt><dd><p><code class="docutils literal notranslate"><span class="pre">True</span></code> の場合、フィールドはブランクになることが許容されます。デフォルトは <code class="docutils literal notranslate"><span class="pre">False</span></code> です。</p>
<p><a class="reference internal" href="../../ref/models/fields.html#django.db.models.Field.null" title="django.db.models.Field.null"><code class="xref py py-attr docutils literal notranslate"><span class="pre">null</span></code></a> とは挙動が異なる事に注意してください。 <a class="reference internal" href="../../ref/models/fields.html#django.db.models.Field.blank" title="django.db.models.Field.blank"><code class="xref py py-attr docutils literal notranslate"><span class="pre">blank</span></code></a> がバリデーション由来である一方、 <a class="reference internal" href="../../ref/models/fields.html#django.db.models.Field.null" title="django.db.models.Field.null"><code class="xref py py-attr docutils literal notranslate"><span class="pre">null</span></code></a> は完全にデータベース由来です。あるフィールドが <a class="reference internal" href="../../ref/models/fields.html#django.db.models.Field.blank" title="django.db.models.Field.blank"><code class="xref py py-attr docutils literal notranslate"><span class="pre">blank=True</span></code></a> であれば、フォームのバリデーションは空の値の入力を許容します。あるフィールドが <a class="reference internal" href="../../ref/models/fields.html#django.db.models.Field.blank" title="django.db.models.Field.blank"><code class="xref py py-attr docutils literal notranslate"><span class="pre">blank=False</span></code></a> の場合は、そのフィールドへの入力は必須となります。</p>
</dd>
<dt><a class="reference internal" href="../../ref/models/fields.html#django.db.models.Field.choices" title="django.db.models.Field.choices"><code class="xref py py-attr docutils literal notranslate"><span class="pre">choices</span></code></a></dt><dd><p>2 値タプルの <a class="reference external" href="https://docs.python.org/3/glossary.html#term-sequence" title="(in Python v3.13)"><span class="xref std std-term">sequence</span></a>, もしくは <a class="reference external" href="https://docs.python.org/3/glossary.html#term-mapping" title="(in Python v3.13)"><span class="xref std std-term">mapping</span></a>, <a class="reference internal" href="../../ref/models/fields.html#field-choices-enum-types"><span class="std std-ref">列挙型</span></a>, または呼び出し可能オブジェクト (引数を指定せず、前述の形式のいずれかを返す) をこのフィールドの選択肢として使用します。これが指定された場合、デフォルトのフォームウィジェットは標準のテキストフィールドではなくセレクトボックスとなり、選択肢は指定されたものに制限されます。</p>
<p>選択肢のリストは以下のようになります。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">YEAR_IN_SCHOOL_CHOICES</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">(</span><span class="s2">&quot;FR&quot;</span><span class="p">,</span> <span class="s2">&quot;Freshman&quot;</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;SO&quot;</span><span class="p">,</span> <span class="s2">&quot;Sophomore&quot;</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;JR&quot;</span><span class="p">,</span> <span class="s2">&quot;Junior&quot;</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;SR&quot;</span><span class="p">,</span> <span class="s2">&quot;Senior&quot;</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;GR&quot;</span><span class="p">,</span> <span class="s2">&quot;Graduate&quot;</span><span class="p">),</span>
<span class="p">]</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p><code class="docutils literal notranslate"><span class="pre">choices</span></code> の順番を変更すると、変更のたびに新しいマイグレーションが生成されます。</p>
</div>
<p>各タプルの1番目の要素はデータベースに保存される値です。2番目の要素はフォームウィジェットに表示される名前です。</p>
<p>モデルのインスタンスが与えられたとき、<code class="docutils literal notranslate"><span class="pre">choices</span></code> のフィールドに対して表示される値は、<a class="reference internal" href="../../ref/models/instances.html#django.db.models.Model.get_FOO_display" title="django.db.models.Model.get_FOO_display"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_FOO_display()</span></code></a> メソッドを用いてアクセスできます。たとえば、次のようになります。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">django.db</span><span class="w"> </span><span class="kn">import</span> <span class="n">models</span>


<span class="k">class</span><span class="w"> </span><span class="nc">Person</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">SHIRT_SIZES</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;S&quot;</span><span class="p">:</span> <span class="s2">&quot;Small&quot;</span><span class="p">,</span>
        <span class="s2">&quot;M&quot;</span><span class="p">:</span> <span class="s2">&quot;Medium&quot;</span><span class="p">,</span>
        <span class="s2">&quot;L&quot;</span><span class="p">:</span> <span class="s2">&quot;Large&quot;</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">60</span><span class="p">)</span>
    <span class="n">shirt_size</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">choices</span><span class="o">=</span><span class="n">SHIRT_SIZES</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">Person</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Fred Flintstone&quot;</span><span class="p">,</span> <span class="n">shirt_size</span><span class="o">=</span><span class="s2">&quot;L&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">shirt_size</span>
<span class="go">&#39;L&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">get_shirt_size_display</span><span class="p">()</span>
<span class="go">&#39;Large&#39;</span>
</pre></div>
</div>
<p>列挙型クラスを用いて、<code class="docutils literal notranslate"><span class="pre">choices</span></code> を簡潔に定義することもできます。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">django.db</span><span class="w"> </span><span class="kn">import</span> <span class="n">models</span>


<span class="k">class</span><span class="w"> </span><span class="nc">Runner</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">MedalType</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">TextChoices</span><span class="p">(</span><span class="s2">&quot;MedalType&quot;</span><span class="p">,</span> <span class="s2">&quot;GOLD SILVER BRONZE&quot;</span><span class="p">)</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">60</span><span class="p">)</span>
    <span class="n">medal</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">blank</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">choices</span><span class="o">=</span><span class="n">MedalType</span><span class="p">,</span> <span class="n">max_length</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
<p>さらに他の例は <a class="reference internal" href="../../ref/models/fields.html#field-choices"><span class="std std-ref">モデルフィールドのリファレンス</span></a> で見ることができます。</p>
<div class="versionchanged">
<span class="title">Changed in Django 5.0:</span> <p>マッピングと callable のサポートが追加されました。</p>
</div>
</dd>
<dt><a class="reference internal" href="../../ref/models/fields.html#django.db.models.Field.default" title="django.db.models.Field.default"><code class="xref py py-attr docutils literal notranslate"><span class="pre">default</span></code></a></dt><dd><p>そのフィールドのデフォルト値です。このオプションには特定の値または呼び出し可能オブジェクトを渡すことができます。呼び出し可能オブジェクトの場合、新しくオブジェクトが生成される度に呼び出されます。</p>
</dd>
<dt><a class="reference internal" href="../../ref/models/fields.html#django.db.models.Field.db_default" title="django.db.models.Field.db_default"><code class="xref py py-attr docutils literal notranslate"><span class="pre">db_default</span></code></a></dt><dd><p>フィールドに対するデータベース計算済みのデフォルト値です。リテラル値またはデータベース関数で指定できます。</p>
<p>もし <code class="docutils literal notranslate"><span class="pre">db_default</span></code> と <a class="reference internal" href="../../ref/models/fields.html#django.db.models.Field.default" title="django.db.models.Field.default"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Field.default</span></code></a> の両方が指定された場合、Python コードでインスタンスを作成する際には <code class="docutils literal notranslate"><span class="pre">default</span></code> が優先されます。データベースレベルでも <code class="docutils literal notranslate"><span class="pre">db_default</span></code> が設定され、ORM の外部で行を挿入するときや、マイグレーションで新しいフィールドを追加するときに使用されます。</p>
</dd>
<dt><a class="reference internal" href="../../ref/models/fields.html#django.db.models.Field.help_text" title="django.db.models.Field.help_text"><code class="xref py py-attr docutils literal notranslate"><span class="pre">help_text</span></code></a></dt><dd><p>フォームウィジェットとともに表示される追加の「ヘルプ」テキストです。この値はフィールドがフォームとして利用されない場合でもドキュメントとして役に立ちます。</p>
</dd>
<dt><a class="reference internal" href="../../ref/models/fields.html#django.db.models.Field.primary_key" title="django.db.models.Field.primary_key"><code class="xref py py-attr docutils literal notranslate"><span class="pre">primary_key</span></code></a></dt><dd><p><code class="docutils literal notranslate"><span class="pre">True</span></code> の場合、設定したフィールドはそのモデルの主キーとなります。</p>
<p>定義したモデル内でどのフィールドに対しても <a class="reference internal" href="../../ref/models/fields.html#django.db.models.Field.primary_key" title="django.db.models.Field.primary_key"><code class="xref py py-attr docutils literal notranslate"><span class="pre">primary_key=True</span></code></a> が設定されなかった場合、Django は自動的に主キーを保存するために <a class="reference internal" href="../../ref/models/fields.html#django.db.models.IntegerField" title="django.db.models.IntegerField"><code class="xref py py-class docutils literal notranslate"><span class="pre">IntegerField</span></code></a> を追加します、つまり、その主キーに対するデフォルトの動作を変更する必要がない場合は、どのフィールドに対しても <a class="reference internal" href="../../ref/models/fields.html#django.db.models.Field.primary_key" title="django.db.models.Field.primary_key"><code class="xref py py-attr docutils literal notranslate"><span class="pre">primary_key=True</span></code></a> を設定する必要がありません。詳細は <a class="reference internal" href="#automatic-primary-key-fields"><span class="std std-ref">自動インクリメントのプライマリーキーフィールド</span></a> を参照してください。</p>
<p>プライマリキーのフィールドは読み取り専用です。もし既存のオブジェクトのプライマリキーの値を変更して保存する操作を行うと、既存のオブジェクトに加えて新たなオブジェクトが生成されます。以下に例を示します。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">django.db</span><span class="w"> </span><span class="kn">import</span> <span class="n">models</span>


<span class="k">class</span><span class="w"> </span><span class="nc">Fruit</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fruit</span> <span class="o">=</span> <span class="n">Fruit</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Apple&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fruit</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;Pear&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fruit</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Fruit</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">values_list</span><span class="p">(</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="n">flat</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">&lt;QuerySet [&#39;Apple&#39;, &#39;Pear&#39;]&gt;</span>
</pre></div>
</div>
</dd>
<dt><a class="reference internal" href="../../ref/models/fields.html#django.db.models.Field.unique" title="django.db.models.Field.unique"><code class="xref py py-attr docutils literal notranslate"><span class="pre">unique</span></code></a></dt><dd><p><code class="docutils literal notranslate"><span class="pre">True</span></code> の場合、そのフィールドはテーブル上で一意となる制約を受けます。</p>
</dd>
</dl>
<p>繰り返しになりますが、これらは特によく利用されるフィールドのオプションの概説です。完全な説明は <a class="reference internal" href="../../ref/models/fields.html#common-model-field-options"><span class="std std-ref">共通のフィールドオプションの説明</span></a> で参照できます。</p>
</section>
<section id="s-automatic-primary-key-fields">
<span id="s-id1"></span><span id="automatic-primary-key-fields"></span><span id="id1"></span><h3>自動インクリメントのプライマリーキーフィールド<a class="headerlink" href="#automatic-primary-key-fields" title="Link to this heading">¶</a></h3>
<p>デフォルトでは、Django は各モデルに、 <a class="reference internal" href="../../ref/applications.html#django.apps.AppConfig.default_auto_field" title="django.apps.AppConfig.default_auto_field"><code class="xref py py-attr docutils literal notranslate"><span class="pre">AppConfig.default_auto_field</span></code></a> でアプリごとに指定した型、または <a class="reference internal" href="../../ref/settings.html#std-setting-DEFAULT_AUTO_FIELD"><code class="xref std std-setting docutils literal notranslate"><span class="pre">DEFAULT_AUTO_FIELD</span></code></a> 設定でグローバルに指定した型の自動インクリメントのプライマリキーを付与します。例えば:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">id</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">BigAutoField</span><span class="p">(</span><span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>独自の主キーを設定したい場合は、いずれかのフィールドで <a class="reference internal" href="../../ref/models/fields.html#django.db.models.Field.primary_key" title="django.db.models.Field.primary_key"><code class="xref py py-attr docutils literal notranslate"><span class="pre">primary_key=True</span></code></a> を設定してください。そのようにして明示的に <a class="reference internal" href="../../ref/models/fields.html#django.db.models.Field.primary_key" title="django.db.models.Field.primary_key"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Field.primary_key</span></code></a> が設定されている場合、Djangoは自動的に <code class="docutils literal notranslate"><span class="pre">id</span></code> カラムを追加しません。</p>
<p>各モデルには、<a class="reference internal" href="../../ref/models/fields.html#django.db.models.Field.primary_key" title="django.db.models.Field.primary_key"><code class="xref py py-attr docutils literal notranslate"><span class="pre">primary_key=True</span></code></a> が必ず 1 つだけ (明示的に宣言されるか、自動的に追加されるかのどちらかで) 存在する必要があります。</p>
</section>
<section id="s-verbose-field-names">
<span id="s-id2"></span><span id="verbose-field-names"></span><span id="id2"></span><h3>詳細 (verbose) なフィールド名<a class="headerlink" href="#verbose-field-names" title="Link to this heading">¶</a></h3>
<p><a class="reference internal" href="../../ref/models/fields.html#django.db.models.ForeignKey" title="django.db.models.ForeignKey"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForeignKey</span></code></a>、<a class="reference internal" href="../../ref/models/fields.html#django.db.models.ManyToManyField" title="django.db.models.ManyToManyField"><code class="xref py py-class docutils literal notranslate"><span class="pre">ManyToManyField</span></code></a> 、<a class="reference internal" href="../../ref/models/fields.html#django.db.models.OneToOneField" title="django.db.models.OneToOneField"><code class="xref py py-class docutils literal notranslate"><span class="pre">OneToOneField</span></code></a> を除くすべてのフィールド型は、任意の第 1 引数として &quot;詳細な名前 (verbose name)&quot; を取ります。詳細な名前を指定しない場合、Django はフィールドの属性名のアンダースコアをスペースに変換したものを使って自動的に生成します。</p>
<p>以下の例では、詳細な名前は <code class="docutils literal notranslate"><span class="pre">&quot;person's</span> <span class="pre">first</span> <span class="pre">name&quot;</span></code> です:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">first_name</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="s2">&quot;person&#39;s first name&quot;</span><span class="p">,</span> <span class="n">max_length</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span>
</pre></div>
</div>
<p>以下の例では、詳細な名前は <code class="docutils literal notranslate"><span class="pre">&quot;first</span> <span class="pre">name&quot;</span></code> です:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">first_name</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span>
</pre></div>
</div>
<p><a class="reference internal" href="../../ref/models/fields.html#django.db.models.ForeignKey" title="django.db.models.ForeignKey"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForeignKey</span></code></a>、<a class="reference internal" href="../../ref/models/fields.html#django.db.models.ManyToManyField" title="django.db.models.ManyToManyField"><code class="xref py py-class docutils literal notranslate"><span class="pre">ManyToManyField</span></code></a> 、<a class="reference internal" href="../../ref/models/fields.html#django.db.models.OneToOneField" title="django.db.models.OneToOneField"><code class="xref py py-class docutils literal notranslate"><span class="pre">OneToOneField</span></code></a> の 3 つは最初の引数にモデルクラスを必要とするので、<a class="reference internal" href="../../ref/models/fields.html#django.db.models.Field.verbose_name" title="django.db.models.Field.verbose_name"><code class="xref py py-attr docutils literal notranslate"><span class="pre">verbose_name</span></code></a> キーワード引数を使用してください:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">poll</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">ForeignKey</span><span class="p">(</span>
    <span class="n">Poll</span><span class="p">,</span>
    <span class="n">on_delete</span><span class="o">=</span><span class="n">models</span><span class="o">.</span><span class="n">CASCADE</span><span class="p">,</span>
    <span class="n">verbose_name</span><span class="o">=</span><span class="s2">&quot;the related poll&quot;</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">sites</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">ManyToManyField</span><span class="p">(</span><span class="n">Site</span><span class="p">,</span> <span class="n">verbose_name</span><span class="o">=</span><span class="s2">&quot;list of sites&quot;</span><span class="p">)</span>
<span class="n">place</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">OneToOneField</span><span class="p">(</span>
    <span class="n">Place</span><span class="p">,</span>
    <span class="n">on_delete</span><span class="o">=</span><span class="n">models</span><span class="o">.</span><span class="n">CASCADE</span><span class="p">,</span>
    <span class="n">verbose_name</span><span class="o">=</span><span class="s2">&quot;related place&quot;</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>
</div>
<p>慣習的に、<a class="reference internal" href="../../ref/models/fields.html#django.db.models.Field.verbose_name" title="django.db.models.Field.verbose_name"><code class="xref py py-attr docutils literal notranslate"><span class="pre">verbose_name</span></code></a> の最初の文字は大文字にしません。必要に応じて Django が自動的に変換します。</p>
</section>
<section id="s-relationships">
<span id="relationships"></span><h3>リレーションシップ<a class="headerlink" href="#relationships" title="Link to this heading">¶</a></h3>
<p>リレーショナルデータベースの強力さがテーブル同士の関係によって決まることは疑いがありません。Dango では、最も一般的な 3 つのデータベースリレーションシップを定義しています。多対 1、多対多、1 対 1 です。</p>
<section id="s-many-to-one-relationships">
<span id="many-to-one-relationships"></span><h4>多対一 (many-to-one) 関係<a class="headerlink" href="#many-to-one-relationships" title="Link to this heading">¶</a></h4>
<p>多対 1 の関係を定義するには、<a class="reference internal" href="../../ref/models/fields.html#django.db.models.ForeignKey" title="django.db.models.ForeignKey"><code class="xref py py-class docutils literal notranslate"><span class="pre">django.db.models.ForeignKey</span></code></a> を使用します。使い方は他の <a class="reference internal" href="../../ref/models/fields.html#django.db.models.Field" title="django.db.models.Field"><code class="xref py py-class docutils literal notranslate"><span class="pre">Field</span></code></a> 型と同様で、モデルのクラス属性として書いてください。</p>
<p><a class="reference internal" href="../../ref/models/fields.html#django.db.models.ForeignKey" title="django.db.models.ForeignKey"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForeignKey</span></code></a> には位置引数が1つ必要で、ここにはモデルと関係付けるクラスを指定します。</p>
<p>たとえば、<code class="docutils literal notranslate"><span class="pre">Car</span></code> モデル <code class="docutils literal notranslate"><span class="pre">Manufacturer</span></code> を持っている場合、つまり、 <code class="docutils literal notranslate"><span class="pre">Manufacturer</span></code> は複数の car を作る一方で <code class="docutils literal notranslate"><span class="pre">Car</span></code> は 1 つしか <code class="docutils literal notranslate"><span class="pre">Manufacturer</span></code> を持たない場合、以下の定義を使用してください。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">django.db</span><span class="w"> </span><span class="kn">import</span> <span class="n">models</span>


<span class="k">class</span><span class="w"> </span><span class="nc">Manufacturer</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="c1"># ...</span>
    <span class="k">pass</span>


<span class="k">class</span><span class="w"> </span><span class="nc">Car</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">manufacturer</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">ForeignKey</span><span class="p">(</span><span class="n">Manufacturer</span><span class="p">,</span> <span class="n">on_delete</span><span class="o">=</span><span class="n">models</span><span class="o">.</span><span class="n">CASCADE</span><span class="p">)</span>
    <span class="c1"># ...</span>
</pre></div>
</div>
<p><a class="reference internal" href="../../ref/models/fields.html#recursive-relationships"><span class="std std-ref">再帰的なリレーションシップ</span></a> (自分自身に対する多対 1 の関係を持つオブジェクト) や <a class="reference internal" href="../../ref/models/fields.html#lazy-relationships"><span class="std std-ref">まだ定義されていないモデルへのリレーションシップ</span></a> を作成することもできます。詳細は <a class="reference internal" href="../../ref/models/fields.html#ref-foreignkey"><span class="std std-ref">モデルフィールドのリファレンス</span></a> を参照してください。</p>
<p>必須ではありませんが、<a class="reference internal" href="../../ref/models/fields.html#django.db.models.ForeignKey" title="django.db.models.ForeignKey"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForeignKey</span></code></a> フィールド名 (上記の例では <code class="docutils literal notranslate"><span class="pre">manufacturer</span></code>) はモデル名を小文字にしたものをおすすめします。もちろん、どんなフィールドでも呼び出すことができます。例えば、以下のようなフィールド名にすることも可能です。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Car</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">company_that_makes_it</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">ForeignKey</span><span class="p">(</span>
        <span class="n">Manufacturer</span><span class="p">,</span>
        <span class="n">on_delete</span><span class="o">=</span><span class="n">models</span><span class="o">.</span><span class="n">CASCADE</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="c1"># ...</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">参考</p>
<p><a class="reference internal" href="../../ref/models/fields.html#django.db.models.ForeignKey" title="django.db.models.ForeignKey"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForeignKey</span></code></a> フィールドは多数の追加的な引数を受け入れます。これらは <a class="reference internal" href="../../ref/models/fields.html#foreign-key-arguments"><span class="std std-ref">モデルフィールドのリファレンス</span></a> にて説明しています。これらの引数は、リレーションシップがどのように動作すべきかを定義するのに役立ちます。追加の引数はすべて任意です。</p>
<p>逆方向のリレーションシップを持つオブジェクトへのアクセスの詳細については、下記の <a class="reference internal" href="queries.html#backwards-related-objects"><span class="std std-ref">逆方向のリレーションシップの例</span></a> を参照してください。</p>
<p>サンプルのコードは、<a class="reference internal" href="examples/many_to_one.html"><span class="doc">多対多のリレーションシップモデルの例</span></a> を参照してください。</p>
</div>
</section>
<section id="s-many-to-many-relationships">
<span id="many-to-many-relationships"></span><h4>多対多 (many-to-many) 関係<a class="headerlink" href="#many-to-many-relationships" title="Link to this heading">¶</a></h4>
<p>多対多のリレーションシップを定義するには、<a class="reference internal" href="../../ref/models/fields.html#django.db.models.ManyToManyField" title="django.db.models.ManyToManyField"><code class="xref py py-class docutils literal notranslate"><span class="pre">django.db.models.ManyToManyField</span></code></a> を使用してください。使い方は他の <a class="reference internal" href="../../ref/models/fields.html#django.db.models.Field" title="django.db.models.Field"><code class="xref py py-class docutils literal notranslate"><span class="pre">Field</span></code></a> 型と同じです。モデルのクラス属性として含めてください。</p>
<p><a class="reference internal" href="../../ref/models/fields.html#django.db.models.ManyToManyField" title="django.db.models.ManyToManyField"><code class="xref py py-class docutils literal notranslate"><span class="pre">ManyToManyField</span></code></a> には位置引数として、モデルと関係させるクラスを指定する必要があります。</p>
<p>たとえば、<code class="docutils literal notranslate"><span class="pre">Pizza</span></code> が複数の <code class="docutils literal notranslate"><span class="pre">Topping</span></code> オブジェクトを持っている（そして <code class="docutils literal notranslate"><span class="pre">Topping</span></code> は複数の pizza に載ることができ <code class="docutils literal notranslate"><span class="pre">Pizza</span></code> は複数の topping を持つ）場合、以下のように表現できます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">django.db</span><span class="w"> </span><span class="kn">import</span> <span class="n">models</span>


<span class="k">class</span><span class="w"> </span><span class="nc">Topping</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="c1"># ...</span>
    <span class="k">pass</span>


<span class="k">class</span><span class="w"> </span><span class="nc">Pizza</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="c1"># ...</span>
    <span class="n">toppings</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">ManyToManyField</span><span class="p">(</span><span class="n">Topping</span><span class="p">)</span>
</pre></div>
</div>
<p><a class="reference internal" href="../../ref/models/fields.html#django.db.models.ForeignKey" title="django.db.models.ForeignKey"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForeignKey</span></code></a> と同様に、<a class="reference internal" href="../../ref/models/fields.html#recursive-relationships"><span class="std std-ref">再帰的なリレーションシップ</span></a> (自分自身に対する多対多のリレーションシップを持つオブジェクト) や <a class="reference internal" href="../../ref/models/fields.html#lazy-relationships"><span class="std std-ref">まだ定義されていないモデルへのリレーションシップ</span></a> を作成することもできます。</p>
<p>必須ではありませんが、<a class="reference internal" href="../../ref/models/fields.html#django.db.models.ManyToManyField" title="django.db.models.ManyToManyField"><code class="xref py py-class docutils literal notranslate"><span class="pre">ManyToManyField</span></code></a> フィールド (上記の例では <code class="docutils literal notranslate"><span class="pre">toppings</span></code>) はリレーション先のモデルオブジェクトの複数形が推奨されています。</p>
<p>どちらのフィールドに <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ManyToManyField" title="django.db.models.ManyToManyField"><code class="xref py py-class docutils literal notranslate"><span class="pre">ManyToManyField</span></code></a> を定義しても構いませんが、片方のフィールドのみに定義するようにしてください -- 両方ではありません。</p>
<p>一般的に、 <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ManyToManyField" title="django.db.models.ManyToManyField"><code class="xref py py-class docutils literal notranslate"><span class="pre">ManyToManyField</span></code></a> インスタンスは、フォームで編集されるオブジェクトの側にあります。上の例では、 <code class="docutils literal notranslate"><span class="pre">toppings</span></code> は <code class="docutils literal notranslate"><span class="pre">Pizza</span></code> の中にあります (<code class="docutils literal notranslate"><span class="pre">Topping</span></code> が <code class="docutils literal notranslate"><span class="pre">pizzas</span></code> の <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ManyToManyField" title="django.db.models.ManyToManyField"><code class="xref py py-class docutils literal notranslate"><span class="pre">ManyToManyField</span></code></a> を持つとするよりはそのほうがいいでしょう)。というのは、ピザが複数のトッピングを持つほうが、トッピングが複数のピザの上にあるというよりも自然だからです。このようにすることで、ユーザは <code class="docutils literal notranslate"><span class="pre">Pizza</span></code> フォームでトッピングを選ぶことができるようになります。</p>
<div class="admonition seealso">
<p class="admonition-title">参考</p>
<p>完全な実装例は <a class="reference internal" href="examples/many_to_many.html"><span class="doc">多対多のリレーションシップモデルの例</span></a> を参照してください。</p>
</div>
<p><a class="reference internal" href="../../ref/models/fields.html#django.db.models.ManyToManyField" title="django.db.models.ManyToManyField"><code class="xref py py-class docutils literal notranslate"><span class="pre">ManyToManyField</span></code></a> フィールドは多数の追加的な引数を受け入れます。これらは <a class="reference internal" href="../../ref/models/fields.html#manytomany-arguments"><span class="std std-ref">モデルフィールドのリファレンス</span></a> にて説明しています。これらの引数は、リレーションシップがどのように動作すべきかを定義するのに役立ちます。引数はすべて任意です。</p>
</section>
<section id="s-extra-fields-on-many-to-many-relationships">
<span id="s-intermediary-manytomany"></span><span id="extra-fields-on-many-to-many-relationships"></span><span id="intermediary-manytomany"></span><h4>多対多のリレーションシップにおける追加フィールド<a class="headerlink" href="#extra-fields-on-many-to-many-relationships" title="Link to this heading">¶</a></h4>
<p>ピザとトッピングを組み合わせる程度の多対多リレーションを扱うのであれば、標準の <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ManyToManyField" title="django.db.models.ManyToManyField"><code class="xref py py-class docutils literal notranslate"><span class="pre">ManyToManyField</span></code></a> で十分でしょう。しかし、2 つのモデルのリレーションに他のデータを付加したくなることもあります。</p>
<p>たとえば、ミュージシャンが所属する音楽グループを追跡するアプリについて考えてみましょう。ミュージシャンとグループの間には多対多の関係があるので、この関係を表すのに <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ManyToManyField" title="django.db.models.ManyToManyField"><code class="xref py py-class docutils literal notranslate"><span class="pre">ManyToManyField</span></code></a> が使えます。しかし、ある人がそのグループに加入した日などといった多くの詳細情報も集めたいとします。</p>
<p>このような場合、 Django ではそのような多対多のリレーションシップを規定するのに使われるモデルを指定できます。そうすることで、中間モデルに追加のフィールドを配置できます。中間モデルは、 <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ManyToManyField.through" title="django.db.models.ManyToManyField.through"><code class="xref py py-attr docutils literal notranslate"><span class="pre">through</span></code></a> 引数で中間として振る舞うモデルを指定することで、 <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ManyToManyField" title="django.db.models.ManyToManyField"><code class="xref py py-class docutils literal notranslate"><span class="pre">ManyToManyField</span></code></a> に紐付けることができます。ミュージシャンの例では、コードはこのようになるでしょう:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">django.db</span><span class="w"> </span><span class="kn">import</span> <span class="n">models</span>


<span class="k">class</span><span class="w"> </span><span class="nc">Person</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">128</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>


<span class="k">class</span><span class="w"> </span><span class="nc">Group</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">128</span><span class="p">)</span>
    <span class="n">members</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">ManyToManyField</span><span class="p">(</span><span class="n">Person</span><span class="p">,</span> <span class="n">through</span><span class="o">=</span><span class="s2">&quot;Membership&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>


<span class="k">class</span><span class="w"> </span><span class="nc">Membership</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">person</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">ForeignKey</span><span class="p">(</span><span class="n">Person</span><span class="p">,</span> <span class="n">on_delete</span><span class="o">=</span><span class="n">models</span><span class="o">.</span><span class="n">CASCADE</span><span class="p">)</span>
    <span class="n">group</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">ForeignKey</span><span class="p">(</span><span class="n">Group</span><span class="p">,</span> <span class="n">on_delete</span><span class="o">=</span><span class="n">models</span><span class="o">.</span><span class="n">CASCADE</span><span class="p">)</span>
    <span class="n">date_joined</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">DateField</span><span class="p">()</span>
    <span class="n">invite_reason</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">64</span><span class="p">)</span>
</pre></div>
</div>
<p>中間モデルを指定する場合は、多対多のリレーションシップに参加するモデルに対する外部キーを明示的に指定します。明示的に指定することで、ふたつのモデルがどのように関係するかが定義されます。</p>
<p>中間モデルにはいくつかの制約があります。</p>
<ul class="simple">
<li><p>中間モデルには、ソースモデル（この例では <code class="docutils literal notranslate"><span class="pre">Group</span></code> ）への外部キーが <em>ただ1つだけ</em> 含まれている必要があります。または、Djangoがリレーションシップに使用すべき外部キーを <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ManyToManyField.through_fields" title="django.db.models.ManyToManyField.through_fields"><code class="xref py py-attr docutils literal notranslate"><span class="pre">ManyToManyField.through_fields</span></code></a> を使用して明示的に指定する必要があります。もし複数の外部キーがあり、 <code class="docutils literal notranslate"><span class="pre">through_fields</span></code> が指定されていない場合、バリデーションエラーが発生します。ターゲットモデル（この例では <code class="docutils literal notranslate"><span class="pre">Person</span></code> ）への外部キーにも同様の制限が適用されます。</p></li>
<li><p>中間モデルを介して自分自身と多対多のリレーションシップを持つモデルの場合、同じモデルに対する2つの外部キーは許可されますが、多対多のリレーションシップの2つの（異なる）側として扱われます。しかし、2つ以上の外部キーがある場合は、上記のように <code class="docutils literal notranslate"><span class="pre">through_fields</span></code> も指定しなければなりません。</p></li>
</ul>
<p>これで <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ManyToManyField" title="django.db.models.ManyToManyField"><code class="xref py py-class docutils literal notranslate"><span class="pre">ManyToManyField</span></code></a> が中間モデル (この場合は <code class="docutils literal notranslate"><span class="pre">Membership</span></code>) を使うように設定できたので、多対多のリレーションシップを作成する準備ができました。これを行うには、中間モデルのインスタンスを作成します:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ringo</span> <span class="o">=</span> <span class="n">Person</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Ringo Starr&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">paul</span> <span class="o">=</span> <span class="n">Person</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Paul McCartney&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">beatles</span> <span class="o">=</span> <span class="n">Group</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;The Beatles&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m1</span> <span class="o">=</span> <span class="n">Membership</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">person</span><span class="o">=</span><span class="n">ringo</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">group</span><span class="o">=</span><span class="n">beatles</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">date_joined</span><span class="o">=</span><span class="n">date</span><span class="p">(</span><span class="mi">1962</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">16</span><span class="p">),</span>
<span class="gp">... </span>    <span class="n">invite_reason</span><span class="o">=</span><span class="s2">&quot;Needed a new drummer.&quot;</span><span class="p">,</span>
<span class="gp">... </span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m1</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">beatles</span><span class="o">.</span><span class="n">members</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
<span class="go">&lt;QuerySet [&lt;Person: Ringo Starr&gt;]&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ringo</span><span class="o">.</span><span class="n">group_set</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
<span class="go">&lt;QuerySet [&lt;Group: The Beatles&gt;]&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m2</span> <span class="o">=</span> <span class="n">Membership</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">person</span><span class="o">=</span><span class="n">paul</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">group</span><span class="o">=</span><span class="n">beatles</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">date_joined</span><span class="o">=</span><span class="n">date</span><span class="p">(</span><span class="mi">1960</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
<span class="gp">... </span>    <span class="n">invite_reason</span><span class="o">=</span><span class="s2">&quot;Wanted to form a band.&quot;</span><span class="p">,</span>
<span class="gp">... </span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">beatles</span><span class="o">.</span><span class="n">members</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
<span class="go">&lt;QuerySet [&lt;Person: Ringo Starr&gt;, &lt;Person: Paul McCartney&gt;]&gt;</span>
</pre></div>
</div>
<p>また、 <a class="reference internal" href="../../ref/models/relations.html#django.db.models.fields.related.RelatedManager.add" title="django.db.models.fields.related.RelatedManager.add"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add()</span></code></a> や <a class="reference internal" href="../../ref/models/relations.html#django.db.models.fields.related.RelatedManager.create" title="django.db.models.fields.related.RelatedManager.create"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create()</span></code></a> 、 <a class="reference internal" href="../../ref/models/relations.html#django.db.models.fields.related.RelatedManager.set" title="django.db.models.fields.related.RelatedManager.set"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set()</span></code></a> を使ってリレーションシップを作成することもできます（<code class="docutils literal notranslate"><span class="pre">through_defaults</span></code> フィールドの指定は必須です）:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">beatles</span><span class="o">.</span><span class="n">members</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">john</span><span class="p">,</span> <span class="n">through_defaults</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;date_joined&quot;</span><span class="p">:</span> <span class="n">date</span><span class="p">(</span><span class="mi">1960</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">1</span><span class="p">)})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">beatles</span><span class="o">.</span><span class="n">members</span><span class="o">.</span><span class="n">create</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">name</span><span class="o">=</span><span class="s2">&quot;George Harrison&quot;</span><span class="p">,</span> <span class="n">through_defaults</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;date_joined&quot;</span><span class="p">:</span> <span class="n">date</span><span class="p">(</span><span class="mi">1960</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">1</span><span class="p">)}</span>
<span class="gp">... </span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">beatles</span><span class="o">.</span><span class="n">members</span><span class="o">.</span><span class="n">set</span><span class="p">(</span>
<span class="gp">... </span>    <span class="p">[</span><span class="n">john</span><span class="p">,</span> <span class="n">paul</span><span class="p">,</span> <span class="n">ringo</span><span class="p">,</span> <span class="n">george</span><span class="p">],</span> <span class="n">through_defaults</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;date_joined&quot;</span><span class="p">:</span> <span class="n">date</span><span class="p">(</span><span class="mi">1960</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">1</span><span class="p">)}</span>
<span class="gp">... </span><span class="p">)</span>
</pre></div>
</div>
<p>中間モデルのインスタンスを直接作成したいこともあるでしょう。</p>
<p>中間モデルで定義されたカスタムスルーテーブルが <code class="docutils literal notranslate"><span class="pre">(model1,</span> <span class="pre">model2)</span></code> ペアの一意性を強制せず、複数の値を許容する場合、 <a class="reference internal" href="../../ref/models/relations.html#django.db.models.fields.related.RelatedManager.remove" title="django.db.models.fields.related.RelatedManager.remove"><code class="xref py py-meth docutils literal notranslate"><span class="pre">remove()</span></code></a> 呼び出しは全ての中間モデルインスタンスを削除します:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Membership</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">person</span><span class="o">=</span><span class="n">ringo</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">group</span><span class="o">=</span><span class="n">beatles</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">date_joined</span><span class="o">=</span><span class="n">date</span><span class="p">(</span><span class="mi">1968</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
<span class="gp">... </span>    <span class="n">invite_reason</span><span class="o">=</span><span class="s2">&quot;You&#39;ve been gone for a month and we miss you.&quot;</span><span class="p">,</span>
<span class="gp">... </span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">beatles</span><span class="o">.</span><span class="n">members</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
<span class="go">&lt;QuerySet [&lt;Person: Ringo Starr&gt;, &lt;Person: Paul McCartney&gt;, &lt;Person: Ringo Starr&gt;]&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># This deletes both of the intermediate model instances for Ringo Starr</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">beatles</span><span class="o">.</span><span class="n">members</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">ringo</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">beatles</span><span class="o">.</span><span class="n">members</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
<span class="go">&lt;QuerySet [&lt;Person: Paul McCartney&gt;]&gt;</span>
</pre></div>
</div>
<p><a class="reference internal" href="../../ref/models/relations.html#django.db.models.fields.related.RelatedManager.clear" title="django.db.models.fields.related.RelatedManager.clear"><code class="xref py py-meth docutils literal notranslate"><span class="pre">clear()</span></code></a> メソッドを使用すると、インスタンスの多対多の関係を全て削除できます:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Beatles have broken up</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">beatles</span><span class="o">.</span><span class="n">members</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Note that this deletes the intermediate model instances</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Membership</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
<span class="go">&lt;QuerySet []&gt;</span>
</pre></div>
</div>
<p>多対多のリレーションシップを確立したら、クエリを発行できます。通常の多対多のリレーションシップと同様に、多対多のリレーション先モデルの属性を使用してクエリを発行できます:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="go"># Find all the groups with a member whose name starts with &#39;Paul&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Group</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">members__name__startswith</span><span class="o">=</span><span class="s2">&quot;Paul&quot;</span><span class="p">)</span>
<span class="go">&lt;QuerySet [&lt;Group: The Beatles&gt;]&gt;</span>
</pre></div>
</div>
<p>中間モデルを使用しているので、その属性に対してクエリを実行することもできます:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="go"># Find all the members of the Beatles that joined after 1 Jan 1961</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Person</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">group__name</span><span class="o">=</span><span class="s2">&quot;The Beatles&quot;</span><span class="p">,</span> <span class="n">membership__date_joined__gt</span><span class="o">=</span><span class="n">date</span><span class="p">(</span><span class="mi">1961</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">... </span><span class="p">)</span>
<span class="go">&lt;QuerySet [&lt;Person: Ringo Starr]&gt;</span>
</pre></div>
</div>
<p>会員情報にアクセスする必要がある場合は、直接 <code class="docutils literal notranslate"><span class="pre">Membership</span></code> モデルにクエリを発行してください:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ringos_membership</span> <span class="o">=</span> <span class="n">Membership</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">group</span><span class="o">=</span><span class="n">beatles</span><span class="p">,</span> <span class="n">person</span><span class="o">=</span><span class="n">ringo</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ringos_membership</span><span class="o">.</span><span class="n">date_joined</span>
<span class="go">datetime.date(1962, 8, 16)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ringos_membership</span><span class="o">.</span><span class="n">invite_reason</span>
<span class="go">&#39;Needed a new drummer.&#39;</span>
</pre></div>
</div>
<p>同じ情報にアクセスするもう一つの方法は、 <code class="docutils literal notranslate"><span class="pre">Person</span></code> オブジェクトから <a class="reference internal" href="queries.html#m2m-reverse-relationships"><span class="std std-ref">多対多の逆リレーションシップ</span></a> を問い合わせることです:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ringos_membership</span> <span class="o">=</span> <span class="n">ringo</span><span class="o">.</span><span class="n">membership_set</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">group</span><span class="o">=</span><span class="n">beatles</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ringos_membership</span><span class="o">.</span><span class="n">date_joined</span>
<span class="go">datetime.date(1962, 8, 16)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ringos_membership</span><span class="o">.</span><span class="n">invite_reason</span>
<span class="go">&#39;Needed a new drummer.&#39;</span>
</pre></div>
</div>
</section>
<section id="s-one-to-one-relationships">
<span id="one-to-one-relationships"></span><h4>一対一 (one-to-one) 関係<a class="headerlink" href="#one-to-one-relationships" title="Link to this heading">¶</a></h4>
<p>1対1のリレーションシップを定義するには、 <a class="reference internal" href="../../ref/models/fields.html#django.db.models.OneToOneField" title="django.db.models.OneToOneField"><code class="xref py py-class docutils literal notranslate"><span class="pre">OneToOneField</span></code></a> を使用します。これは他の <code class="docutils literal notranslate"><span class="pre">Field</span></code> タイプと同様、モデルのクラス属性として書きます。</p>
<p>あるオブジェクトが他のオブジェクトを何らかの方法で「拡張 (extends)」しているとき、オブジェクトの主キーに設定するのが最も便利です。</p>
<p><a class="reference internal" href="../../ref/models/fields.html#django.db.models.OneToOneField" title="django.db.models.OneToOneField"><code class="xref py py-class docutils literal notranslate"><span class="pre">OneToOneField</span></code></a> には1つの位置引数として、モデルと関係させるクラスを指定する必要があります。</p>
<p>例えば、&quot;場所&quot; のデータベースを構築する場合、住所や電話番号などの標準的なものをデータベースに構築します。そして、その場所の上にレストランのデータベースを構築したい場合、 <code class="docutils literal notranslate"><span class="pre">Restaurant</span></code> モデルにこれらのフィールドを複製する代わりに、 <code class="docutils literal notranslate"><span class="pre">Restaurant</span></code> に <code class="docutils literal notranslate"><span class="pre">Place</span></code> に対する <a class="reference internal" href="../../ref/models/fields.html#django.db.models.OneToOneField" title="django.db.models.OneToOneField"><code class="xref py py-class docutils literal notranslate"><span class="pre">OneToOneField</span></code></a> を持たせることができます (レストランは「場所」だからです。実際、これを扱うには、暗黙の一対一関係を含む <a class="reference internal" href="#model-inheritance"><span class="std std-ref">継承</span></a> を使うのが一般的です)。</p>
<p><a class="reference internal" href="../../ref/models/fields.html#django.db.models.ForeignKey" title="django.db.models.ForeignKey"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForeignKey</span></code></a> と同様に、<a class="reference internal" href="../../ref/models/fields.html#recursive-relationships"><span class="std std-ref">再帰的なリレーションシップ</span></a> や <a class="reference internal" href="../../ref/models/fields.html#lazy-relationships"><span class="std std-ref">まだ定義されていないモデルへの参照</span></a> を作成することもできます。</p>
<div class="admonition seealso">
<p class="admonition-title">参考</p>
<p>完全な実装例は、<a class="reference internal" href="examples/one_to_one.html"><span class="doc">1対1リレーションモデルの例</span></a> を参照してください。</p>
</div>
<p><a class="reference internal" href="../../ref/models/fields.html#django.db.models.OneToOneField" title="django.db.models.OneToOneField"><code class="xref py py-class docutils literal notranslate"><span class="pre">OneToOneField</span></code></a> フィールドには、オプションの <a class="reference internal" href="../../ref/models/fields.html#django.db.models.OneToOneField.parent_link" title="django.db.models.OneToOneField.parent_link"><code class="xref py py-attr docutils literal notranslate"><span class="pre">parent_link</span></code></a> 引数を指定することもできます。</p>
<p>以前は <a class="reference internal" href="../../ref/models/fields.html#django.db.models.OneToOneField" title="django.db.models.OneToOneField"><code class="xref py py-class docutils literal notranslate"><span class="pre">OneToOneField</span></code></a> クラスが自動的にモデルのプライマリキーになっていました。しかし、現在はそうではありません (手動で <a class="reference internal" href="../../ref/models/fields.html#django.db.models.Field.primary_key" title="django.db.models.Field.primary_key"><code class="xref py py-attr docutils literal notranslate"><span class="pre">primary_key</span></code></a> 引数を渡すこともできます)。このため、1つのモデルに <a class="reference internal" href="../../ref/models/fields.html#django.db.models.OneToOneField" title="django.db.models.OneToOneField"><code class="xref py py-class docutils literal notranslate"><span class="pre">OneToOneField</span></code></a> 型のフィールドを複数持つことができるようになりました。</p>
</section>
</section>
<section id="s-models-across-files">
<span id="models-across-files"></span><h3>ファイルを横断したモデル<a class="headerlink" href="#models-across-files" title="Link to this heading">¶</a></h3>
<p>モデルを他のアプリのモデルと関連付けることも全く問題ありません。これを行うには、モデルが定義されているファイルの先頭で、関連するモデルをインポートします。そして、必要なところで他のモデルクラスを参照してください。たとえば、次のようにします:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">django.db</span><span class="w"> </span><span class="kn">import</span> <span class="n">models</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">geography.models</span><span class="w"> </span><span class="kn">import</span> <span class="n">ZipCode</span>


<span class="k">class</span><span class="w"> </span><span class="nc">Restaurant</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="c1"># ...</span>
    <span class="n">zip_code</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">ForeignKey</span><span class="p">(</span>
        <span class="n">ZipCode</span><span class="p">,</span>
        <span class="n">on_delete</span><span class="o">=</span><span class="n">models</span><span class="o">.</span><span class="n">SET_NULL</span><span class="p">,</span>
        <span class="n">blank</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">null</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span>
</pre></div>
</div>
</section>
<section id="s-field-name-restrictions">
<span id="field-name-restrictions"></span><h3>フィールド名の制約<a class="headerlink" href="#field-name-restrictions" title="Link to this heading">¶</a></h3>
<p>Django はモデルのフィールド名にいくつかの制約を課しています。</p>
<ol class="arabic">
<li><p>フィールド名はPythonの予約語にはできません。Pythonの構文エラーになるからです。たとえば次のようなものです:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>class Example(models.Model):
    pass = models.IntegerField() # &#39;pass&#39; is a reserved word!
</pre></div>
</div>
</li>
<li><p>フィールド名には連続したアンダースコアを2つ以上含めることはできません。これはDjangoのクエリルックアップ構文のためです。たとえば次のようなものです:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Example</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">foo__bar</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">IntegerField</span><span class="p">()</span>  <span class="c1"># &#39;foo__bar&#39; has two underscores!</span>
</pre></div>
</div>
</li>
<li><p>同様の理由で、フィールド名の最後をアンダースコアにすることはできません。</p></li>
</ol>
<p>しかし、これらの制約を回避する手段はあります。なぜなら、フィールド名は必ずしもデータベースのカラム名と一致する必要はないからです。詳細については <a class="reference internal" href="../../ref/models/fields.html#django.db.models.Field.db_column" title="django.db.models.Field.db_column"><code class="xref py py-attr docutils literal notranslate"><span class="pre">db_column</span></code></a> オプションをご覧ください。</p>
<p>ただし、<code class="docutils literal notranslate"><span class="pre">join</span></code>、<code class="docutils literal notranslate"><span class="pre">where</span></code>、<code class="docutils literal notranslate"><span class="pre">select</span></code> などの SQL の予約語はモデルのフィールド名に使用できます。これは、Django がすべての SQL クエリに対して、データベースデーブル名とカラム名のエスケープを行っているためです。エスケープ処理では、使用しているデータベースエンジンのクオート構文を利用しています。</p>
</section>
<section id="s-custom-field-types">
<span id="custom-field-types"></span><h3>カスタムのフィールドタイプ<a class="headerlink" href="#custom-field-types" title="Link to this heading">¶</a></h3>
<p>既存のモデルフィールドが目的に適わない場合、あるいは一般的ではないデータベースカラム型を利用したいと考えチエル場合、独自のフィールドクラスを作成できます。自分自身のフィールドを作成する方法は、<a class="reference internal" href="../../howto/custom-model-fields.html"><span class="doc">カスタムのモデルフィールドを作成する</span></a> で提供しています。</p>
</section>
</section>
<section id="s-meta-options">
<span id="s-id3"></span><span id="meta-options"></span><span id="id3"></span><h2><code class="docutils literal notranslate"><span class="pre">Meta</span></code> オプション<a class="headerlink" href="#meta-options" title="Link to this heading">¶</a></h2>
<p>内側に <code class="docutils literal notranslate"><span class="pre">class</span> <span class="pre">Meta</span></code> というクラスを定義することで、モデルのメタデータを設定できます。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">django.db</span><span class="w"> </span><span class="kn">import</span> <span class="n">models</span>


<span class="k">class</span><span class="w"> </span><span class="nc">Ox</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">horn_length</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">IntegerField</span><span class="p">()</span>

    <span class="k">class</span><span class="w"> </span><span class="nc">Meta</span><span class="p">:</span>
        <span class="n">ordering</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;horn_length&quot;</span><span class="p">]</span>
        <span class="n">verbose_name_plural</span> <span class="o">=</span> <span class="s2">&quot;oxen&quot;</span>
</pre></div>
</div>
<p>モデルのメタデータには「フィールド以外のすべての事項」が設定できます。例えば、並び替えオプション (<a class="reference internal" href="../../ref/models/options.html#django.db.models.Options.ordering" title="django.db.models.Options.ordering"><code class="xref py py-attr docutils literal notranslate"><span class="pre">ordering</span></code></a>)、データベースのテーブル名 (<a class="reference internal" href="../../ref/models/options.html#django.db.models.Options.db_table" title="django.db.models.Options.db_table"><code class="xref py py-attr docutils literal notranslate"><span class="pre">db_table</span></code></a>)、人が読むための単数形と複数形の名前 (<a class="reference internal" href="../../ref/models/options.html#django.db.models.Options.verbose_name" title="django.db.models.Options.verbose_name"><code class="xref py py-attr docutils literal notranslate"><span class="pre">verbose_name</span></code></a> と <a class="reference internal" href="../../ref/models/options.html#django.db.models.Options.verbose_name_plural" title="django.db.models.Options.verbose_name_plural"><code class="xref py py-attr docutils literal notranslate"><span class="pre">verbose_name_plural</span></code></a>) などです。必須のものはなく、<code class="docutils literal notranslate"><span class="pre">class</span> <span class="pre">Meta</span></code> のモデルへの追加は完全にオプションです。</p>
<p><code class="docutils literal notranslate"><span class="pre">Meta</span></code> に指定できるオプションの完全なリストは、<a class="reference internal" href="../../ref/models/options.html"><span class="doc">モデルオプションリファレンス</span></a> で確認できます。</p>
</section>
<section id="s-model-attributes">
<span id="s-id4"></span><span id="model-attributes"></span><span id="id4"></span><h2>モデルの属性<a class="headerlink" href="#model-attributes" title="Link to this heading">¶</a></h2>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">objects</span></code></dt><dd><p>モデルの最も重要な属性は <a class="reference internal" href="managers.html#django.db.models.Manager" title="django.db.models.Manager"><code class="xref py py-class docutils literal notranslate"><span class="pre">Manager</span></code></a> です。これは、Django のモデルにデータベースクエリの操作を渡すインターフェースで、データベースから <a class="reference internal" href="queries.html#retrieving-objects"><span class="std std-ref">インスタンスを取り出す</span></a> ために使われます。<code class="docutils literal notranslate"><span class="pre">Manager</span></code> が定義されていない場合、デフォルトの名前は <a class="reference internal" href="../../ref/models/class.html#django.db.models.Model.objects" title="django.db.models.Model.objects"><code class="xref py py-attr docutils literal notranslate"><span class="pre">objects</span></code></a> となります。マネージャはモデルクラスを通じてのみアクセスできます。インスタンスからはアクセスできません。</p>
</dd>
</dl>
</section>
<section id="s-model-methods">
<span id="s-id5"></span><span id="model-methods"></span><span id="id5"></span><h2>モデルのメソッド<a class="headerlink" href="#model-methods" title="Link to this heading">¶</a></h2>
<p>オブジェクトに独自の &quot;行レベルの&quot; 機能を追加するには、カスタムのメソッドを定義してください。<a class="reference internal" href="managers.html#django.db.models.Manager" title="django.db.models.Manager"><code class="xref py py-class docutils literal notranslate"><span class="pre">Manager</span></code></a> メソッドは &quot;テーブル単位の&quot; 操作をするように意図されており、モデルメソッドは特定のモデルインスタンス上で動作します。</p>
<p>これは、ビジネスロジックを 1 つの場所（モデル）で管理するための重要なテクニックです。</p>
<p>例えば、以下のモデルはいくつかのカスタムメソッドを持ちます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">django.db</span><span class="w"> </span><span class="kn">import</span> <span class="n">models</span>


<span class="k">class</span><span class="w"> </span><span class="nc">Person</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">first_name</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">50</span><span class="p">)</span>
    <span class="n">last_name</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">50</span><span class="p">)</span>
    <span class="n">birth_date</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">DateField</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">baby_boomer_status</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s2">&quot;Returns the person&#39;s baby-boomer status.&quot;</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">datetime</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">birth_date</span> <span class="o">&lt;</span> <span class="n">datetime</span><span class="o">.</span><span class="n">date</span><span class="p">(</span><span class="mi">1945</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">return</span> <span class="s2">&quot;Pre-boomer&quot;</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">birth_date</span> <span class="o">&lt;</span> <span class="n">datetime</span><span class="o">.</span><span class="n">date</span><span class="p">(</span><span class="mi">1965</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">return</span> <span class="s2">&quot;Baby boomer&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;Post-boomer&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">full_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s2">&quot;Returns the person&#39;s full name.&quot;</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">first_name</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">last_name</span><span class="si">}</span><span class="s2">&quot;</span>
</pre></div>
</div>
<p>例にある最後のメソッドは <a class="reference internal" href="../../glossary.html#term-property"><span class="xref std std-term">property</span></a> です。</p>
<p><a class="reference internal" href="../../ref/models/instances.html"><span class="doc">モデルインスタンスのリファレンス</span></a> には各モデルに自動的に与えられる <a class="reference internal" href="../../ref/models/instances.html#model-instance-methods"><span class="std std-ref">メソッド</span></a> の完全なリストがあります。ほとんどはオーバーライドできます（後述の <a class="reference internal" href="#overriding-predefined-model-methods">overriding predefined model methods</a> を参照してください）が、特によく定義することになるものがあります：</p>
<dl>
<dt><a class="reference internal" href="../../ref/models/instances.html#django.db.models.Model.__str__" title="django.db.models.Model.__str__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__str__()</span></code></a></dt><dd><p>Python の「マジックメソッド」で、任意のオブジェクトの文字列表現を返します。Python や Django がモデルインスタンスを文字列として表示する際に、このメソッドが使用されます。最も典型的な例は、インタラクティブなコンソールや管理画面でオブジェクトを表示するときです。</p>
<p>このメソッドは必ず定義することを推奨します。デフォルト値はあまり役に立ちません。</p>
</dd>
<dt><a class="reference internal" href="../../ref/models/instances.html#django.db.models.Model.get_absolute_url" title="django.db.models.Model.get_absolute_url"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_absolute_url()</span></code></a></dt><dd><p>Django にオブジェクトの URL の計算方法を定義します。Django はこのメソッドを admin インターフェイスで利用しており、オブジェクトの URL を使用する必要があるあらゆる場面でも使用されます。</p>
<p>ユニークに特定できる URL を持つすべてのオブジェクトには、このメソッドを定義しなければなりません。</p>
</dd>
</dl>
<section id="s-overriding-predefined-model-methods">
<span id="s-overriding-model-methods"></span><span id="overriding-predefined-model-methods"></span><span id="overriding-model-methods"></span><h3>定義済みのモデルメソッドをオーバーライドする<a class="headerlink" href="#overriding-predefined-model-methods" title="Link to this heading">¶</a></h3>
<p>別の一連の <a class="reference internal" href="../../ref/models/instances.html#model-instance-methods"><span class="std std-ref">モデルメソッド</span></a> を使って、多くのカスタマイズしたいデータベース動作をカプセル化できます。特に、<a class="reference internal" href="../../ref/models/instances.html#django.db.models.Model.save" title="django.db.models.Model.save"><code class="xref py py-meth docutils literal notranslate"><span class="pre">save()</span></code></a> や <a class="reference internal" href="../../ref/models/instances.html#django.db.models.Model.delete" title="django.db.models.Model.delete"><code class="xref py py-meth docutils literal notranslate"><span class="pre">delete()</span></code></a> の動作を変更したいことがよくあります。</p>
<p>これらのメソッド (および他のすべてのメソッド) は自由にオーバーライドして、動作を変更できます。</p>
<p>ビルトインのメソッドをオーバーライドする典型的な状況は、オブジェクトを保存するとき毎回何かを実行したい、という場合です。例えば (受け入れるパラメータについては <a class="reference internal" href="../../ref/models/instances.html#django.db.models.Model.save" title="django.db.models.Model.save"><code class="xref py py-meth docutils literal notranslate"><span class="pre">save()</span></code></a> を参照してください):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">django.db</span><span class="w"> </span><span class="kn">import</span> <span class="n">models</span>


<span class="k">class</span><span class="w"> </span><span class="nc">Blog</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
    <span class="n">tagline</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">TextField</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">do_something</span><span class="p">()</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>  <span class="c1"># Call the &quot;real&quot; save() method.</span>
        <span class="n">do_something_else</span><span class="p">()</span>
</pre></div>
</div>
<p>保存しないようにすることもできます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">django.db</span><span class="w"> </span><span class="kn">import</span> <span class="n">models</span>


<span class="k">class</span><span class="w"> </span><span class="nc">Blog</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
    <span class="n">tagline</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">TextField</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;Yoko Ono&#39;s blog&quot;</span><span class="p">:</span>
            <span class="k">return</span>  <span class="c1"># Yoko shall never have her own blog!</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>  <span class="c1"># Call the &quot;real&quot; save() method.</span>
</pre></div>
</div>
<p>親クラスのメソッド、つまり <code class="docutils literal notranslate"><span class="pre">super().save(**kwargs)</span></code> を忘れずに呼び出すようにします。これを呼び出さないと、オブジェクトがデータベースに保存されなくなります。親クラスのメソッドを呼び出さない場合、デフォルトの動作が行われず、データベースに変更が反映されません。</p>
<p>また、モデルメソッドに渡される可能性のある引数をそのまま渡すことも重要です。これが <code class="docutils literal notranslate"><span class="pre">**kwargs</span></code> の役割です。Djangoは時折、組み込みのモデルメソッドの機能を拡張し、新しいキーワード引数を追加します。メソッド定義で <code class="docutils literal notranslate"><span class="pre">**kwargs</span></code> を使用しておけば、これらの引数が追加された際にも自動的に対応できるようになります。</p>
<p><a class="reference internal" href="../../ref/models/instances.html#django.db.models.Model.save" title="django.db.models.Model.save"><code class="xref py py-meth docutils literal notranslate"><span class="pre">save()</span></code></a> メソッド内のフィールドの値をアップデートしたい場合は、<code class="docutils literal notranslate"><span class="pre">update_fields</span></code>  キーワード引数に追加されたこのフィールドを持ちたくなるかもしれません。これにより、<code class="docutils literal notranslate"><span class="pre">update_fields</span></code> が指定されたときにフィールドが保存されることが保証されます。次に例を示します。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">django.db</span><span class="w"> </span><span class="kn">import</span> <span class="n">models</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">django.utils.text</span><span class="w"> </span><span class="kn">import</span> <span class="n">slugify</span>


<span class="k">class</span><span class="w"> </span><span class="nc">Blog</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
    <span class="n">slug</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">TextField</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">slug</span> <span class="o">=</span> <span class="n">slugify</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">update_fields</span> <span class="o">:=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;update_fields&quot;</span><span class="p">)</span>
        <span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="s2">&quot;name&quot;</span> <span class="ow">in</span> <span class="n">update_fields</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;update_fields&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;slug&quot;</span><span class="p">}</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">update_fields</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>
</div>
<p>詳しくは <a class="reference internal" href="../../ref/models/instances.html#ref-models-update-fields"><span class="std std-ref">どのフィールドを保存するか指定する</span></a> を読んでください。</p>
<div class="admonition-overridden-model-methods-are-not-called-on-bulk-operations admonition">
<p class="admonition-title">オーバーライドされたモデルメソッドは一括操作では呼び出されません</p>
<p>オブジェクトの <a class="reference internal" href="../../ref/models/instances.html#django.db.models.Model.delete" title="django.db.models.Model.delete"><code class="xref py py-meth docutils literal notranslate"><span class="pre">delete()</span></code></a> メソッドは、<a class="reference internal" href="queries.html#topics-db-queries-delete"><span class="std std-ref">QuerySet を使用したオブジェクトの一括削除</span></a> や <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ForeignKey.on_delete" title="django.db.models.ForeignKey.on_delete"><code class="xref py py-attr docutils literal notranslate"><span class="pre">カスケード削除</span></code></a> を行ったときに、必ずしも呼ばれるわけではないことに注意してください。カスタマイズされた削除ロジックが実行されることを保証するためには、<a class="reference internal" href="../../ref/signals.html#django.db.models.signals.pre_delete" title="django.db.models.signals.pre_delete"><code class="xref py py-data docutils literal notranslate"><span class="pre">pre_delete</span></code></a> と <a class="reference internal" href="../../ref/signals.html#django.db.models.signals.post_delete" title="django.db.models.signals.post_delete"><code class="xref py py-data docutils literal notranslate"><span class="pre">post_delete</span></code></a> シグナルのいずれかまたは両方が利用できます。</p>
<p>残念ながら、オブジェクトを一括で <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.bulk_create" title="django.db.models.query.QuerySet.bulk_create"><code class="xref py py-meth docutils literal notranslate"><span class="pre">作成</span></code></a> または <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.update" title="django.db.models.query.QuerySet.update"><code class="xref py py-meth docutils literal notranslate"><span class="pre">更新</span></code></a> するときにはワークアラウンドはありません。この場合には <a class="reference internal" href="../../ref/models/instances.html#django.db.models.Model.save" title="django.db.models.Model.save"><code class="xref py py-meth docutils literal notranslate"><span class="pre">save()</span></code></a>、<a class="reference internal" href="../../ref/signals.html#django.db.models.signals.pre_save" title="django.db.models.signals.pre_save"><code class="xref py py-data docutils literal notranslate"><span class="pre">pre_save</span></code></a>、<a class="reference internal" href="../../ref/signals.html#django.db.models.signals.post_save" title="django.db.models.signals.post_save"><code class="xref py py-data docutils literal notranslate"><span class="pre">post_save</span></code></a> のいずれも呼ばれないためです。</p>
</div>
</section>
<section id="s-executing-custom-sql">
<span id="executing-custom-sql"></span><h3>カスタムの SQL を実行する<a class="headerlink" href="#executing-custom-sql" title="Link to this heading">¶</a></h3>
<p>その他のよくあるパターンとしては、カスタムの SQL 文をモデルのメソッドやモジュールのメソッドとして定義することがあります。生の SQL 文を使用する方法については、<a class="reference internal" href="sql.html"><span class="doc">生の SQL を使用する</span></a> を参照してください。</p>
</section>
</section>
<section id="s-model-inheritance">
<span id="s-id6"></span><span id="model-inheritance"></span><span id="id6"></span><h2>モデルの継承<a class="headerlink" href="#model-inheritance" title="Link to this heading">¶</a></h2>
<p>Django におけるモデルの継承は Python における普通のクラスの継承とほぼ同じ方法で行われますが、最初の段階だけでもここで説明しておいた方がよいでしょう。それはその基底クラスが <a class="reference internal" href="../../ref/models/instances.html#django.db.models.Model" title="django.db.models.Model"><code class="xref py py-class docutils literal notranslate"><span class="pre">django.db.models.Model</span></code></a> のサブクラスでなければならないという事です。</p>
<p>唯一決めるべきことは、親モデルを (保持するデータベースのテーブルと共に) 独自の権限を持ったモデルとするか、それとも子モデルを通じてのみ共通情報を参照する単なる保持者とするかです。</p>
<p>Django において可能な継承には 3 つの方式があります。</p>
<ol class="arabic simple">
<li><p>子モデルそれぞれに対して一々定義し直さないで済ませたい情報を保持するためだけに、親クラスを使用することがあるかもしれません。このクラスが単体で用いられることはないので、この場合 <a class="reference internal" href="#abstract-base-classes"><span class="std std-ref">抽象基底クラス</span></a> が適切です。</p></li>
<li><p>もし既存のモデル (完全に別のアプリケーション等から取得した) のサブクラスを作成していてモデルそれぞれにデータベース上のテーブルを定義したい場合、 <a class="reference internal" href="#multi-table-inheritance"><span class="std std-ref">マルチテーブル継承</span></a> を利用するとよいでしょう。</p></li>
<li><p>最後に、モデルの Python レベルでの振る舞いを、モデルのフィールドを変更せずに修正したい場合は、 <a class="reference internal" href="#proxy-models"><span class="std std-ref">プロキシモデル</span></a> を利用できます。</p></li>
</ol>
<section id="s-abstract-base-classes">
<span id="s-id7"></span><span id="abstract-base-classes"></span><span id="id7"></span><h3>抽象基底クラス<a class="headerlink" href="#abstract-base-classes" title="Link to this heading">¶</a></h3>
<p>抽象基底クラスは、複数の他モデルに対して共通の情報を入れ込みたいときに有用です。基底クラスを書いて <a class="reference internal" href="#meta-options"><span class="std std-ref">Meta</span></a> クラス内で <code class="docutils literal notranslate"><span class="pre">abstract=True</span></code> をセットしてください。これで、このモデルはデータベーステーブルを作成するために使用されることはなくなります。 代わりに、他のモデルで基底クラスとして使われる際に、これら子クラスのフィールドとして追加されます。</p>
<p>実装例:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">django.db</span><span class="w"> </span><span class="kn">import</span> <span class="n">models</span>


<span class="k">class</span><span class="w"> </span><span class="nc">CommonInfo</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
    <span class="n">age</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">PositiveIntegerField</span><span class="p">()</span>

    <span class="k">class</span><span class="w"> </span><span class="nc">Meta</span><span class="p">:</span>
        <span class="n">abstract</span> <span class="o">=</span> <span class="kc">True</span>


<span class="k">class</span><span class="w"> </span><span class="nc">Student</span><span class="p">(</span><span class="n">CommonInfo</span><span class="p">):</span>
    <span class="n">home_group</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Student</span></code> モデルは <code class="docutils literal notranslate"><span class="pre">name</span></code>、<code class="docutils literal notranslate"><span class="pre">age</span></code> そして <code class="docutils literal notranslate"><span class="pre">home_group</span></code> の 3 つのフィールドを持つことになります。 <code class="docutils literal notranslate"><span class="pre">CommonInfo</span></code> モデルは抽象基底クラスであるため、通常の Django モデルとしては利用できません。データベース上にテーブルを生成したりマネージャを持ったりせず、そしてインスタンス化されたり直接値を保存する事もできません。</p>
<p>抽象基底クラスを継承したフィールドは、他のフィールドや値でオーバーライドしたり、 <code class="docutils literal notranslate"><span class="pre">None</span></code> を使って削除したりできます。</p>
<p>多くの場合、このタイプのモデル継承があなたの必要としているものでしょう。この方式では、データベースレベルでは子モデルごとのテーブルを 1 つずつ作る一方で、共通情報を Python レベルで因数分解できます。</p>
<section id="s-meta-inheritance">
<span id="meta-inheritance"></span><h4><code class="docutils literal notranslate"><span class="pre">Meta</span></code> の継承<a class="headerlink" href="#meta-inheritance" title="Link to this heading">¶</a></h4>
<p>抽象基底クラスを作成した際、Django は基底クラスで宣言したすべての <a class="reference internal" href="#meta-options"><span class="std std-ref">Meta</span></a> インナークラスを子クラスの属性とします。子クラスが自身の <a class="reference internal" href="#meta-options"><span class="std std-ref">Meta</span></a> クラスを定義しなければ、親の <a class="reference internal" href="#meta-options"><span class="std std-ref">Meta</span></a> クラスを継承します。子クラスが親の <a class="reference internal" href="#meta-options"><span class="std std-ref">Meta</span></a> クラスを拡張したい場合、サブクラス化できます。例えば:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">django.db</span><span class="w"> </span><span class="kn">import</span> <span class="n">models</span>


<span class="k">class</span><span class="w"> </span><span class="nc">CommonInfo</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="c1"># ...</span>
    <span class="k">class</span><span class="w"> </span><span class="nc">Meta</span><span class="p">:</span>
        <span class="n">abstract</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">ordering</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span>


<span class="k">class</span><span class="w"> </span><span class="nc">Student</span><span class="p">(</span><span class="n">CommonInfo</span><span class="p">):</span>
    <span class="c1"># ...</span>
    <span class="k">class</span><span class="w"> </span><span class="nc">Meta</span><span class="p">(</span><span class="n">CommonInfo</span><span class="o">.</span><span class="n">Meta</span><span class="p">):</span>
        <span class="n">db_table</span> <span class="o">=</span> <span class="s2">&quot;student_info&quot;</span>
</pre></div>
</div>
<p>抽象基底クラスを継承したとき、 Django は <a class="reference internal" href="#meta-options"><span class="std std-ref">Meta</span></a> 属性に <code class="docutils literal notranslate"><span class="pre">abstract=False</span></code> をセットしてから子クラスに引き継ぎます。そのため、抽象基底クラスを継承した子クラスが自動的に抽象クラスになることはありません。抽象基底クラスを継承して新たな抽象基底クラスを作る場合は、子クラスに <code class="docutils literal notranslate"><span class="pre">abstract=True</span></code> を明示的にセットする必要があります。</p>
<p>抽象基底クラスの <a class="reference internal" href="#meta-options"><span class="std std-ref">Meta</span></a> クラスに持っても意味をなさない属性がいくつか存在します。例えば、属性値 <code class="docutils literal notranslate"><span class="pre">db_table</span></code> を指定することは、子クラス (のうち自身の <a class="reference internal" href="#meta-options"><span class="std std-ref">Meta</span></a> を定義していないもの) が全て同じデータベース上のテーブルを利用することを意味しますが、これは明らかに必要なものではありません。</p>
<p>Python の継承の仕組みにより、子クラスが複数の抽象基底クラスから継承する場合、デフォルトでは、最初にリストされたクラスの <a class="reference internal" href="#meta-options"><span class="std std-ref">Meta</span></a> オプションのみが継承されます。複数の抽象基底クラスから <a class="reference internal" href="#meta-options"><span class="std std-ref">Meta</span></a> オプションを継承するには、<a class="reference internal" href="#meta-options"><span class="std std-ref">Meta</span></a> の継承を明示的に宣言する必要があります。以下に例を示します。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">django.db</span><span class="w"> </span><span class="kn">import</span> <span class="n">models</span>


<span class="k">class</span><span class="w"> </span><span class="nc">CommonInfo</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
    <span class="n">age</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">PositiveIntegerField</span><span class="p">()</span>

    <span class="k">class</span><span class="w"> </span><span class="nc">Meta</span><span class="p">:</span>
        <span class="n">abstract</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">ordering</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span>


<span class="k">class</span><span class="w"> </span><span class="nc">Unmanaged</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="k">class</span><span class="w"> </span><span class="nc">Meta</span><span class="p">:</span>
        <span class="n">abstract</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">managed</span> <span class="o">=</span> <span class="kc">False</span>


<span class="k">class</span><span class="w"> </span><span class="nc">Student</span><span class="p">(</span><span class="n">CommonInfo</span><span class="p">,</span> <span class="n">Unmanaged</span><span class="p">):</span>
    <span class="n">home_group</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

    <span class="k">class</span><span class="w"> </span><span class="nc">Meta</span><span class="p">(</span><span class="n">CommonInfo</span><span class="o">.</span><span class="n">Meta</span><span class="p">,</span> <span class="n">Unmanaged</span><span class="o">.</span><span class="n">Meta</span><span class="p">):</span>
        <span class="k">pass</span>
</pre></div>
</div>
</section>
<section id="s-be-careful-with-related-name-and-related-query-name">
<span id="s-abstract-related-name"></span><span id="be-careful-with-related-name-and-related-query-name"></span><span id="abstract-related-name"></span><h4><code class="docutils literal notranslate"><span class="pre">related_name</span></code> と <code class="docutils literal notranslate"><span class="pre">related_query_name</span></code> の利用に関して注意するべき点<a class="headerlink" href="#be-careful-with-related-name-and-related-query-name" title="Link to this heading">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">ForeignKey</span></code> もしくは <code class="docutils literal notranslate"><span class="pre">ManyToManyField</span></code> に対して <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ForeignKey.related_name" title="django.db.models.ForeignKey.related_name"><code class="xref py py-attr docutils literal notranslate"><span class="pre">related_name</span></code></a> または <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ForeignKey.related_query_name" title="django.db.models.ForeignKey.related_query_name"><code class="xref py py-attr docutils literal notranslate"><span class="pre">related_query_name</span></code></a> を使う場合、そのフィールドに対して <em>一意の</em> 逆引き名およびクエリ名を常に定義しなければなりません。これは抽象基底クラスにおいて、フィールドが継承した子クラスそれぞれに含まれ、継承される毎にその属性値が完全に同じ値 (<a class="reference internal" href="../../ref/models/fields.html#django.db.models.ForeignKey.related_name" title="django.db.models.ForeignKey.related_name"><code class="xref py py-attr docutils literal notranslate"><span class="pre">related_name</span></code></a> と <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ForeignKey.related_query_name" title="django.db.models.ForeignKey.related_query_name"><code class="xref py py-attr docutils literal notranslate"><span class="pre">related_query_name</span></code></a> も含む) となるため、通常問題となります。</p>
<p>この問題に対処するため、抽象基底クラスにおいて <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ForeignKey.related_name" title="django.db.models.ForeignKey.related_name"><code class="xref py py-attr docutils literal notranslate"><span class="pre">related_name</span></code></a> もしくは <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ForeignKey.related_query_name" title="django.db.models.ForeignKey.related_query_name"><code class="xref py py-attr docutils literal notranslate"><span class="pre">related_query_name</span></code></a> を用いる場合(のみ)、その値の一部に <code class="docutils literal notranslate"><span class="pre">'%(app_label)s'</span></code> と <code class="docutils literal notranslate"><span class="pre">'%(class)s'</span></code> を含まなければなりません。</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">'%(class)s'</span></code> は、フィールドが使用されている子クラスの名前を小文字にした文字列と置換されます。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'%(app_label)s'</span></code> は、子クラスが含まれているアプリ名を小文字にした文字列と置換されます。各インストールアプリケーション名はユニークでなければならず、モデルクラスの名は各アプリ内でもユニークでなければなりません。その結果、すべての名前が異なるものとなります。</p></li>
</ul>
<p>例として、次のような <code class="docutils literal notranslate"><span class="pre">common/models.py</span></code> というアプリケーションが存在したとします。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">django.db</span><span class="w"> </span><span class="kn">import</span> <span class="n">models</span>


<span class="k">class</span><span class="w"> </span><span class="nc">Base</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">m2m</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">ManyToManyField</span><span class="p">(</span>
        <span class="n">OtherModel</span><span class="p">,</span>
        <span class="n">related_name</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">%(app_label)s</span><span class="s2">_</span><span class="si">%(class)s</span><span class="s2">_related&quot;</span><span class="p">,</span>
        <span class="n">related_query_name</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">%(app_label)s</span><span class="s2">_</span><span class="si">%(class)s</span><span class="s2">s&quot;</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">class</span><span class="w"> </span><span class="nc">Meta</span><span class="p">:</span>
        <span class="n">abstract</span> <span class="o">=</span> <span class="kc">True</span>


<span class="k">class</span><span class="w"> </span><span class="nc">ChildA</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">class</span><span class="w"> </span><span class="nc">ChildB</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>別のアプリケーションの <code class="docutils literal notranslate"><span class="pre">rare/models.py</span></code> も存在するとします。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">common.models</span><span class="w"> </span><span class="kn">import</span> <span class="n">Base</span>


<span class="k">class</span><span class="w"> </span><span class="nc">ChildB</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">common.ChildA.m2m</span></code> フィールドの逆引き名は <code class="docutils literal notranslate"><span class="pre">common_childa_related</span></code> で、逆引きクエリ名は <code class="docutils literal notranslate"><span class="pre">common_childas</span></code> になります。 <code class="docutils literal notranslate"><span class="pre">common.ChildB.m2m</span></code> フィールドの逆引き名は <code class="docutils literal notranslate"><span class="pre">common_childb_related</span></code> で、逆引きクエリ名は <code class="docutils literal notranslate"><span class="pre">common_childbs</span></code> になります。最後に、 <code class="docutils literal notranslate"><span class="pre">rare.ChildB.m2m</span></code> フィールドの逆引き名は <code class="docutils literal notranslate"><span class="pre">rare_childb_related</span></code> で、逆引きクエリ名は <code class="docutils literal notranslate"><span class="pre">rare_childbs</span></code> になります。related name あるいは related query name の中で <code class="docutils literal notranslate"><span class="pre">'%(app_label)s'</span></code> と <code class="docutils literal notranslate"><span class="pre">'%(class)s'</span></code> をどう使うかは任意ですが、それらの値自体を入れ忘れた場合、Django はシステムチェックの実行時 (もしくは <a class="reference internal" href="../../ref/django-admin.html#django-admin-migrate"><code class="xref std std-djadmin docutils literal notranslate"><span class="pre">migrate</span></code></a> の実行時) にエラーを発生させます。</p>
<p>もし、抽象基底クラスでフィールドに <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ForeignKey.related_name" title="django.db.models.ForeignKey.related_name"><code class="xref py py-attr docutils literal notranslate"><span class="pre">related_name</span></code></a> 属性を指定しなかった場合、デフォルトの逆引き名は、子クラスの名前に <code class="docutils literal notranslate"><span class="pre">'_set'</span></code> を付けたものになります。これは、フィールドを直接子クラスに宣言した場合と同じです。例えば、上記のコードで <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ForeignKey.related_name" title="django.db.models.ForeignKey.related_name"><code class="xref py py-attr docutils literal notranslate"><span class="pre">related_name</span></code></a> 属性が省略された場合、<code class="docutils literal notranslate"><span class="pre">m2m</span></code> フィールドの逆引き名は、<code class="docutils literal notranslate"><span class="pre">ChildA</span></code> の場合は <code class="docutils literal notranslate"><span class="pre">childa_set</span></code>、<code class="docutils literal notranslate"><span class="pre">ChildB</span></code> の場合は <code class="docutils literal notranslate"><span class="pre">childb_set</span></code> になります。</p>
</section>
</section>
<section id="s-multi-table-inheritance">
<span id="s-id8"></span><span id="multi-table-inheritance"></span><span id="id8"></span><h3>マルチテーブル継承<a class="headerlink" href="#multi-table-inheritance" title="Link to this heading">¶</a></h3>
<p>Django がサポートするもう一つのモデル継承は、ヒエラルキー内の各モデルすべてが、それ自体モデルであるような場合です。それぞれのモデルはデータベース上のテーブルに対応しており、個別にクエリーを作成したり、テーブルの作成ができます。継承の関係によって、(自動的に作成される <a class="reference internal" href="../../ref/models/fields.html#django.db.models.OneToOneField" title="django.db.models.OneToOneField"><code class="xref py py-class docutils literal notranslate"><span class="pre">OneToOneField</span></code></a> を通して) 子モデルとその親モデルとの間にリンクが作られます。この継承を利用すると、たとえば、次のように書くことができます。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">django.db</span><span class="w"> </span><span class="kn">import</span> <span class="n">models</span>


<span class="k">class</span><span class="w"> </span><span class="nc">Place</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">50</span><span class="p">)</span>
    <span class="n">address</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">80</span><span class="p">)</span>


<span class="k">class</span><span class="w"> </span><span class="nc">Restaurant</span><span class="p">(</span><span class="n">Place</span><span class="p">):</span>
    <span class="n">serves_hot_dogs</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">BooleanField</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">serves_pizza</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">BooleanField</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>データはデータベースの異なるテーブルに存在しますが、<code class="docutils literal notranslate"><span class="pre">Place</span></code> のすべてのフィールドは <code class="docutils literal notranslate"><span class="pre">Restaurant</span></code> でも利用できます。したがって、以下はともに可能です。</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Place</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Bob&#39;s Cafe&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Restaurant</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Bob&#39;s Cafe&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>もし、<code class="docutils literal notranslate"><span class="pre">Restaurant</span></code> でもある <code class="docutils literal notranslate"><span class="pre">Place</span></code> が存在する時、小文字にしたモデル名を使うことで、<code class="docutils literal notranslate"><span class="pre">Place</span></code> オブジェクトから <code class="docutils literal notranslate"><span class="pre">Restaurant</span></code> オブジェクトを取得できます。</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">Place</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
<span class="go"># If p is a Restaurant object, this will give the child class:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">restaurant</span>
<span class="go">&lt;Restaurant: ...&gt;</span>
</pre></div>
</div>
<p>しかし、上の例において <code class="docutils literal notranslate"><span class="pre">p</span></code> が <code class="docutils literal notranslate"><span class="pre">Restaurant</span></code> オブジェクト <em>ではない</em> 場合 (つまり、継承を用いず <code class="docutils literal notranslate"><span class="pre">Place</span></code> オブジェクトが直接作成されたもしくは他のクラスの親であった場合)、<code class="docutils literal notranslate"><span class="pre">p.restaurant</span></code> を参照すると、<code class="docutils literal notranslate"><span class="pre">Restaurant.DoesNotExist</span></code> 例外が発生します。</p>
<p><code class="docutils literal notranslate"><span class="pre">Restaurant</span></code> 上には次のように、 <code class="docutils literal notranslate"><span class="pre">Place</span></code> と関連付けられた <a class="reference internal" href="../../ref/models/fields.html#django.db.models.OneToOneField" title="django.db.models.OneToOneField"><code class="xref py py-class docutils literal notranslate"><span class="pre">OneToOneField</span></code></a> が自動生成されます。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">place_ptr</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">OneToOneField</span><span class="p">(</span>
    <span class="n">Place</span><span class="p">,</span>
    <span class="n">on_delete</span><span class="o">=</span><span class="n">models</span><span class="o">.</span><span class="n">CASCADE</span><span class="p">,</span>
    <span class="n">parent_link</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Restaurant</span></code> 上で、自分自身の <a class="reference internal" href="../../ref/models/fields.html#django.db.models.OneToOneField" title="django.db.models.OneToOneField"><code class="xref py py-class docutils literal notranslate"><span class="pre">OneToOneField</span></code></a> を <a class="reference internal" href="../../ref/models/fields.html#django.db.models.OneToOneField.parent_link" title="django.db.models.OneToOneField.parent_link"><code class="xref py py-attr docutils literal notranslate"><span class="pre">parent_link=True</span></code></a> を付けて宣言すれば、このフィールドをオーバーライドできます。</p>
<section id="s-meta-and-multi-table-inheritance">
<span id="s-id9"></span><span id="meta-and-multi-table-inheritance"></span><span id="id9"></span><h4><code class="docutils literal notranslate"><span class="pre">Meta</span></code> とマルチテーブル継承<a class="headerlink" href="#meta-and-multi-table-inheritance" title="Link to this heading">¶</a></h4>
<p>マルチテーブル継承においては、子クラスが親クラスの <a class="reference internal" href="#meta-options"><span class="std std-ref">Meta</span></a> クラスを継承することは意味がありません。すべての <a class="reference internal" href="#meta-options"><span class="std std-ref">Meta</span></a> オプションは既に親クラスに適用されており、それらを再度適用すると通常は矛盾した動作につながるだけです（これは、基底クラスが独自の権利を持たない抽象基底クラスの場合とは対照的です）。</p>
<p>したがって、子モデルは親の <a class="reference internal" href="#meta-options"><span class="std std-ref">Meta</span></a> クラスへのアクセスを持ちません。しかし、ごく限られたケースにおいて、子モデルは親から振る舞いを継承します。具体的には、子モデルで <a class="reference internal" href="../../ref/models/options.html#django.db.models.Options.ordering" title="django.db.models.Options.ordering"><code class="xref py py-attr docutils literal notranslate"><span class="pre">ordering</span></code></a> 属性もしくは <a class="reference internal" href="../../ref/models/options.html#django.db.models.Options.get_latest_by" title="django.db.models.Options.get_latest_by"><code class="xref py py-attr docutils literal notranslate"><span class="pre">get_latest_by</span></code></a> 属性を指定しなかった場合、これらは親モデルから継承されます。</p>
<p>もし親モデルが ordering 属性を持っているが、子モデルに既定のデータ並び順を持たせたくない場合は、下記のように明示的に無効化できます。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">ChildModel</span><span class="p">(</span><span class="n">ParentModel</span><span class="p">):</span>
    <span class="c1"># ...</span>
    <span class="k">class</span><span class="w"> </span><span class="nc">Meta</span><span class="p">:</span>
        <span class="c1"># Remove parent&#39;s ordering effect</span>
        <span class="n">ordering</span> <span class="o">=</span> <span class="p">[]</span>
</pre></div>
</div>
</section>
<section id="s-inheritance-and-reverse-relations">
<span id="inheritance-and-reverse-relations"></span><h4>継承と関係の逆引き<a class="headerlink" href="#inheritance-and-reverse-relations" title="Link to this heading">¶</a></h4>
<p>マルチテーブル継承は、親と子の関連付けに暗黙的に <a class="reference internal" href="../../ref/models/fields.html#django.db.models.OneToOneField" title="django.db.models.OneToOneField"><code class="xref py py-class docutils literal notranslate"><span class="pre">OneToOneField</span></code></a> を使用するため、上記の例のように親から子を参照することは可能です。しかし、これは <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ForeignKey" title="django.db.models.ForeignKey"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForeignKey</span></code></a> と <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ManyToManyField" title="django.db.models.ManyToManyField"><code class="xref py py-class docutils literal notranslate"><span class="pre">ManyToManyField</span></code></a> のデフォルトの <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ForeignKey.related_name" title="django.db.models.ForeignKey.related_name"><code class="xref py py-attr docutils literal notranslate"><span class="pre">related_name</span></code></a> のための名前を使い切ってしまいます。その種のリレーションシップを親モデルの子クラスに用いる場合、そのフィールドには必ず <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ForeignKey.related_name" title="django.db.models.ForeignKey.related_name"><code class="xref py py-attr docutils literal notranslate"><span class="pre">related_name</span></code></a> 属性を <strong>指定しなければなりません</strong> 。それを忘れた場合、Django はバリデーションエラーを発生させます。</p>
<p>例として、上で用いた <code class="docutils literal notranslate"><span class="pre">Place</span></code> クラスを再度用いて、また別のサブクラスを <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ManyToManyField" title="django.db.models.ManyToManyField"><code class="xref py py-class docutils literal notranslate"><span class="pre">ManyToManyField</span></code></a> によって作成してみましょう:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Supplier</span><span class="p">(</span><span class="n">Place</span><span class="p">):</span>
    <span class="n">customers</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">ManyToManyField</span><span class="p">(</span><span class="n">Place</span><span class="p">)</span>
</pre></div>
</div>
<p>この処理の結果はエラーとなります。</p>
<div class="highlight-pytb notranslate"><div class="highlight"><pre><span></span><span class="x">Reverse query name for &#39;Supplier.customers&#39; clashes with reverse query</span>
<span class="x">name for &#39;Supplier.place_ptr&#39;.</span>

<span class="x">HINT: Add or change a related_name argument to the definition for</span>
<span class="x">&#39;Supplier.customers&#39; or &#39;Supplier.place_ptr&#39;.</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">customers</span></code> フィールドに <code class="docutils literal notranslate"><span class="pre">related_name</span></code> を追加する事でこのエラーを解消できます: <code class="docutils literal notranslate"><span class="pre">models.ManyToManyField(Place,</span> <span class="pre">related_name='provider')</span></code>。</p>
</section>
<section id="s-specifying-the-parent-link-field">
<span id="specifying-the-parent-link-field"></span><h4>親モデルとの関連付けに用いるフィールドを定義する<a class="headerlink" href="#specifying-the-parent-link-field" title="Link to this heading">¶</a></h4>
<p>前述のように、Django は、非抽象の親モデルにリンクする :class:~django.db.models.OneToOneField を子クラスに自動的に作成します。親モデルへのリンクとなる属性の名前を自分で決めたい場合は、 :class:~django.db.models.OneToOneField を手動で作成し、そのフィールドが親クラスへのリンクであることを示すために :attr:parent_link=True &lt;django.db.models.OneToOneField.parent_link&gt; を設定します。</p>
</section>
</section>
<section id="s-proxy-models">
<span id="s-id10"></span><span id="proxy-models"></span><span id="id10"></span><h3>プロキシモデル<a class="headerlink" href="#proxy-models" title="Link to this heading">¶</a></h3>
<p><a class="reference internal" href="#multi-table-inheritance"><span class="std std-ref">マルチテーブル継承</span></a> を使用すると、モデルの各サブクラスに対して新しいデータベーステーブルが作成されます。これは通常、望ましい動作です。なぜなら、サブクラスには基底クラスに存在しない追加のデータフィールドを格納する場所が必要だからです。しかし、時にはモデルの Python 上での動作を変更したいだけの場合もあります。たとえば、デフォルトマネージャーを変更する、新しいメソッドを追加するなどです。</p>
<p>これがプロキシモデル継承の目的、つまり元のモデルの <em>プロキシ</em> を作成することです。プロキシモデルのインスタンスは作成、削除、更新でき、すべてのデータは元の（非プロキシ）モデルを使用しているかのように保存されます。違いは、元のモデルを変更することなく、デフォルトのモデルのソート順やマネージャーの設定をプロキシ上で変更できるという点です。</p>
<p>プロキシモデルは通常のモデルと同様に定義されます。Django にそれがプロキシモデルである事を伝えるには <code class="docutils literal notranslate"><span class="pre">Meta</span></code> クラスの <a class="reference internal" href="../../ref/models/options.html#django.db.models.Options.proxy" title="django.db.models.Options.proxy"><code class="xref py py-attr docutils literal notranslate"><span class="pre">proxy</span></code></a> 属性値を <code class="docutils literal notranslate"><span class="pre">True</span></code> にします。</p>
<p>例として、<code class="docutils literal notranslate"><span class="pre">Person</span></code> モデルにメソッドを追加する場合は、次のように書くことができます。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">django.db</span><span class="w"> </span><span class="kn">import</span> <span class="n">models</span>


<span class="k">class</span><span class="w"> </span><span class="nc">Person</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">first_name</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span>
    <span class="n">last_name</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span>


<span class="k">class</span><span class="w"> </span><span class="nc">MyPerson</span><span class="p">(</span><span class="n">Person</span><span class="p">):</span>
    <span class="k">class</span><span class="w"> </span><span class="nc">Meta</span><span class="p">:</span>
        <span class="n">proxy</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">do_something</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># ...</span>
        <span class="k">pass</span>
</pre></div>
</div>
<p>MyPerson クラスは、親クラスである Person クラスと同じデータベーステーブルを操作します。特に、新たに作成された Person のインスタンスは MyPerson を通じてもアクセス可能であり、その逆も同様です。</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">Person</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">first_name</span><span class="o">=</span><span class="s2">&quot;foobar&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">MyPerson</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">first_name</span><span class="o">=</span><span class="s2">&quot;foobar&quot;</span><span class="p">)</span>
<span class="go">&lt;MyPerson: foobar&gt;</span>
</pre></div>
</div>
<p>プロキシモデルを使用して、モデルに異なるデフォルトの並び順を定義することもできます。<code class="docutils literal notranslate"><span class="pre">Person</span></code> モデルの並び順を常に指定したいわけではなくても、プロキシを利用することで、規則的に <code class="docutils literal notranslate"><span class="pre">last_name</span></code> 属性で並び替えることができます。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">OrderedPerson</span><span class="p">(</span><span class="n">Person</span><span class="p">):</span>
    <span class="k">class</span><span class="w"> </span><span class="nc">Meta</span><span class="p">:</span>
        <span class="n">ordering</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;last_name&quot;</span><span class="p">]</span>
        <span class="n">proxy</span> <span class="o">=</span> <span class="kc">True</span>
</pre></div>
</div>
<p>これにより、通常の <code class="docutils literal notranslate"><span class="pre">Person</span></code> に対するクエリは並び順が指定されず、<code class="docutils literal notranslate"><span class="pre">OrderedPerson</span></code> に対するクエリでは <code class="docutils literal notranslate"><span class="pre">last_name</span></code> に基づいて並び替えられるようになります。</p>
<p>プロキシモデルは <code class="docutils literal notranslate"><span class="pre">Meta</span></code> の属性値を <a class="reference internal" href="#meta-and-multi-table-inheritance"><span class="std std-ref">通常のモデルと同様に</span></a> 継承します。</p>
<section id="s-querysets-still-return-the-model-that-was-requested">
<span id="querysets-still-return-the-model-that-was-requested"></span><h4><code class="docutils literal notranslate"><span class="pre">QuerySet</span></code>s はリクエストされたモデルを返し続ける<a class="headerlink" href="#querysets-still-return-the-model-that-was-requested" title="Link to this heading">¶</a></h4>
<p>Django では、例えば <code class="docutils literal notranslate"><span class="pre">Person</span></code> オブジェクトにクエリした際に、<code class="docutils literal notranslate"><span class="pre">MyPerson</span></code> オブジェクトを返すようにする方法はありません。<code class="docutils literal notranslate"><span class="pre">Person</span></code> オブジェクトのクエリセットは、そのまま <code class="docutils literal notranslate"><span class="pre">Person</span></code> オブジェクトを返します。プロキシオブジェクトのポイントは、<code class="docutils literal notranslate"><span class="pre">Person</span></code> モデルに依存するコードはそのまま <code class="docutils literal notranslate"><span class="pre">Person</span></code> を使用しつつ、コード上ではあなたが独自に書いた拡張を利用できることにあります（他のコードがその拡張に依存することはありません）。つまり、<code class="docutils literal notranslate"><span class="pre">Person</span></code> （または他のモデル）をすべて自分の作成したものに置き換えるための方法ではありません。</p>
</section>
<section id="s-base-class-restrictions">
<span id="base-class-restrictions"></span><h4>基底クラスの制限<a class="headerlink" href="#base-class-restrictions" title="Link to this heading">¶</a></h4>
<p>プロキシモデルは、ちょうど1つの非抽象モデルクラスを継承しなければなりません。プロキシモデルは異なるデータベースのテーブル上の行の間にコネクションを作らないため、複数の非抽象クラスを継承することはできません。一方、プロキシモデルは、モデルフィールドを定義して <em>いない</em> 限り、抽象モデルクラスをいくつでも継承できます。また、プロキシモデルは、共通の非抽象な親クラスを持つプロキシモデルをいくつでも継承できます。</p>
</section>
<section id="s-proxy-model-managers">
<span id="proxy-model-managers"></span><h4>プロキシモデルマネージャー<a class="headerlink" href="#proxy-model-managers" title="Link to this heading">¶</a></h4>
<p>プロキシモデル上にモデルのマネージャーを定義しない場合、そのプロキシモデルはマネージャーを親のモデルから継承します。プロキシモデル上にマネージャーを定義した場合は、親クラス上のマネージャーで定義されて利用可能な物があったとしても、定義したほうのマネージャーがデフォルトになります。</p>
<p>先ほどの例の続きで、<code class="docutils literal notranslate"><span class="pre">Person</span></code> モデルにクエリを発行するときに使うデフォルトのマネージャを次のように変更できます：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">django.db</span><span class="w"> </span><span class="kn">import</span> <span class="n">models</span>


<span class="k">class</span><span class="w"> </span><span class="nc">NewManager</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Manager</span><span class="p">):</span>
    <span class="c1"># ...</span>
    <span class="k">pass</span>


<span class="k">class</span><span class="w"> </span><span class="nc">MyPerson</span><span class="p">(</span><span class="n">Person</span><span class="p">):</span>
    <span class="n">objects</span> <span class="o">=</span> <span class="n">NewManager</span><span class="p">()</span>

    <span class="k">class</span><span class="w"> </span><span class="nc">Meta</span><span class="p">:</span>
        <span class="n">proxy</span> <span class="o">=</span> <span class="kc">True</span>
</pre></div>
</div>
<p>既存のデフォルトのマネージャを置き換えることなく、新しいマネージャをプロキシに追加したい場合は、 <a class="reference internal" href="managers.html#custom-managers-and-inheritance"><span class="std std-ref">カスタムマネージャ</span></a> で説明したテクニックを使用できます。新しいマネージャを含む基底クラスを作成し、それを主要な基底クラスの後に多重継承します：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create an abstract class for the new manager.</span>
<span class="k">class</span><span class="w"> </span><span class="nc">ExtraManagers</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">secondary</span> <span class="o">=</span> <span class="n">NewManager</span><span class="p">()</span>

    <span class="k">class</span><span class="w"> </span><span class="nc">Meta</span><span class="p">:</span>
        <span class="n">abstract</span> <span class="o">=</span> <span class="kc">True</span>


<span class="k">class</span><span class="w"> </span><span class="nc">MyPerson</span><span class="p">(</span><span class="n">Person</span><span class="p">,</span> <span class="n">ExtraManagers</span><span class="p">):</span>
    <span class="k">class</span><span class="w"> </span><span class="nc">Meta</span><span class="p">:</span>
        <span class="n">proxy</span> <span class="o">=</span> <span class="kc">True</span>
</pre></div>
</div>
<p>これが必要になることはあまりないでしょうが、必要であれば上記のような実装も可能です。</p>
</section>
<section id="s-differences-between-proxy-inheritance-and-unmanaged-models">
<span id="s-proxy-vs-unmanaged-models"></span><span id="differences-between-proxy-inheritance-and-unmanaged-models"></span><span id="proxy-vs-unmanaged-models"></span><h4>プロキシモデルの継承と管理対象外モデルの違い<a class="headerlink" href="#differences-between-proxy-inheritance-and-unmanaged-models" title="Link to this heading">¶</a></h4>
<p>プロキシモデルの継承は、あるモデルの <code class="docutils literal notranslate"><span class="pre">Meta</span></code> クラスにおける <a class="reference internal" href="../../ref/models/options.html#django.db.models.Options.managed" title="django.db.models.Options.managed"><code class="xref py py-attr docutils literal notranslate"><span class="pre">managed</span></code></a> 属性を用いて Django に管理されないモデルを作成するのにかなり似ています。</p>
<p><a class="reference internal" href="../../ref/models/options.html#django.db.models.Options.db_table" title="django.db.models.Options.db_table"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Meta.db_table</span></code></a> を慎重に設定することで、既存のモデルを隠ぺいする管理対象外モデルを作成し、その既存モデルに Python メソッドを追加できます。しかし、この方法では変更を加えたときに両方のモデルを同期する必要があるため、とても冗長で変更に弱いものとなります。</p>
<p>一方、プロキシモデルは、プロキシ対象となるモデルと全く同じように動作することを意図しています。プロキシモデルは親モデルのフィールドとマネージャを直接継承しているため、常に親モデルと同期します。</p>
<p>原則としては:</p>
<ol class="arabic simple">
<li><p>もし既存のモデルやデータベースのテーブルを反映したいが元となるテーブルのカラムの全てを必要とする訳ではない場合は、 <code class="docutils literal notranslate"><span class="pre">Meta.managed=False</span></code> を利用してください。このオプションはデータベースのビューやテーブルを Django の管理下に置きたくない場合に通常有用となります。</p></li>
<li><p>モデルの Python 上の振る舞いだけを変更したいが、元のモデルと同じフィールドをすべて保持したい場合は、<code class="docutils literal notranslate"><span class="pre">Meta.proxy=True</span></code> を使用します。これにより、データが保存される際にプロキシモデルが元のモデルのストレージ構造の正確なコピーとなるように設定されます。</p></li>
</ol>
</section>
</section>
<section id="s-multiple-inheritance">
<span id="s-model-multiple-inheritance-topic"></span><span id="multiple-inheritance"></span><span id="model-multiple-inheritance-topic"></span><h3>多重継承<a class="headerlink" href="#multiple-inheritance" title="Link to this heading">¶</a></h3>
<p>Python のサブクラス化と同様に、Django モデルも複数の親モデルを継承することが可能です。ただし、通常の Python の名前解決ルールが適用される点に注意してください。ある名前 (例えば <a class="reference internal" href="#meta-options"><span class="std std-ref">Meta</span></a>) が最初に登場する基底クラスが使用されます。たとえば、複数の親クラスに <a class="reference internal" href="#meta-options"><span class="std std-ref">Meta</span></a> クラスが含まれている場合、最初のものだけが使用され、それ以降のものは無視されます。</p>
<p>通常、複数の親クラスを継承する必要はありません。これが有用となる主なケースは、「ミックスイン (mixin)」クラスを使う場合です。ミックスインを使うと、すべての子クラスで特定の追加フィールドやメソッドを利用できます。ただし、継承階層はできるだけシンプルで分かりやすく保つようにしてください。そうすることで、特定の情報がどこから来ているのかを把握するために苦労せずに済みます。</p>
<p>共通の <code class="docutils literal notranslate"><span class="pre">id</span></code> 主キーフィールドを持った複数のモデルを継承すると例外が送出されることに注意してください。多重継承を正常に使うために、基底モデル内で明示的に <a class="reference internal" href="../../ref/models/fields.html#django.db.models.AutoField" title="django.db.models.AutoField"><code class="xref py py-class docutils literal notranslate"><span class="pre">AutoField</span></code></a> を利用できます。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Article</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">article_id</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">AutoField</span><span class="p">(</span><span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="o">...</span>


<span class="k">class</span><span class="w"> </span><span class="nc">Book</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">book_id</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">AutoField</span><span class="p">(</span><span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="o">...</span>


<span class="k">class</span><span class="w"> </span><span class="nc">BookReview</span><span class="p">(</span><span class="n">Book</span><span class="p">,</span> <span class="n">Article</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>あるいは、共通の祖先を使って <a class="reference internal" href="../../ref/models/fields.html#django.db.models.AutoField" title="django.db.models.AutoField"><code class="xref py py-class docutils literal notranslate"><span class="pre">AutoField</span></code></a> を保持します。このためには、以下のように、自動生成されて子に継承されたフィールド間の衝突を避けるために、各親モデルから共通の祖先への <a class="reference internal" href="../../ref/models/fields.html#django.db.models.OneToOneField" title="django.db.models.OneToOneField"><code class="xref py py-class docutils literal notranslate"><span class="pre">OneToOneField</span></code></a> を明示的に使用する必要があります。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Piece</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">class</span><span class="w"> </span><span class="nc">Article</span><span class="p">(</span><span class="n">Piece</span><span class="p">):</span>
    <span class="n">article_piece</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">OneToOneField</span><span class="p">(</span>
        <span class="n">Piece</span><span class="p">,</span> <span class="n">on_delete</span><span class="o">=</span><span class="n">models</span><span class="o">.</span><span class="n">CASCADE</span><span class="p">,</span> <span class="n">parent_link</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">)</span>
    <span class="o">...</span>


<span class="k">class</span><span class="w"> </span><span class="nc">Book</span><span class="p">(</span><span class="n">Piece</span><span class="p">):</span>
    <span class="n">book_piece</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">OneToOneField</span><span class="p">(</span><span class="n">Piece</span><span class="p">,</span> <span class="n">on_delete</span><span class="o">=</span><span class="n">models</span><span class="o">.</span><span class="n">CASCADE</span><span class="p">,</span> <span class="n">parent_link</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="o">...</span>


<span class="k">class</span><span class="w"> </span><span class="nc">BookReview</span><span class="p">(</span><span class="n">Book</span><span class="p">,</span> <span class="n">Article</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</div>
</section>
<section id="s-field-name-hiding-is-not-permitted">
<span id="field-name-hiding-is-not-permitted"></span><h3>フィールド名の「隠ぺい」は許可されない<a class="headerlink" href="#field-name-hiding-is-not-permitted" title="Link to this heading">¶</a></h3>
<p>通常の Python のクラス継承では、親クラスから継承したあらゆる属性を子クラスがオーバーライドできます。Django では、この挙動は通常モデルのフィールドに対して許容されません。もし非抽象なモデルの基底クラスが <code class="docutils literal notranslate"><span class="pre">author</span></code> フィールドを持っていたとしたら、そのモデルの基底クラスを継承したあらゆるモデルクラス内では <code class="docutils literal notranslate"><span class="pre">author</span></code> という名称の属性値を別のモデルのフィールドや属性として定義できなくなります。</p>
<p>この制約は抽象モデルを継承したモデルのフィールドに対しては適用されません。こういったフィールドは別のフィールドや値によってオーバーライドされるか <code class="docutils literal notranslate"><span class="pre">field_name</span> <span class="pre">=</span> <span class="pre">None</span></code> を設定することで削除する事ができます:</p>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>モデルマネージャーは抽象基底クラスより継承されます。継承された <a class="reference internal" href="managers.html#django.db.models.Manager" title="django.db.models.Manager"><code class="xref py py-class docutils literal notranslate"><span class="pre">Manager</span></code></a> から参照される継承されたフィールドをオーバーライドすると、ちょっとしたバグを発生させることがあります。詳細は <a class="reference internal" href="managers.html#custom-managers-and-inheritance"><span class="std std-ref">カスタムマネージャーとモデルの継承</span></a> を参照ください。</p>
</div>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>ある種のフィールドはモデル上に特別な属性を定義します、例えば <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ForeignKey" title="django.db.models.ForeignKey"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForeignKey</span></code></a> は <code class="docutils literal notranslate"><span class="pre">_id</span></code> がフィールド名に付与された属性を、外部モデル上の <code class="docutils literal notranslate"><span class="pre">related_name</span></code> と <code class="docutils literal notranslate"><span class="pre">related_query_name</span></code> と同じように定義します。</p>
<p>これらの特別な属性はその属性を定義しているフィールドが、もはやその特別な属性を定義しなくなるように、変更もしくは削除されなければオーバーライドできません。</p>
</div>
<p>親モデルのフィールドをオーバーライドする事はインスタンス (どのフィールドが初期化されるか <code class="docutils literal notranslate"><span class="pre">Model.__init__</span></code> に定義している) の初期化やシリアライズ時の問題につながります。これらは通常の Python のクラス継承で全く同様に扱う事が求められていない機能であるため、 Django のモデル継承と Python のクラス継承のこうした差異は恣意的な設計による物ではありません。</p>
<p>この制限は <a class="reference internal" href="../../ref/models/fields.html#django.db.models.Field" title="django.db.models.Field"><code class="xref py py-class docutils literal notranslate"><span class="pre">Field</span></code></a> のインスタンスである属性にのみ適用されます。通常の Python の属性は必要に応じてオーバーライドできます。また、この制限は Python が認識する属性名にだけ適用されます。データベースのカラム名を手動で設定している場合は、マルチテーブル継承の関係にある子と祖先のモデルで同じカラム名を使えます（2つのカラムは別のデータベーステーブル内にあるからです）。</p>
<p>もし祖先モデルのいずれかに定義されたモデルのフィールドをオーバーライドした場合 Django は <a class="reference internal" href="../../ref/exceptions.html#django.core.exceptions.FieldError" title="django.core.exceptions.FieldError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">FieldError</span></code></a> 例外を送出します。</p>
<p>クラス定義中のフィールドの解決方法のため、複数の抽象親モデルから継承されたモデルのフィールドは、厳密な深さ優先順序で解決されることに注意してください。これは標準の Python の MRO とは対照的です。MRO では、ダイヤモンド型継承の場合には、幅優先で解決されます。この違いの影響を受けるのは複雑なモデル階層のみであり、これは（上記のアドバイスに従って）避けるべきです。</p>
</section>
</section>
<section id="s-organizing-models-in-a-package">
<span id="organizing-models-in-a-package"></span><h2>パッケージ化したモデルを扱う<a class="headerlink" href="#organizing-models-in-a-package" title="Link to this heading">¶</a></h2>
<p><a class="reference internal" href="../../ref/django-admin.html#django-admin-startapp"><code class="xref std std-djadmin docutils literal notranslate"><span class="pre">manage.py</span> <span class="pre">startapp</span></code></a> コマンドを実行することで <code class="docutils literal notranslate"><span class="pre">models.py</span></code> ファイルを含むアプリケーション構造が作成されます。多数のモデルが存在する場合、それらを別のファイルとして管理するのが良いかもしれません。</p>
<p>それを行うため、 <code class="docutils literal notranslate"><span class="pre">models</span></code> パッケージを作成します。 <code class="docutils literal notranslate"><span class="pre">models.py</span></code> を削除してモデルを保持するための <code class="docutils literal notranslate"><span class="pre">__init__.py</span></code> ファイルを持つ <code class="docutils literal notranslate"><span class="pre">myapp/models/</span></code> ディレクトリを作成します。作成した <code class="docutils literal notranslate"><span class="pre">__init__.py</span></code> でモデルをインポートする必要があります。</p>
<p>例えば、 <code class="docutils literal notranslate"><span class="pre">organic.py</span></code> および <code class="docutils literal notranslate"><span class="pre">synthetic.py</span></code> を <code class="docutils literal notranslate"><span class="pre">models</span></code> ディレクトリ内に持っている場合:</p>
<div class="literal-block-wrapper docutils container" id="id11">
<div class="code-block-caption"><span class="caption-text"><code class="docutils literal notranslate"><span class="pre">myapp/models/__init__.py</span></code></span><a class="headerlink" href="#id11" title="Link to this code">¶</a></div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">.organic</span><span class="w"> </span><span class="kn">import</span> <span class="n">Person</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.synthetic</span><span class="w"> </span><span class="kn">import</span> <span class="n">Robot</span>
</pre></div>
</div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">.models</span> <span class="pre">import</span> <span class="pre">*</span></code> という記述を用いずに各モデルを明示的にインポートする方法には名前空間を汚染しない、可読性を向上させる、コード解析ツールを有用な状態に保つという利点があります。</p>
<div class="admonition seealso">
<p class="admonition-title">参考</p>
<dl class="simple">
<dt><a class="reference internal" href="../../ref/models/index.html"><span class="doc">モデルの手引き</span></a></dt><dd><p>モデルのフィールド、関連オブジェクト、<code class="docutils literal notranslate"><span class="pre">QuerySet</span></code> を含む、モデルに関係するすべての API について説明しています。</p>
</dd>
</dl>
</div>
</section>
</section>


          </div>
        </div>
      </div>
      
        
          <div class="yui-b" id="sidebar">
            
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../../contents.html">目次</a></h3>
    <ul>
<li><a class="reference internal" href="#">モデル</a><ul>
<li><a class="reference internal" href="#quick-example">簡単な例</a></li>
<li><a class="reference internal" href="#using-models">モデルの利用</a></li>
<li><a class="reference internal" href="#fields">フィールド</a><ul>
<li><a class="reference internal" href="#field-types">フィールドの型</a></li>
<li><a class="reference internal" href="#field-options">フィールドオプション</a></li>
<li><a class="reference internal" href="#automatic-primary-key-fields">自動インクリメントのプライマリーキーフィールド</a></li>
<li><a class="reference internal" href="#verbose-field-names">詳細 (verbose) なフィールド名</a></li>
<li><a class="reference internal" href="#relationships">リレーションシップ</a><ul>
<li><a class="reference internal" href="#many-to-one-relationships">多対一 (many-to-one) 関係</a></li>
<li><a class="reference internal" href="#many-to-many-relationships">多対多 (many-to-many) 関係</a></li>
<li><a class="reference internal" href="#extra-fields-on-many-to-many-relationships">多対多のリレーションシップにおける追加フィールド</a></li>
<li><a class="reference internal" href="#one-to-one-relationships">一対一 (one-to-one) 関係</a></li>
</ul>
</li>
<li><a class="reference internal" href="#models-across-files">ファイルを横断したモデル</a></li>
<li><a class="reference internal" href="#field-name-restrictions">フィールド名の制約</a></li>
<li><a class="reference internal" href="#custom-field-types">カスタムのフィールドタイプ</a></li>
</ul>
</li>
<li><a class="reference internal" href="#meta-options"><code class="docutils literal notranslate"><span class="pre">Meta</span></code> オプション</a></li>
<li><a class="reference internal" href="#model-attributes">モデルの属性</a></li>
<li><a class="reference internal" href="#model-methods">モデルのメソッド</a><ul>
<li><a class="reference internal" href="#overriding-predefined-model-methods">定義済みのモデルメソッドをオーバーライドする</a></li>
<li><a class="reference internal" href="#executing-custom-sql">カスタムの SQL を実行する</a></li>
</ul>
</li>
<li><a class="reference internal" href="#model-inheritance">モデルの継承</a><ul>
<li><a class="reference internal" href="#abstract-base-classes">抽象基底クラス</a><ul>
<li><a class="reference internal" href="#meta-inheritance"><code class="docutils literal notranslate"><span class="pre">Meta</span></code> の継承</a></li>
<li><a class="reference internal" href="#be-careful-with-related-name-and-related-query-name"><code class="docutils literal notranslate"><span class="pre">related_name</span></code> と <code class="docutils literal notranslate"><span class="pre">related_query_name</span></code> の利用に関して注意するべき点</a></li>
</ul>
</li>
<li><a class="reference internal" href="#multi-table-inheritance">マルチテーブル継承</a><ul>
<li><a class="reference internal" href="#meta-and-multi-table-inheritance"><code class="docutils literal notranslate"><span class="pre">Meta</span></code> とマルチテーブル継承</a></li>
<li><a class="reference internal" href="#inheritance-and-reverse-relations">継承と関係の逆引き</a></li>
<li><a class="reference internal" href="#specifying-the-parent-link-field">親モデルとの関連付けに用いるフィールドを定義する</a></li>
</ul>
</li>
<li><a class="reference internal" href="#proxy-models">プロキシモデル</a><ul>
<li><a class="reference internal" href="#querysets-still-return-the-model-that-was-requested"><code class="docutils literal notranslate"><span class="pre">QuerySet</span></code>s はリクエストされたモデルを返し続ける</a></li>
<li><a class="reference internal" href="#base-class-restrictions">基底クラスの制限</a></li>
<li><a class="reference internal" href="#proxy-model-managers">プロキシモデルマネージャー</a></li>
<li><a class="reference internal" href="#differences-between-proxy-inheritance-and-unmanaged-models">プロキシモデルの継承と管理対象外モデルの違い</a></li>
</ul>
</li>
<li><a class="reference internal" href="#multiple-inheritance">多重継承</a></li>
<li><a class="reference internal" href="#field-name-hiding-is-not-permitted">フィールド名の「隠ぺい」は許可されない</a></li>
</ul>
</li>
<li><a class="reference internal" href="#organizing-models-in-a-package">パッケージ化したモデルを扱う</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>前のトピックへ</h4>
    <p class="topless"><a href="index.html"
                          title="前の章へ">モデルとデータベース</a></p>
  </div>
  <div>
    <h4>次のトピックへ</h4>
    <p class="topless"><a href="queries.html"
                          title="次の章へ">クエリを作成する</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>このページ</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/topics/db/models.txt"
            rel="nofollow">ソースコードを表示</a></li>
    </ul>
   </div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">クイック検索</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="検索" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
              <h3>Last update:</h3>
              <p class="topless">1月 22, 2025</p>
          </div>
        
      
    </div>

    <div id="ft">
      <div class="nav">
    &laquo; <a href="index.html" title="モデルとデータベース">previous</a>
     |
    <a href="../index.html" title="Django を使う" accesskey="U">up</a>
   |
    <a href="queries.html" title="クエリを作成する">next</a> &raquo;</div>
    </div>
  </div>

      <div class="clearer"></div>
    </div>
  </body>
</html>