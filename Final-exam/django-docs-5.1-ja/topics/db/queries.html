<!DOCTYPE html>

<html lang="ja" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>クエリを作成する &#8212; Django 5.1.6.dev20250122212402 ドキュメント</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=34bb78ad" />
    <link rel="stylesheet" type="text/css" href="../../_static/default.css?v=bf4d74af" />
    <script src="../../_static/documentation_options.js?v=d2885b0a"></script>
    <script src="../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/translations.js?v=4755f45a"></script>
    <link rel="index" title="索引" href="../../genindex.html" />
    <link rel="search" title="検索" href="../../search.html" />
    <link rel="next" title="アグリゲーション (集計)" href="aggregation.html" />
    <link rel="prev" title="モデル" href="models.html" />



 
<script src="../../templatebuiltins.js"></script>
<script>
(function($) {
    if (!django_template_builtins) {
       // templatebuiltins.js missing, do nothing.
       return;
    }
    $(document).ready(function() {
        // Hyperlink Django template tags and filters
        var base = "../../ref/templates/builtins.html";
        if (base == "#") {
            // Special case for builtins.html itself
            base = "";
        }
        // Tags are keywords, class '.k'
        $("div.highlight\\-html\\+django span.k").each(function(i, elem) {
             var tagname = $(elem).text();
             if ($.inArray(tagname, django_template_builtins.ttags) != -1) {
                 var fragment = tagname.replace(/_/, '-');
                 $(elem).html("<a href='" + base + "#" + fragment + "'>" + tagname + "</a>");
             }
        });
        // Filters are functions, class '.nf'
        $("div.highlight\\-html\\+django span.nf").each(function(i, elem) {
             var filtername = $(elem).text();
             if ($.inArray(filtername, django_template_builtins.tfilters) != -1) {
                 var fragment = filtername.replace(/_/, '-');
                 $(elem).html("<a href='" + base + "#" + fragment + "'>" + filtername + "</a>");
             }
        });
    });
})(jQuery);</script>

  </head><body>

    <div class="document">
  <div id="custom-doc" class="yui-t6">
    <div id="hd">
      <h1><a href="../../index.html">Django 5.1.6.dev20250122212402 ドキュメント</a></h1>
      <div id="global-nav">
        <a title="Home page" href="../../index.html">Home</a>  |
        <a title="Table of contents" href="../../contents.html">Table of contents</a>  |
        <a title="Global index" href="../../genindex.html">Index</a>  |
        <a title="Module index" href="../../py-modindex.html">Modules</a>
      </div>
      <div class="nav">
    &laquo; <a href="models.html" title="モデル">previous</a>
     |
    <a href="../index.html" title="Django を使う" accesskey="U">up</a>
   |
    <a href="aggregation.html" title="アグリゲーション (集計)">next</a> &raquo;</div>
    </div>

    <div id="bd">
      <div id="yui-main">
        <div class="yui-b">
          <div class="yui-g" id="topics-db-queries">
            
  <section id="s-making-queries">
<span id="making-queries"></span><h1>クエリを作成する<a class="headerlink" href="#making-queries" title="Link to this heading">¶</a></h1>
<p>一度 <a class="reference internal" href="models.html"><span class="doc">データモデル</span></a> を作成すれば、Django はデータオブジェクトの作成、取得、更新および削除を行えるようにデータベースを抽象化した API を自動的に提供します。本ドキュメントではこの API をどのように用いるかを説明します。多様なモデル探索オプション全てに関する詳細については <a class="reference internal" href="../../ref/models/index.html"><span class="doc">データモデルの項目</span></a> を参照ください。</p>
<p>このガイド（およびリファレンス）全体を通して、以下のモデルを参照します。これらはブログアプリケーションを構成するものです。</p>
<div class="highlight-python notranslate" id="queryset-model-example"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">datetime</span><span class="w"> </span><span class="kn">import</span> <span class="n">date</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">django.db</span><span class="w"> </span><span class="kn">import</span> <span class="n">models</span>


<span class="k">class</span><span class="w"> </span><span class="nc">Blog</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
    <span class="n">tagline</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">TextField</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>


<span class="k">class</span><span class="w"> </span><span class="nc">Author</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">200</span><span class="p">)</span>
    <span class="n">email</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">EmailField</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>


<span class="k">class</span><span class="w"> </span><span class="nc">Entry</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">blog</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">ForeignKey</span><span class="p">(</span><span class="n">Blog</span><span class="p">,</span> <span class="n">on_delete</span><span class="o">=</span><span class="n">models</span><span class="o">.</span><span class="n">CASCADE</span><span class="p">)</span>
    <span class="n">headline</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">255</span><span class="p">)</span>
    <span class="n">body_text</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">TextField</span><span class="p">()</span>
    <span class="n">pub_date</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">DateField</span><span class="p">()</span>
    <span class="n">mod_date</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">DateField</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="n">date</span><span class="o">.</span><span class="n">today</span><span class="p">)</span>
    <span class="n">authors</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">ManyToManyField</span><span class="p">(</span><span class="n">Author</span><span class="p">)</span>
    <span class="n">number_of_comments</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">IntegerField</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">number_of_pingbacks</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">IntegerField</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">rating</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">IntegerField</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">headline</span>
</pre></div>
</div>
<section id="s-creating-objects">
<span id="creating-objects"></span><h2>オブジェクトを作成する<a class="headerlink" href="#creating-objects" title="Link to this heading">¶</a></h2>
<p>Djangoでは、データベースのテーブルデータをPythonオブジェクトで表現するために、直感的な仕組みを採用しています。モデルクラスはデータベースのテーブルを表し、そのクラスのインスタンスはデータベーステーブル内の特定のレコードを表します。</p>
<p>オブジェクトを生成するためには、作成するモデルのクラスにキーワード引数を渡してインスタンス化し、そのデータをデータベースに保存するために <a class="reference internal" href="../../ref/models/instances.html#django.db.models.Model.save" title="django.db.models.Model.save"><code class="xref py py-meth docutils literal notranslate"><span class="pre">save()</span></code></a> を呼び出します。</p>
<p>以下はモデルがDjangoアプリ <code class="docutils literal notranslate"><span class="pre">blog</span></code> 内の <code class="docutils literal notranslate"><span class="pre">models.py</span></code> ファイルに存在する場合の例です。</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">blog.models</span><span class="w"> </span><span class="kn">import</span> <span class="n">Blog</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">Blog</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Beatles Blog&quot;</span><span class="p">,</span> <span class="n">tagline</span><span class="o">=</span><span class="s2">&quot;All the latest Beatles news.&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
</pre></div>
</div>
<p>この例では内部で <code class="docutils literal notranslate"><span class="pre">INSERT</span></code> SQL 文が処理されます。明示的に <a class="reference internal" href="../../ref/models/instances.html#django.db.models.Model.save" title="django.db.models.Model.save"><code class="xref py py-meth docutils literal notranslate"><span class="pre">save()</span></code></a> を呼ぶまで Django はデータベースを操作しません。</p>
<p><a class="reference internal" href="../../ref/models/instances.html#django.db.models.Model.save" title="django.db.models.Model.save"><code class="xref py py-meth docutils literal notranslate"><span class="pre">save()</span></code></a> メソッドは値を返しません。</p>
<div class="admonition seealso">
<p class="admonition-title">参考</p>
<p><a class="reference internal" href="../../ref/models/instances.html#django.db.models.Model.save" title="django.db.models.Model.save"><code class="xref py py-meth docutils literal notranslate"><span class="pre">save()</span></code></a> はここには記述されていない多数の高度なオプションを持ちます。詳細については <a class="reference internal" href="../../ref/models/instances.html#django.db.models.Model.save" title="django.db.models.Model.save"><code class="xref py py-meth docutils literal notranslate"><span class="pre">save()</span></code></a> の項目を参照してください。</p>
<p>オブジェクトの作成と保存を一つの処理で行うには、 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.create" title="django.db.models.query.QuerySet.create"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create()</span></code></a> メソッドを利用してください。</p>
</div>
</section>
<section id="s-saving-changes-to-objects">
<span id="saving-changes-to-objects"></span><h2>オブジェクトに対する変更を保存する<a class="headerlink" href="#saving-changes-to-objects" title="Link to this heading">¶</a></h2>
<p>既にデータベース上に存在する 1 つのオブジェクトに対する変更を保存するには、 <a class="reference internal" href="../../ref/models/instances.html#django.db.models.Model.save" title="django.db.models.Model.save"><code class="xref py py-meth docutils literal notranslate"><span class="pre">save()</span></code></a> を利用します。</p>
<p>すでにデータベースに保存されている <code class="docutils literal notranslate"><span class="pre">Blog</span></code> インスタンス <code class="docutils literal notranslate"><span class="pre">b5</span></code> がある場合、この例ではその名前を変更し、データベース内のレコードを更新します:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b5</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;New name&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b5</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
</pre></div>
</div>
<p>この例では内部で <code class="docutils literal notranslate"><span class="pre">UPDATE</span></code> SQL 文が処理されます。明示的に <a class="reference internal" href="../../ref/models/instances.html#django.db.models.Model.save" title="django.db.models.Model.save"><code class="xref py py-meth docutils literal notranslate"><span class="pre">save()</span></code></a> が呼ばれるまで Django はデータベースを操作しません。</p>
<section id="s-saving-foreignkey-and-manytomanyfield-fields">
<span id="saving-foreignkey-and-manytomanyfield-fields"></span><h3><code class="docutils literal notranslate"><span class="pre">ForeignKey</span></code> と <code class="docutils literal notranslate"><span class="pre">ManyToManyField</span></code> フィールドを扱う<a class="headerlink" href="#saving-foreignkey-and-manytomanyfield-fields" title="Link to this heading">¶</a></h3>
<p><a class="reference internal" href="../../ref/models/fields.html#django.db.models.ForeignKey" title="django.db.models.ForeignKey"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForeignKey</span></code></a> フィールドを更新するには、通常のフィールドを保存するのと全く同じように、該当のフィールドに適切なタイプのオブジェクトを割り当てます。以下の例では、 <code class="docutils literal notranslate"><span class="pre">Entry</span></code> インスタンス <code class="docutils literal notranslate"><span class="pre">entry</span></code> の <code class="docutils literal notranslate"><span class="pre">blog</span></code> 属性を更新しています。ここでは、 <code class="docutils literal notranslate"><span class="pre">Entry</span></code> と <code class="docutils literal notranslate"><span class="pre">Blog</span></code> の適切なインスタンスが既にデータベースに保存されていると仮定しています（したがって、以下でそれらを取得できます）。</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">blog.models</span><span class="w"> </span><span class="kn">import</span> <span class="n">Blog</span><span class="p">,</span> <span class="n">Entry</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">entry</span> <span class="o">=</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">pk</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cheese_blog</span> <span class="o">=</span> <span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Cheddar Talk&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">entry</span><span class="o">.</span><span class="n">blog</span> <span class="o">=</span> <span class="n">cheese_blog</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">entry</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
</pre></div>
</div>
<p><a class="reference internal" href="../../ref/models/fields.html#django.db.models.ManyToManyField" title="django.db.models.ManyToManyField"><code class="xref py py-class docutils literal notranslate"><span class="pre">ManyToManyField</span></code></a> を更新する方法は少し異なります。関連するフィールド上の <a class="reference internal" href="../../ref/models/relations.html#django.db.models.fields.related.RelatedManager.add" title="django.db.models.fields.related.RelatedManager.add"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add()</span></code></a> メソッドを使用して、リレーションにレコードを追加します。以下の例では、 <code class="docutils literal notranslate"><span class="pre">Author</span></code> インスタンス <code class="docutils literal notranslate"><span class="pre">joe</span></code> を <code class="docutils literal notranslate"><span class="pre">entry</span></code> オブジェクトに追加しています:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">blog.models</span><span class="w"> </span><span class="kn">import</span> <span class="n">Author</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">joe</span> <span class="o">=</span> <span class="n">Author</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Joe&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">entry</span><span class="o">.</span><span class="n">authors</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">joe</span><span class="p">)</span>
</pre></div>
</div>
<p>複数のレコードを <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ManyToManyField" title="django.db.models.ManyToManyField"><code class="xref py py-class docutils literal notranslate"><span class="pre">ManyToManyField</span></code></a> に一気に追加するには、 <a class="reference internal" href="../../ref/models/relations.html#django.db.models.fields.related.RelatedManager.add" title="django.db.models.fields.related.RelatedManager.add"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add()</span></code></a> の呼び出しに複数の引数を含めてください:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">john</span> <span class="o">=</span> <span class="n">Author</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;John&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">paul</span> <span class="o">=</span> <span class="n">Author</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Paul&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">george</span> <span class="o">=</span> <span class="n">Author</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;George&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ringo</span> <span class="o">=</span> <span class="n">Author</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Ringo&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">entry</span><span class="o">.</span><span class="n">authors</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">john</span><span class="p">,</span> <span class="n">paul</span><span class="p">,</span> <span class="n">george</span><span class="p">,</span> <span class="n">ringo</span><span class="p">)</span>
</pre></div>
</div>
<p>もし間違った型のオブジェクトを設定もしくは追加しようとすれば Django はエラーを発生させます。</p>
</section>
</section>
<section id="s-retrieving-objects">
<span id="s-id1"></span><span id="retrieving-objects"></span><span id="id1"></span><h2>オブジェクトを取得する<a class="headerlink" href="#retrieving-objects" title="Link to this heading">¶</a></h2>
<p>データベースからオブジェクトを取得するには、モデルクラスの <a class="reference internal" href="managers.html#django.db.models.Manager" title="django.db.models.Manager"><code class="xref py py-class docutils literal notranslate"><span class="pre">Manager</span></code></a> から <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> を作ります。</p>
<p><a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> はデータベース上のオブジェクトの集合を表しています。多数の <em>フィルタ</em> を持つことができます。フィルタは与えられたパラメータに基づいてクエリの検索結果を絞り込みます。SQL 文においては、 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> は <code class="docutils literal notranslate"><span class="pre">SELECT</span></code> 句、フィルタは <code class="docutils literal notranslate"><span class="pre">WHERE</span></code> や <code class="docutils literal notranslate"><span class="pre">LIMIT</span></code> のような絞り込みに用いる句に対応しています。</p>
<p>モデルの <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> を取得するには、モデルの <a class="reference internal" href="managers.html#django.db.models.Manager" title="django.db.models.Manager"><code class="xref py py-class docutils literal notranslate"><span class="pre">Manager</span></code></a> を使用します。各モデルには少なくとも1つの <a class="reference internal" href="managers.html#django.db.models.Manager" title="django.db.models.Manager"><code class="xref py py-class docutils literal notranslate"><span class="pre">Manager</span></code></a> があり、デフォルトでは <a class="reference internal" href="../../ref/models/class.html#django.db.models.Model.objects" title="django.db.models.Model.objects"><code class="xref py py-attr docutils literal notranslate"><span class="pre">objects</span></code></a> という名前がついています。モデルクラスから直接アクセスしてください:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span>
<span class="go">&lt;django.db.models.manager.Manager object at ...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">Blog</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Foo&quot;</span><span class="p">,</span> <span class="n">tagline</span><span class="o">=</span><span class="s2">&quot;Bar&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">objects</span>
<span class="go">Traceback:</span>
<span class="go">    ...</span>
<span class="go">AttributeError: &quot;Manager isn&#39;t accessible via Blog instances.&quot;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p><code class="docutils literal notranslate"><span class="pre">Manager</span></code> はモデルのインスタンスでなく、モデルのクラスを経由してのみアクセスでき、それは &quot;テーブル水準&quot; の処理と &quot;レコード水準&quot; の処理とで責任を明確に分離するためです。</p>
</div>
<p><a class="reference internal" href="managers.html#django.db.models.Manager" title="django.db.models.Manager"><code class="xref py py-class docutils literal notranslate"><span class="pre">Manager</span></code></a> はモデルの <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code> の主な取得元になります。たとえば、 <code class="docutils literal notranslate"><span class="pre">Blog.objects.all()</span></code> はデータベース内の <code class="docutils literal notranslate"><span class="pre">Blog</span></code> オブジェクト全てを含んだ <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> を返します。</p>
<section id="s-retrieving-all-objects">
<span id="retrieving-all-objects"></span><h3>すべてのオブジェクトを取得する<a class="headerlink" href="#retrieving-all-objects" title="Link to this heading">¶</a></h3>
<p>テーブルからオブジェクトを取得する最も簡単な方法は、全てのオブジェクトを取得することです。これを行うには、 <a class="reference internal" href="managers.html#django.db.models.Manager" title="django.db.models.Manager"><code class="xref py py-class docutils literal notranslate"><span class="pre">Manager</span></code></a> の <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.all" title="django.db.models.query.QuerySet.all"><code class="xref py py-meth docutils literal notranslate"><span class="pre">all()</span></code></a> メソッドを使います:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">all_entries</span> <span class="o">=</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
</pre></div>
</div>
<p><a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.all" title="django.db.models.query.QuerySet.all"><code class="xref py py-meth docutils literal notranslate"><span class="pre">all()</span></code></a> メソッドは、データベース内のすべてのオブジェクトを含んだ <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> を返します。</p>
</section>
<section id="s-retrieving-specific-objects-with-filters">
<span id="retrieving-specific-objects-with-filters"></span><h3>フィルタを使って特定のオブジェクトを取得する<a class="headerlink" href="#retrieving-specific-objects-with-filters" title="Link to this heading">¶</a></h3>
<p><a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.all" title="django.db.models.query.QuerySet.all"><code class="xref py py-meth docutils literal notranslate"><span class="pre">all()</span></code></a> が返す <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> には、データベーステーブルのすべてのオブジェクトが含まれています。しかし、ふつう必要になるのはオブジェクト全体の集合ではなく、その部分集合でしょう。</p>
<p>そのような部分集合を作るには、条件フィルタを追加して最初の <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> を絞り込みます。 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> を絞り込む代表的な方法として次の2つのものがあります。</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">filter(**kwargs)</span></code></dt><dd><p>与えられたルックアップパラメータにマッチする新しい <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> を返します。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">exclude(**kwargs)</span></code></dt><dd><p>与えられたルックアップパラメータにマッチ <em>しない</em> 新しい <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> を返します。</p>
</dd>
</dl>
<p>ルックアップパラメータ (上の関数定義における <code class="docutils literal notranslate"><span class="pre">**kwargs</span></code> ) は、以下の <a class="reference internal" href="#field-lookups">Field lookups</a> で説明するフォーマットに従わなければなりません。</p>
<p>たとえば、2006年以降のブログエントリーの <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> を取得するには、 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.filter" title="django.db.models.query.QuerySet.filter"><code class="xref py py-meth docutils literal notranslate"><span class="pre">filter()</span></code></a> を次のように使用します。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">pub_date__year</span><span class="o">=</span><span class="mi">2006</span><span class="p">)</span>
</pre></div>
</div>
<p>デフォルトの manager クラスの場合、これは次のコードと等価です。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">()</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">pub_date__year</span><span class="o">=</span><span class="mi">2006</span><span class="p">)</span>
</pre></div>
</div>
<section id="s-chaining-filters">
<span id="s-id2"></span><span id="chaining-filters"></span><span id="id2"></span><h4>フィルタの連結<a class="headerlink" href="#chaining-filters" title="Link to this heading">¶</a></h4>
<p>フィルタを行った <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> の結果自体も <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> です。そのため、複数のフィルタを連結することが可能です。たとえば、次のように書くことができます。</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">headline__startswith</span><span class="o">=</span><span class="s2">&quot;What&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">exclude</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">pub_date__gte</span><span class="o">=</span><span class="n">datetime</span><span class="o">.</span><span class="n">date</span><span class="o">.</span><span class="n">today</span><span class="p">()</span>
<span class="gp">... </span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">pub_date__gte</span><span class="o">=</span><span class="n">datetime</span><span class="o">.</span><span class="n">date</span><span class="p">(</span><span class="mi">2005</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">30</span><span class="p">))</span>
</pre></div>
</div>
<p>これはデータベース内のすべてのエントリーを含む <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> をとり、フィルタを追加し、除外フィルタを追加し、さらにもう1つのフィルタを追加しています。最終的な結果は、&quot;What&quot; で始まるヘッドラインを持ち、2005年1月30日から今日までに公開されたすべてのエントリーを含んだ <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> となります。</p>
</section>
<section id="s-filtered-querysets-are-unique">
<span id="s-id3"></span><span id="filtered-querysets-are-unique"></span><span id="id3"></span><h4>フィルタを適用した <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code> はユニーク<a class="headerlink" href="#filtered-querysets-are-unique" title="Link to this heading">¶</a></h4>
<p><a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> に対してフィルタを適用するごとに、前の <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> から独立した完全に新しい <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> が作られます。フィルタごとに独立した <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> が作られるため、保存したり何度も再利用したりできます。</p>
<p>例:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">q1</span> <span class="o">=</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">headline__startswith</span><span class="o">=</span><span class="s2">&quot;What&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q2</span> <span class="o">=</span> <span class="n">q1</span><span class="o">.</span><span class="n">exclude</span><span class="p">(</span><span class="n">pub_date__gte</span><span class="o">=</span><span class="n">datetime</span><span class="o">.</span><span class="n">date</span><span class="o">.</span><span class="n">today</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q3</span> <span class="o">=</span> <span class="n">q1</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">pub_date__gte</span><span class="o">=</span><span class="n">datetime</span><span class="o">.</span><span class="n">date</span><span class="o">.</span><span class="n">today</span><span class="p">())</span>
</pre></div>
</div>
<p>これら3つの <code class="docutils literal notranslate"><span class="pre">QuerySets</span></code> は独立しています。1番目は基本の <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> で、&quot;What&quot; で始まるヘッドラインを持つ全てのエントリーを含みます。2番めは1番目の部分集合で、 <code class="docutils literal notranslate"><span class="pre">pub_date</span></code> が今日または未来の日付であるレコードを除外する追加条件を持ちます。3番目も1番目の部分集合で、 <code class="docutils literal notranslate"><span class="pre">pub_date</span></code> が今日または未来の日付であるレコードだけを選択する追加条件を持ちます。1番目の <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> (<code class="docutils literal notranslate"><span class="pre">q1</span></code>) は、絞り込みの過程において何ら影響を受けません。</p>
</section>
<section id="s-querysets-are-lazy">
<span id="s-id4"></span><span id="querysets-are-lazy"></span><span id="id4"></span><h4><code class="docutils literal notranslate"><span class="pre">QuerySet</span></code> は遅延評価される<a class="headerlink" href="#querysets-are-lazy" title="Link to this heading">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">QuerySets</span></code> は遅延評価されます。 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> を作る行為はいかなるデータベース操作も引き起こしません。たとえあなたが 1 日中フィルタのスタックを積み上げたとしても、<a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> が <em>評価される</em> までは、Django は実際にはクエリを実行しません。次の例を見てください。</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">q</span> <span class="o">=</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">headline__startswith</span><span class="o">=</span><span class="s2">&quot;What&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">pub_date__lte</span><span class="o">=</span><span class="n">datetime</span><span class="o">.</span><span class="n">date</span><span class="o">.</span><span class="n">today</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">exclude</span><span class="p">(</span><span class="n">body_text__icontains</span><span class="o">=</span><span class="s2">&quot;food&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
</pre></div>
</div>
<p>この例ではデータベースに3回アクセスしているように見えますが、実際にアクセスしているのは、最終行 (<code class="docutils literal notranslate"><span class="pre">print(q)</span></code>) での1回だけです。一般に、 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> の結果は、明示的に要求するまでデータベースから取得されません。取得するように要求した時点で、 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> は <em>評価</em> され、データベースへのアクセスが発生します。評価が起こる正確なタイミングの詳細については、 <a class="reference internal" href="../../ref/models/querysets.html#when-querysets-are-evaluated"><span class="std std-ref">QuerySet が評価されるタイミング</span></a> を参照してください。</p>
</section>
</section>
<section id="s-retrieving-a-single-object-with-get">
<span id="s-retrieving-single-object-with-get"></span><span id="retrieving-a-single-object-with-get"></span><span id="retrieving-single-object-with-get"></span><h3><code class="docutils literal notranslate"><span class="pre">get()</span></code> を使って1つのオブジェクトを取得する<a class="headerlink" href="#retrieving-a-single-object-with-get" title="Link to this heading">¶</a></h3>
<p><a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.filter" title="django.db.models.query.QuerySet.filter"><code class="xref py py-meth docutils literal notranslate"><span class="pre">filter()</span></code></a> は、たとえクエリーにマッチしたのが1つのオブジェクトだけだったとしても、常に <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> を返します。この場合、 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> には1つの要素だけが含まれることになります。</p>
<p>クエリーにマッチするのは1つのオブジェクトだけだと分かっている場合、  <a class="reference internal" href="managers.html#django.db.models.Manager" title="django.db.models.Manager"><code class="xref py py-class docutils literal notranslate"><span class="pre">Manager</span></code></a> の <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.get" title="django.db.models.query.QuerySet.get"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get()</span></code></a> メソッドを呼べば、そのオブジェクトが直接返されます。</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">one_entry</span> <span class="o">=</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">pk</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p><a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.filter" title="django.db.models.query.QuerySet.filter"><code class="xref py py-meth docutils literal notranslate"><span class="pre">filter()</span></code></a> と同じように、 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.get" title="django.db.models.query.QuerySet.get"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get()</span></code></a> には任意のクエリー表現が使用できます。 繰り返しますが、詳しくはあとで説明する <a class="reference internal" href="#field-lookups">Field lookups</a> を見てください。</p>
<p><a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.get" title="django.db.models.query.QuerySet.get"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get()</span></code></a> と <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.filter" title="django.db.models.query.QuerySet.filter"><code class="xref py py-meth docutils literal notranslate"><span class="pre">filter()</span></code></a> を <code class="docutils literal notranslate"><span class="pre">[0]</span></code> でスライスすることには、次のような違いがあることに注意してください。クエリにマッチする結果が存在しない場合、 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.get" title="django.db.models.query.QuerySet.get"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get()</span></code></a> は <code class="docutils literal notranslate"><span class="pre">DoesNotExist</span></code> 例外を起こします。この例外はクエリーが実行されるモデルクラスの属性です。たとえば上のコードでは、1というプライマリーキーを持つ <code class="docutils literal notranslate"><span class="pre">Entry</span></code> オブジェクトがなければ、Django は <code class="docutils literal notranslate"><span class="pre">Entry.DoesNotExist</span></code> 例外を起こします。</p>
<p>同様に <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.get" title="django.db.models.query.QuerySet.get"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get()</span></code></a> のクエリーが2つ以上のアイテムにマッチした場合にも、Djangoは文句を言います。この場合には、やはり同じクエリのモデルクラスの属性の <a class="reference internal" href="../../ref/exceptions.html#django.core.exceptions.MultipleObjectsReturned" title="django.core.exceptions.MultipleObjectsReturned"><code class="xref py py-exc docutils literal notranslate"><span class="pre">MultipleObjectsReturned</span></code></a> 例外が起こります。</p>
</section>
<section id="s-other-queryset-methods">
<span id="other-queryset-methods"></span><h3>その他の <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code> メソッド<a class="headerlink" href="#other-queryset-methods" title="Link to this heading">¶</a></h3>
<p>データベースからオブジェクトを検索する必要がある大抵の場合は、 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.all" title="django.db.models.query.QuerySet.all"><code class="xref py py-meth docutils literal notranslate"><span class="pre">all()</span></code></a>, <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.get" title="django.db.models.query.QuerySet.get"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get()</span></code></a>, <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.filter" title="django.db.models.query.QuerySet.filter"><code class="xref py py-meth docutils literal notranslate"><span class="pre">filter()</span></code></a> および <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.exclude" title="django.db.models.query.QuerySet.exclude"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exclude()</span></code></a> のいずれかを使うことになるでしょう。しかしこれらのメソッドだけでは不十分な場合は、さまざまな <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> メソッドの全リストが掲載されている <a class="reference internal" href="../../ref/models/querysets.html#queryset-api"><span class="std std-ref">QuerySet API リファレンス</span></a> を参照してください。</p>
</section>
<section id="s-limiting-querysets">
<span id="s-id5"></span><span id="limiting-querysets"></span><span id="id5"></span><h3><code class="docutils literal notranslate"><span class="pre">QuerySet</span></code> の要素数を制限する<a class="headerlink" href="#limiting-querysets" title="Link to this heading">¶</a></h3>
<p>Python のリストスライスのサブセットを使うことで <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> の結果を特定の要素数に制限できます。これは SQL の <code class="docutils literal notranslate"><span class="pre">LIMIT</span></code> と <code class="docutils literal notranslate"><span class="pre">OFFSET</span></code> 句に対応します。</p>
<p>たとえば、次のコードは最初の5つのオブジェクトを返します (<code class="docutils literal notranslate"><span class="pre">LIMIT</span> <span class="pre">5</span></code>)。</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">()[:</span><span class="mi">5</span><span class="p">]</span>
</pre></div>
</div>
<p>次のコードは、6番目から10番目までのオブジェクトを返します (<code class="docutils literal notranslate"><span class="pre">OFFSET</span> <span class="pre">5</span> <span class="pre">LIMIT</span> <span class="pre">5</span></code>)。</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">()[</span><span class="mi">5</span><span class="p">:</span><span class="mi">10</span><span class="p">]</span>
</pre></div>
</div>
<p>負のインデックスには対応していません (例: <code class="docutils literal notranslate"><span class="pre">Entry.objects.all()[-1]</span></code>)。</p>
<p>一般に、 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> をスライスしたとしても、新しい <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> が返り、クエリーの評価は行われません。例外は、Python のリストスライス構文の &quot;step&quot; パラメーターを使用した場合です。たとえば、次のコードは実際にクエリを実行し、最初の10個のオブジェクトから一つおきにとったオブジェクトのリストを返します。</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">()[:</span><span class="mi">10</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
</pre></div>
</div>
<p>スライスされたクエリーセットのフィルタリングやソートは、動作が曖昧なため禁止されています。</p>
<p>リスト (例: <code class="docutils literal notranslate"><span class="pre">SELECT</span> <span class="pre">foo</span> <span class="pre">FROM</span> <span class="pre">bar</span> <span class="pre">LIMIT</span> <span class="pre">1</span></code>) ではなく <em>1つの</em> オブジェクトを取得するには、スライスではなくリストのインデックスを使用してください。たとえば、次のコードは、ヘッドラインでアルファベット順にソートしたあと、データベースの1番目の <code class="docutils literal notranslate"><span class="pre">Entry</span></code> を返します。</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="s2">&quot;headline&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<p>上の例は次のコードとほとんど同じです。</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="s2">&quot;headline&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
</pre></div>
</div>
<p>ただし、与えられた条件を満たすオブジェクトが存在しない場合に、前者は <code class="docutils literal notranslate"><span class="pre">IndexError</span></code> を起こすのに対して、後者は <code class="docutils literal notranslate"><span class="pre">DoesNotExist</span></code> を起こすことに注意してください。詳細については <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.get" title="django.db.models.query.QuerySet.get"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get()</span></code></a> を参照してください。</p>
</section>
<section id="s-field-lookups">
<span id="s-field-lookups-intro"></span><span id="field-lookups"></span><span id="field-lookups-intro"></span><h3>フィールドルックアップ<a class="headerlink" href="#field-lookups" title="Link to this heading">¶</a></h3>
<p>フィールドルックアップは、SQL の <code class="docutils literal notranslate"><span class="pre">WHERE</span></code> 句の内容を指定する手段です。 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> メソッド、 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.filter" title="django.db.models.query.QuerySet.filter"><code class="xref py py-meth docutils literal notranslate"><span class="pre">filter()</span></code></a> 、 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.exclude" title="django.db.models.query.QuerySet.exclude"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exclude()</span></code></a> および <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.get" title="django.db.models.query.QuerySet.get"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get()</span></code></a> にキーワード引数として指定します。</p>
<p>基本のルックアップキーワード引数は <code class="docutils literal notranslate"><span class="pre">field__lookuptype=value</span></code> という形を取ります (2文字連続するアンダースコアです)。たとえば、</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">pub_date__lte</span><span class="o">=</span><span class="s2">&quot;2006-01-01&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>というコードは、(だいたい) 次の SQL 文に変換されます。</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">blog_entry</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">pub_date</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="s1">&#39;2006-01-01&#39;</span><span class="p">;</span>
</pre></div>
</div>
<div class="admonition-how-this-is-possible admonition">
<p class="admonition-title">動作のしくみ</p>
<p>Python には任意の name-value 形式の引数をとる関数を定義する能力があり、name と value の値を実行時に評価します。詳しい情報については、公式の Python チュートリアルの <a class="reference external" href="https://docs.python.org/3/tutorial/controlflow.html#tut-keywordargs" title="(in Python v3.13)"><span>Keyword Arguments</span></a> を参照してください。</p>
</div>
<p>ルックアップに指定するフィールドはモデルが持つフィールド名でなければなりません。ただし1つだけ例外があり、 <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ForeignKey" title="django.db.models.ForeignKey"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForeignKey</span></code></a> の場合にはフィールド名の末尾に <code class="docutils literal notranslate"><span class="pre">_id</span></code> を付けた名前を指定できます。その場合、value  パラメータには外部モデルのプライマリーキーの生の値を書くことが期待されます。</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">blog_id</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
<p>無効なキーワード引数を指定すると、ルックアップ関数は <code class="docutils literal notranslate"><span class="pre">TypeError</span></code> を起こします。</p>
<p>データベース API は約30個のルックアップタイプをサポートしており、完全なガイドは <a class="reference internal" href="../../ref/models/querysets.html#field-lookups"><span class="std std-ref">フィールドルックアップのリファレンス</span></a> で見ることができます。ルックアップを使って何ができるのかがよく分かるように、以下によく使う一般的なルックアップをいくつか挙げます。</p>
<dl>
<dt><a class="reference internal" href="../../ref/models/querysets.html#std-fieldlookup-exact"><code class="xref std std-lookup docutils literal notranslate"><span class="pre">exact</span></code></a></dt><dd><p>完全な (&quot;exact&quot;) マッチを行います。たとえば、</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">headline__exact</span><span class="o">=</span><span class="s2">&quot;Cat bites dog&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>は次のような SQL を生成します。</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">headline</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;Cat bites dog&#39;</span><span class="p">;</span>
</pre></div>
</div>
<p>ルックアップタイプを指定しなかった場合、つまりキーワード引数がダブルアンダースコアを含まない場合、ルックアップタイプは <code class="docutils literal notranslate"><span class="pre">exact</span></code> が指定されたものとみなされます。</p>
<p>たとえば、次の2つの文は等価です。</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">id__exact</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>  <span class="c1"># Explicit form</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>  <span class="c1"># __exact is implied</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">exact</span></code> ルックアップが最もよく使われるため、利便性のためにこのようになっています。</p>
</dd>
<dt><a class="reference internal" href="../../ref/models/querysets.html#std-fieldlookup-iexact"><code class="xref std std-lookup docutils literal notranslate"><span class="pre">iexact</span></code></a></dt><dd><p>case-insensitive  なマッチを行います。したがって、次のクエリ</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name__iexact</span><span class="o">=</span><span class="s2">&quot;beatles blog&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>は <code class="docutils literal notranslate"><span class="pre">&quot;Beatles</span> <span class="pre">Blog&quot;</span></code>、 <code class="docutils literal notranslate"><span class="pre">&quot;beatles</span> <span class="pre">blog&quot;</span></code>、あるいは <code class="docutils literal notranslate"><span class="pre">&quot;BeAtlES</span> <span class="pre">blOG&quot;</span></code> というタイトルを持つ <code class="docutils literal notranslate"><span class="pre">Blog</span></code> にもマッチします。</p>
</dd>
<dt><a class="reference internal" href="../../ref/models/querysets.html#std-fieldlookup-contains"><code class="xref std std-lookup docutils literal notranslate"><span class="pre">contains</span></code></a></dt><dd><p>case-sensitive な部分一致テストを行います。たとえば、</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">headline__contains</span><span class="o">=</span><span class="s2">&quot;Lennon&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>はだいたい次のような SQL に変換されます。</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">headline</span><span class="w"> </span><span class="k">LIKE</span><span class="w"> </span><span class="s1">&#39;%Lennon%&#39;</span><span class="p">;</span>
</pre></div>
</div>
<p>この例では、ヘッドライン <code class="docutils literal notranslate"><span class="pre">'Today</span> <span class="pre">Lennon</span> <span class="pre">honored'</span></code> にはマッチしても <code class="docutils literal notranslate"><span class="pre">'today</span> <span class="pre">lennon</span> <span class="pre">honored'</span></code> にはマッチしないことに注意してください。</p>
<p>case-insensitive バージョンの <a class="reference internal" href="../../ref/models/querysets.html#std-fieldlookup-icontains"><code class="xref std std-lookup docutils literal notranslate"><span class="pre">icontains</span></code></a> もあります。</p>
</dd>
<dt><a class="reference internal" href="../../ref/models/querysets.html#std-fieldlookup-startswith"><code class="xref std std-lookup docutils literal notranslate"><span class="pre">startswith</span></code></a> と <a class="reference internal" href="../../ref/models/querysets.html#std-fieldlookup-endswith"><code class="xref std std-lookup docutils literal notranslate"><span class="pre">endswith</span></code></a></dt><dd><p>それぞれ starts-with と ends-with 検索を行います。case-insensitive バージョン <a class="reference internal" href="../../ref/models/querysets.html#std-fieldlookup-istartswith"><code class="xref std std-lookup docutils literal notranslate"><span class="pre">istartswith</span></code></a> と <a class="reference internal" href="../../ref/models/querysets.html#std-fieldlookup-iendswith"><code class="xref std std-lookup docutils literal notranslate"><span class="pre">iendswith</span></code></a> もあります。</p>
</dd>
</dl>
<p>繰り返しになりますが、以上はルックアップの表面をさらったに過ぎません。完全なリファレンスは <a class="reference internal" href="../../ref/models/querysets.html#field-lookups"><span class="std std-ref">フィールドルックアップのリファレンス</span></a> を参照してください。</p>
</section>
<section id="s-lookups-that-span-relationships">
<span id="s-id6"></span><span id="lookups-that-span-relationships"></span><span id="id6"></span><h3>リレーションシップを横断するルックアップ<a class="headerlink" href="#lookups-that-span-relationships" title="Link to this heading">¶</a></h3>
<p>Django はルックアップの中でリレーションシップを「横断する」強力で直感的な方法を提供します。あなたのために、背後で SQL の <code class="docutils literal notranslate"><span class="pre">JOIN</span></code> を自動的に実行しています。リレーションシップを横断するには、使いたいフィールドにたどり着くまで、モデル間を横断する関連フィールドのフィールド名をダブルアンダースコアで繋ぎます。</p>
<p>次の例は、<code class="docutils literal notranslate"><span class="pre">name</span></code> に <code class="docutils literal notranslate"><span class="pre">'Beatles</span> <span class="pre">Blog'</span></code> を持つ <code class="docutils literal notranslate"><span class="pre">Blog</span></code> のすべての <code class="docutils literal notranslate"><span class="pre">Entry</span></code> オブジェクトを取得します。</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">blog__name</span><span class="o">=</span><span class="s2">&quot;Beatles Blog&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>この横断は好きなだけ深くすることができます。</p>
<p>逆方向にも動作します。 <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ForeignKey.related_query_name" title="django.db.models.ForeignKey.related_query_name"><code class="xref py py-attr docutils literal notranslate"><span class="pre">カスタマイズすることもできます</span></code></a> が、デフォルトでは、モデルの小文字の名前を使用して、ルックアップで「逆」リレーションシップを参照します。</p>
<p>次の例は、少なくとも1つの <code class="docutils literal notranslate"><span class="pre">headline</span></code> が <code class="docutils literal notranslate"><span class="pre">'Lennon'</span></code> を含む <code class="docutils literal notranslate"><span class="pre">Entry</span></code> を持つ、すべての <code class="docutils literal notranslate"><span class="pre">Blog</span></code> オブジェクトを取得します。</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">entry__headline__contains</span><span class="o">=</span><span class="s2">&quot;Lennon&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>複数のリレーションにまたがってフィルタリングをしていて、中間モデルのどれかが条件に合致しない場合、Django は空 (すべての値が <code class="docutils literal notranslate"><span class="pre">NULL</span></code>) だが有効なオブジェクトとして扱います。これは、エラーにはならないということです。たとえば以下のフィルタでは、</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">entry__authors__name</span><span class="o">=</span><span class="s2">&quot;Lennon&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>（リレーションシップを持つ <code class="docutils literal notranslate"><span class="pre">Author</span></code> モデルがあったとして、）もしあるエントリに関連付けられた <code class="docutils literal notranslate"><span class="pre">author</span></code> がいなかった場合、<code class="docutils literal notranslate"><span class="pre">author</span></code> が無いことを理由にエラーになるのではなく、単に <code class="docutils literal notranslate"><span class="pre">name</span></code> が無かったかのように扱われます。通常はこれが望ましい動作です。もし混乱するとしたら、<a class="reference internal" href="../../ref/models/querysets.html#std-fieldlookup-isnull"><code class="xref std std-lookup docutils literal notranslate"><span class="pre">isnull</span></code></a> を使う場合でしょう。つまり、</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">entry__authors__name__isnull</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>これは、<code class="docutils literal notranslate"><span class="pre">author</span></code> の <code class="docutils literal notranslate"><span class="pre">name</span></code> が空であるような <code class="docutils literal notranslate"><span class="pre">Blog</span></code> オブジェクトと、<code class="docutils literal notranslate"><span class="pre">entry</span></code> の <code class="docutils literal notranslate"><span class="pre">author</span></code> が空であるような <code class="docutils literal notranslate"><span class="pre">Blog</span></code> オブジェクトの両方を返します。後者のオブジェクトが欲しくない場合は、次のように書きます。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">entry__authors__isnull</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">entry__authors__name__isnull</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<section id="s-spanning-multi-valued-relationships">
<span id="s-id7"></span><span id="spanning-multi-valued-relationships"></span><span id="id7"></span><h4>複数の値を持つリレーションシップの横断<a class="headerlink" href="#spanning-multi-valued-relationships" title="Link to this heading">¶</a></h4>
<p><a class="reference internal" href="../../ref/models/fields.html#django.db.models.ManyToManyField" title="django.db.models.ManyToManyField"><code class="xref py py-class docutils literal notranslate"><span class="pre">ManyToManyField</span></code></a> や逆の <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ForeignKey" title="django.db.models.ForeignKey"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForeignKey</span></code></a> (例えば <code class="docutils literal notranslate"><span class="pre">Blog</span></code> から <code class="docutils literal notranslate"><span class="pre">Entry</span></code> へ) をまたぐとき、複数の属性でフィルタリングを行う場合、それぞれの属性がリレーション先の同一オブジェクト内で同時に一致する必要があるのかどうかが問題になります。「2008年に公開された、見出しに <em>“Lennon”</em> が含まれるエントリ」を持つブログを探したいかもしれませんし、「2008年に公開されたエントリを持ち、かつ2008年より新しいか古い、見出しに <em>“Lennon”</em> の含まれた別のエントリを持つブログ」を探したいかも知れません。</p>
<p>少なくとも1つの2008年のエントリーを含み、かつそのエントリーに「Lennon」というヘッドラインが含まれている（同じエントリーが両方の条件を満たしている）ブログをすべて取得する場合、このように書きます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">entry__headline__contains</span><span class="o">=</span><span class="s2">&quot;Lennon&quot;</span><span class="p">,</span> <span class="n">entry__pub_date__year</span><span class="o">=</span><span class="mi">2008</span><span class="p">)</span>
</pre></div>
</div>
<p>一方、ヘッドラインに「Lennon」が含まれる <em>何らか</em> のエントリーと、2008年の <em>何らかの</em> エントリーを持つ任意のブログを取得する寛容なクエリを実行する場合は、次のように書きます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">entry__headline__contains</span><span class="o">=</span><span class="s2">&quot;Lennon&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
    <span class="n">entry__pub_date__year</span><span class="o">=</span><span class="mi">2008</span>
<span class="p">)</span>
</pre></div>
</div>
<p><em>&quot;Lennon &quot;</em> を含むエントリーと2008年のエントリーの両方を持つブログが1つだけあり、2008年のエントリーには <em>&quot;Lennon &quot;</em> が含まれていなかったとします。最初のクエリはどのブログも返しませんが、2番目のクエリはその1つのブログを返します (これは、2番目のフィルタによって選択されたエントリーが1番目のフィルタのエントリーと違っていても構わないからです。私たちはそれぞれのフィルタ文で、 <code class="docutils literal notranslate"><span class="pre">Entry</span></code> アイテムではなく、 <code class="docutils literal notranslate"><span class="pre">Blog</span></code> アイテムをフィルタしているのです)。つまり、各条件がリレーション先の同じオブジェクトにマッチする必要がある場合、それぞれを 1 つの <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.filter" title="django.db.models.query.QuerySet.filter"><code class="xref py py-meth docutils literal notranslate"><span class="pre">filter()</span></code></a> 呼び出しに含める必要があります。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>2番目の (より寛容な) クエリは複数のフィルタを連鎖させるので、最初のモデルに複数の結合を実行し、重複を生成することがあります。</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">datetime</span><span class="w"> </span><span class="kn">import</span> <span class="n">date</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">beatles</span> <span class="o">=</span> <span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Beatles Blog&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pop</span> <span class="o">=</span> <span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Pop Music Blog&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">blog</span><span class="o">=</span><span class="n">beatles</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">headline</span><span class="o">=</span><span class="s2">&quot;New Lennon Biography&quot;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">pub_date</span><span class="o">=</span><span class="n">date</span><span class="p">(</span><span class="mi">2008</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
<span class="gp">... </span><span class="p">)</span>
<span class="go">&lt;Entry: New Lennon Biography&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">blog</span><span class="o">=</span><span class="n">beatles</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">headline</span><span class="o">=</span><span class="s2">&quot;New Lennon Biography in Paperback&quot;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">pub_date</span><span class="o">=</span><span class="n">date</span><span class="p">(</span><span class="mi">2009</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
<span class="gp">... </span><span class="p">)</span>
<span class="go">&lt;Entry: New Lennon Biography in Paperback&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">blog</span><span class="o">=</span><span class="n">pop</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">headline</span><span class="o">=</span><span class="s2">&quot;Best Albums of 2008&quot;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">pub_date</span><span class="o">=</span><span class="n">date</span><span class="p">(</span><span class="mi">2008</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">15</span><span class="p">),</span>
<span class="gp">... </span><span class="p">)</span>
<span class="go">&lt;Entry: Best Albums of 2008&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">blog</span><span class="o">=</span><span class="n">pop</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">headline</span><span class="o">=</span><span class="s2">&quot;Lennon Would Have Loved Hip Hop&quot;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">pub_date</span><span class="o">=</span><span class="n">date</span><span class="p">(</span><span class="mi">2020</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
<span class="gp">... </span><span class="p">)</span>
<span class="go">&lt;Entry: Lennon Would Have Loved Hip Hop&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">entry__headline__contains</span><span class="o">=</span><span class="s2">&quot;Lennon&quot;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">entry__pub_date__year</span><span class="o">=</span><span class="mi">2008</span><span class="p">,</span>
<span class="gp">... </span><span class="p">)</span>
<span class="go">&lt;QuerySet [&lt;Blog: Beatles Blog&gt;]&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">entry__headline__contains</span><span class="o">=</span><span class="s2">&quot;Lennon&quot;</span><span class="p">,</span>
<span class="gp">... </span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">entry__pub_date__year</span><span class="o">=</span><span class="mi">2008</span><span class="p">,</span>
<span class="gp">... </span><span class="p">)</span>
<span class="go">&lt;QuerySet [&lt;Blog: Beatles Blog&gt;, &lt;Blog: Beatles Blog&gt;, &lt;Blog: Pop Music Blog]&gt;</span>
</pre></div>
</div>
</div>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>上記のような複数の値のリレーションシップをまたぐクエリに対する <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.filter" title="django.db.models.query.QuerySet.filter"><code class="xref py py-meth docutils literal notranslate"><span class="pre">filter()</span></code></a> の動作は、 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.exclude" title="django.db.models.query.QuerySet.exclude"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exclude()</span></code></a> と同等には実装されていません。その代わり、1つの <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.exclude" title="django.db.models.query.QuerySet.exclude"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exclude()</span></code></a> 呼び出しにおける条件は必ずしも同じアイテムを参照するとは限りません。</p>
<p>例えば、以下のクエリは、見出しに <em>&quot;Lennon&quot;</em> を含むエントリー <em>と</em> 、2008年に公開されたエントリーの <em>両方</em> を含むブログを除外します:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">exclude</span><span class="p">(</span>
    <span class="n">entry__headline__contains</span><span class="o">=</span><span class="s2">&quot;Lennon&quot;</span><span class="p">,</span>
    <span class="n">entry__pub_date__year</span><span class="o">=</span><span class="mi">2008</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>
</div>
<p>しかし、 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.filter" title="django.db.models.query.QuerySet.filter"><code class="xref py py-meth docutils literal notranslate"><span class="pre">filter()</span></code></a> を使ったときの動作とは異なり、このクエリは両方の条件を満たすエントリでブログを絞り込むわけではありません。つまり、「2008年に <em>&quot;Lennon&quot;</em> によって公開されたエントリー」を含まないブログすべてを取得するには、このように2つのクエリを書く必要があります:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">exclude</span><span class="p">(</span>
    <span class="n">entry__in</span><span class="o">=</span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
        <span class="n">headline__contains</span><span class="o">=</span><span class="s2">&quot;Lennon&quot;</span><span class="p">,</span>
        <span class="n">pub_date__year</span><span class="o">=</span><span class="mi">2008</span><span class="p">,</span>
    <span class="p">),</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
</section>
</section>
<section id="s-filters-can-reference-fields-on-the-model">
<span id="s-using-f-expressions-in-filters"></span><span id="filters-can-reference-fields-on-the-model"></span><span id="using-f-expressions-in-filters"></span><h3>フィルタはモデルのフィールドを参照できる<a class="headerlink" href="#filters-can-reference-fields-on-the-model" title="Link to this heading">¶</a></h3>
<p>今まで見てきた例では、モデルのフィールドの値を定数と比較するフィルタを作ってきました。しかし、もしモデルのフィールドの値を、同じモデルの他のフィールドと比較したい時にはどうすればいいのでしょう？</p>
<p>そのような比較を行うために、Django は <a class="reference internal" href="../../ref/models/expressions.html#django.db.models.F" title="django.db.models.F"><code class="xref py py-class docutils literal notranslate"><span class="pre">F</span> <span class="pre">式</span></code></a> を用意しています。 <code class="docutils literal notranslate"><span class="pre">F()</span></code> のインスタンスは、クエリの中でモデルのフィールドへの参照として振る舞います。したがって、この参照をクエリの中で使うことで、同じモデルのインスタンスの異なる2つのフィールドの値を比較できます。</p>
<p>たとえば、pingback の数よりコメントの数のほうが多いすべてのブログエントリーのリストを検索するには、pingback の数を参照する <code class="docutils literal notranslate"><span class="pre">F()</span></code> オブジェクトを作り、その <code class="docutils literal notranslate"><span class="pre">F()</span></code> オブジェクトをクエリの中で次のように使います。</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">django.db.models</span><span class="w"> </span><span class="kn">import</span> <span class="n">F</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">number_of_comments__gt</span><span class="o">=</span><span class="n">F</span><span class="p">(</span><span class="s2">&quot;number_of_pingbacks&quot;</span><span class="p">))</span>
</pre></div>
</div>
<p>Django は <code class="docutils literal notranslate"><span class="pre">F()</span></code> オブジェクトを使った足し算、引き算、掛け算、割り算、モジュロ、累乗算術を、定数や他の <code class="docutils literal notranslate"><span class="pre">F()</span></code> オブジェクトとの両方でサポートしています。コメント数がピンバック数の <em>2倍</em> を超えるブログエントリをすべて見つけるには、このようにクエリを変更します:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">number_of_comments__gt</span><span class="o">=</span><span class="n">F</span><span class="p">(</span><span class="s2">&quot;number_of_pingbacks&quot;</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>エントリーのレーティングがピンバック数とコメント数の合計より少ないエントリーをすべて見つけるには、次のようなクエリを発行します:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">rating__lt</span><span class="o">=</span><span class="n">F</span><span class="p">(</span><span class="s2">&quot;number_of_comments&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">F</span><span class="p">(</span><span class="s2">&quot;number_of_pingbacks&quot;</span><span class="p">))</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">F()</span></code> オブジェクトのリレーションシップに 2重アンダースコア表記を使うこともできます。 <code class="docutils literal notranslate"><span class="pre">F()</span></code> オブジェクトに2重アンダースコアを付けると、リレーション先オブジェクトにアクセスするために必要な結合を行うことができます。例えば、作者名がブログ名と同じすべてのエントリを取得するには、次のようなクエリを発行します:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">authors__name</span><span class="o">=</span><span class="n">F</span><span class="p">(</span><span class="s2">&quot;blog__name&quot;</span><span class="p">))</span>
</pre></div>
</div>
<p>日付と日付/時刻フィールドには、 <a class="reference external" href="https://docs.python.org/3/library/datetime.html#datetime.timedelta" title="(in Python v3.13)"><code class="xref py py-class docutils literal notranslate"><span class="pre">timedelta</span></code></a> オブジェクトを足し引きできます。次のようにすると、公開から3日以上経ってから更新されたすべてのエントリーが返されます:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">datetime</span><span class="w"> </span><span class="kn">import</span> <span class="n">timedelta</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">mod_date__gt</span><span class="o">=</span><span class="n">F</span><span class="p">(</span><span class="s2">&quot;pub_date&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">timedelta</span><span class="p">(</span><span class="n">days</span><span class="o">=</span><span class="mi">3</span><span class="p">))</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">F()</span></code> オブジェクトは <code class="docutils literal notranslate"><span class="pre">.bitand()</span></code>, <code class="docutils literal notranslate"><span class="pre">.bitor()</span></code>, <code class="docutils literal notranslate"><span class="pre">.bitxor()</span></code>, <code class="docutils literal notranslate"><span class="pre">.bitrightshift()</span></code>, <code class="docutils literal notranslate"><span class="pre">.bitleftshift()</span></code> によるビット演算をサポートしています。例えばこのようにします:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">F</span><span class="p">(</span><span class="s2">&quot;somefield&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">bitand</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition-oracle admonition">
<p class="admonition-title">Oracle</p>
<p>オラクルはXORビット演算をサポートしていません。</p>
</div>
</section>
<section id="s-expressions-can-reference-transforms">
<span id="s-using-transforms-in-expressions"></span><span id="expressions-can-reference-transforms"></span><span id="using-transforms-in-expressions"></span><h3>式はトランスフォーム（Transform）を参照できる<a class="headerlink" href="#expressions-can-reference-transforms" title="Link to this heading">¶</a></h3>
<p>Django は式でトランスフォーム（変換）を使うことをサポートしています。</p>
<p>たとえば、次のコードは最終更新年と同じ年に発行されたすべてのEntryオブジェクトを検索します:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">django.db.models</span><span class="w"> </span><span class="kn">import</span> <span class="n">F</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">pub_date__year</span><span class="o">=</span><span class="n">F</span><span class="p">(</span><span class="s2">&quot;mod_date__year&quot;</span><span class="p">))</span>
</pre></div>
</div>
<p>最も古い出版年を調べるには、次のクエリを実行します:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">django.db.models</span><span class="w"> </span><span class="kn">import</span> <span class="n">Min</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">aggregate</span><span class="p">(</span><span class="n">first_published_year</span><span class="o">=</span><span class="n">Min</span><span class="p">(</span><span class="s2">&quot;pub_date__year&quot;</span><span class="p">))</span>
</pre></div>
</div>
<p>たとえばこの例では、各年の最高評価エントリーの値と、全エントリーに対するコメントの総数を求めています:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">django.db.models</span><span class="w"> </span><span class="kn">import</span> <span class="n">OuterRef</span><span class="p">,</span> <span class="n">Subquery</span><span class="p">,</span> <span class="n">Sum</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">values</span><span class="p">(</span><span class="s2">&quot;pub_date__year&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">top_rating</span><span class="o">=</span><span class="n">Subquery</span><span class="p">(</span>
<span class="gp">... </span>        <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
<span class="gp">... </span>            <span class="n">pub_date__year</span><span class="o">=</span><span class="n">OuterRef</span><span class="p">(</span><span class="s2">&quot;pub_date__year&quot;</span><span class="p">),</span>
<span class="gp">... </span>        <span class="p">)</span>
<span class="gp">... </span>        <span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="s2">&quot;-rating&quot;</span><span class="p">)</span>
<span class="gp">... </span>        <span class="o">.</span><span class="n">values</span><span class="p">(</span><span class="s2">&quot;rating&quot;</span><span class="p">)[:</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">... </span>    <span class="p">),</span>
<span class="gp">... </span>    <span class="n">total_comments</span><span class="o">=</span><span class="n">Sum</span><span class="p">(</span><span class="s2">&quot;number_of_comments&quot;</span><span class="p">),</span>
<span class="gp">... </span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="s-the-pk-lookup-shortcut">
<span id="the-pk-lookup-shortcut"></span><h3><code class="docutils literal notranslate"><span class="pre">pk</span></code> ルックアップショートカット<a class="headerlink" href="#the-pk-lookup-shortcut" title="Link to this heading">¶</a></h3>
<p>利便性のために、Django は <code class="docutils literal notranslate"><span class="pre">pk</span></code> ルックアップショートカットを用意しています。pk とは &quot;primary key&quot; を表します。</p>
<p>例の <code class="docutils literal notranslate"><span class="pre">Blog</span></code> モデルでは、プライマリキーは <code class="docutils literal notranslate"><span class="pre">id</span></code> フィールドなので、次の3つの文は等価です:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">id__exact</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>  <span class="c1"># Explicit form</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>  <span class="c1"># __exact is implied</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">pk</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>  <span class="c1"># pk implies id__exact</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">pk</span></code> は、 <code class="docutils literal notranslate"><span class="pre">__exact</span></code> クエリ以外でも使えます。好きなクエリ語句を <code class="docutils literal notranslate"><span class="pre">pk</span></code> と組み合わせて、モデルのプライマリキーに対するクエリを実行できます:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="go"># Get blogs entries with id 1, 4 and 7</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">pk__in</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">])</span>

<span class="go"># Get all blog entries with id &gt; 14</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">pk__gt</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">pk</span></code> ルックアップは結合をまたいでも動作します。たとえば、次の3つの文は等価です:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">blog__id__exact</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>  <span class="c1"># Explicit form</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">blog__id</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>  <span class="c1"># __exact is implied</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">blog__pk</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>  <span class="c1"># __pk implies __id__exact</span>
</pre></div>
</div>
</section>
<section id="s-escaping-percent-signs-and-underscores-in-like-statements">
<span id="escaping-percent-signs-and-underscores-in-like-statements"></span><h3><code class="docutils literal notranslate"><span class="pre">LIKE</span></code> 文の中ではパーセント記号とアンダースコアがエスケープされる<a class="headerlink" href="#escaping-percent-signs-and-underscores-in-like-statements" title="Link to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">LIKE</span></code> SQL文 (<code class="docutils literal notranslate"><span class="pre">iexact</span></code>, <code class="docutils literal notranslate"><span class="pre">contains</span></code>, <code class="docutils literal notranslate"><span class="pre">icontains</span></code>, <code class="docutils literal notranslate"><span class="pre">startswith</span></code>, <code class="docutils literal notranslate"><span class="pre">istartswith</span></code>, <code class="docutils literal notranslate"><span class="pre">endswith</span></code>, <code class="docutils literal notranslate"><span class="pre">iendswith</span></code>) に相当するフィールドルックアップでは、 <code class="docutils literal notranslate"><span class="pre">LIKE</span></code> 文で使用される2つの特殊文字 (パーセント記号とアンダースコア) が自動的にエスケープされます。 (<code class="docutils literal notranslate"><span class="pre">LIKE</span></code> 文では、パーセント記号は複数文字のワイルドカードを意味し、アンダースコアは1文字のワイルドカードを意味します)。</p>
<p>つまり、直感的に動作するので、抽象化が漏れることはありません。たとえば、パーセント記号を含むすべてのエントリを取得するには、パーセント記号を他の文字と同じように使用します:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">headline__contains</span><span class="o">=</span><span class="s2">&quot;%&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Django は以下のように、あなたの代わりにクォート処理をしてくれます:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">headline</span><span class="w"> </span><span class="k">LIKE</span><span class="w"> </span><span class="s1">&#39;%\%%&#39;</span><span class="p">;</span>
</pre></div>
</div>
<p>アンダースコアも同様です。パーセント記号もアンダースコアも透過的に処理されます。</p>
</section>
<section id="s-caching-and-querysets">
<span id="s-id8"></span><span id="caching-and-querysets"></span><span id="id8"></span><h3>キャッシュと <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code><a class="headerlink" href="#caching-and-querysets" title="Link to this heading">¶</a></h3>
<p>それぞれの <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> には、データベースへのアクセスを最小にするために内部にキャッシュがあります。キャッシュのしくみを理解すれば、最も効率の良いコードが書けるようになります。</p>
<p>新しく作成された <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> では、キャッシュは空です。初めて <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> が評価されたとき、つまりデータベースへのクエリが発生したとき、Django はクエリの結果を <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> のキャッシュに保存し、明示的に要求された結果 (例えば、 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> が繰り返し処理されている場合は次の要素) を返します。それ以降の <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> の評価はキャッシュされた結果を再利用します。</p>
<p>このキャッシュの動作は覚えておきましょう。 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> を正しく使わないと、痛い目を見るかもしれません。たとえば、次のようにしてしまうと <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> が 2 つ作成され、評価され、そして破棄されます:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">([</span><span class="n">e</span><span class="o">.</span><span class="n">headline</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">()])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">([</span><span class="n">e</span><span class="o">.</span><span class="n">pub_date</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">()])</span>
</pre></div>
</div>
<p>つまり、同じデータベースクエリが2回実行されることになり、事実上データベースの負荷が2倍になります。また、2つのリクエストの間の一瞬の間に <code class="docutils literal notranslate"><span class="pre">Entry</span></code> が追加されたり削除されたりして、2つのリストに同じデータベースレコードが含まれない可能性もあります。</p>
<p>この問題を回避するには、 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> を保存して再利用します:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">queryset</span> <span class="o">=</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">([</span><span class="n">p</span><span class="o">.</span><span class="n">headline</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">queryset</span><span class="p">])</span>  <span class="c1"># Evaluate the query set.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">([</span><span class="n">p</span><span class="o">.</span><span class="n">pub_date</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">queryset</span><span class="p">])</span>  <span class="c1"># Reuse the cache from the evaluation.</span>
</pre></div>
</div>
<section id="s-when-querysets-are-not-cached">
<span id="when-querysets-are-not-cached"></span><h4><code class="docutils literal notranslate"><span class="pre">QuerySet</span></code> がキャッシュされないケース<a class="headerlink" href="#when-querysets-are-not-cached" title="Link to this heading">¶</a></h4>
<p>クエリセットは常に結果をキャッシュするわけではありません。 クエリセットの <em>一部</em> だけを評価する場合、キャッシュがチェックされますが、もしキャッシュに値が入力されていなければ、後続のクエリで返される項目はキャッシュされません。具体的には、配列のスライスやインデックスを使用して <a class="reference internal" href="#limiting-querysets"><span class="std std-ref">クエリセットを制限</span></a> しても、キャッシュは生成されません。</p>
<p>たとえば、クエリセットオブジェクトで特定のインデックスを繰り返し取得すると、その度にデータベースにクエリが送られます:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">queryset</span> <span class="o">=</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">queryset</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span>  <span class="c1"># Queries the database</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">queryset</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span>  <span class="c1"># Queries the database again</span>
</pre></div>
</div>
<p>しかし、クエリセット全体がすでに評価されている場合は、代わりにキャッシュが調べられます:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">queryset</span> <span class="o">=</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">entry</span> <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">queryset</span><span class="p">]</span>  <span class="c1"># Queries the database</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">queryset</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span>  <span class="c1"># Uses cache</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">queryset</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span>  <span class="c1"># Uses cache</span>
</pre></div>
</div>
<p>以下に、クエリセット全体が評価され、その結果キャッシュに入力される他の操作の例をいくつか示します:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">entry</span> <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">queryset</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">bool</span><span class="p">(</span><span class="n">queryset</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">entry</span> <span class="ow">in</span> <span class="n">queryset</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">queryset</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>単にクエリセットを表示するだけではキャッシュにデータを入れることはできません。これは <code class="docutils literal notranslate"><span class="pre">__repr__()</span></code> の呼び出しがクエリセット全体のスライスを返すだけだからです。</p>
</div>
</section>
</section>
</section>
<section id="s-asynchronous-queries">
<span id="s-async-queries"></span><span id="asynchronous-queries"></span><span id="async-queries"></span><h2>非同期クエリ<a class="headerlink" href="#asynchronous-queries" title="Link to this heading">¶</a></h2>
<p>非同期ビューやコードを書いている場合、上記で説明した方法でORMをクエリに使用することはできません。非同期コードから <em>ブロッキングな</em> 同期コードを呼び出すことはできず、イベントループをブロックしてしまいます（それか、大抵はDjangoがそのことを検出し、 <code class="docutils literal notranslate"><span class="pre">SynchronousOnlyOperation</span></code> を発生させて防ぐでしょう）。</p>
<p>幸い、Django の非同期クエリ API を使えば、多くのクエリを実行できます。 <code class="docutils literal notranslate"><span class="pre">get()</span></code> や  <code class="docutils literal notranslate"><span class="pre">delete()</span></code> のようなブロッキングされる可能性のあるメソッドにはすべて非同期型 (<code class="docutils literal notranslate"><span class="pre">aget()</span></code> や <code class="docutils literal notranslate"><span class="pre">adelete()</span></code>) があり、結果を反復処理するときには、代わりに非同期反復処理 (<code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code>) が使えます。</p>
<section id="s-query-iteration">
<span id="query-iteration"></span><h3>クエリの繰り返し（イテレーション）<a class="headerlink" href="#query-iteration" title="Link to this heading">¶</a></h3>
<p>クエリを繰り返し処理するデフォルトの方法 <code class="docutils literal notranslate"><span class="pre">for</span></code> では、 Django が繰り返し処理時に結果をロードするため、裏でデータベースのクエリがブロッキングされます。これを修正するには、 <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code> に変更します:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">Authors</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">name__startswith</span><span class="o">=</span><span class="s2">&quot;A&quot;</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>例えば、 <code class="docutils literal notranslate"><span class="pre">list()</span></code> をクエリセットにラップして強制的にクエリセットを評価するようなことはできません (必要であれば、内包表記の中で <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code> を使うことができます)。</p>
<p><code class="docutils literal notranslate"><span class="pre">filter()</span></code> や <code class="docutils literal notranslate"><span class="pre">exclude()</span></code> のような <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code> メソッドは実際にクエリを実行するわけではなく、クエリセットがイテレートされたときに実行されるように指定するものなので、非同期コードで自由に使用できます。どのメソッドがこのように使い続けられるか、またどのメソッドに非同期バージョンがあるかについては、次のセクションを読んでください。</p>
</section>
<section id="s-queryset-and-manager-methods">
<span id="queryset-and-manager-methods"></span><h3><code class="docutils literal notranslate"><span class="pre">QuerySet</span></code> とマネージャメソッド<a class="headerlink" href="#queryset-and-manager-methods" title="Link to this heading">¶</a></h3>
<p>マネージャやクエリセットに関するメソッドの中には、 <code class="docutils literal notranslate"><span class="pre">get()</span></code> や <code class="docutils literal notranslate"><span class="pre">first()</span></code> のように、クエリセットを強制的に実行し、ブロッキングするものがあります。 <code class="docutils literal notranslate"><span class="pre">filter()</span></code> や <code class="docutils literal notranslate"><span class="pre">exclude()</span></code> のように、実行を強制しないメソッドもあります。しかし、どうやって見分けるのでしょうか？</p>
<p>メソッドに <code class="docutils literal notranslate"><span class="pre">a</span></code> で始まるバージョンがあるかどうかを探ることもできます（例えば、<code class="docutils literal notranslate"><span class="pre">aget()</span></code> はありますが、 <code class="docutils literal notranslate"><span class="pre">afilter()</span></code> はありません）。しかし、もっとロジカルな方法があります。それは、 <a class="reference internal" href="../../ref/models/querysets.html"><span class="doc">QuerySet リファレンス</span></a> でそのメソッドがどのような種類のものかを調べることです。</p>
<p>そこでは、QuerySet に関するメソッドを2つのセクションに分けています:</p>
<ul class="simple">
<li><p><em>新しいクエリセットを返すメソッド</em>: これらはノンブロッキングのもので、非同期バージョンはありません。これらはどんな状況でも自由に使うことができますが、使う前に <code class="docutils literal notranslate"><span class="pre">defer()</span></code> と <code class="docutils literal notranslate"><span class="pre">only()</span></code> に関する注意事項を読んでください。</p></li>
<li><p><em>クエリセットを返さないメソッド</em>: これらはブロッキングメソッドで、非同期バージョンもあります。それぞれの非同期名はドキュメントに書かれていますが、私たちの標準的なパターンは接頭辞に <code class="docutils literal notranslate"><span class="pre">a</span></code> をつけることです。</p></li>
</ul>
<p>この区別を使えば、非同期バージョンを使う必要があるときとないときを判断できます。たとえば、これは有効な非同期クエリです:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">user</span> <span class="o">=</span> <span class="k">await</span> <span class="n">User</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">username</span><span class="o">=</span><span class="n">my_input</span><span class="p">)</span><span class="o">.</span><span class="n">afirst</span><span class="p">()</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">filter()</span></code> はクエリセットを返すため、非同期環境内で連結して使用しても問題ありません。一方で <code class="docutils literal notranslate"><span class="pre">first()</span></code> は評価してモデルインスタンスを返すため、 <code class="docutils literal notranslate"><span class="pre">afirst()</span></code> に変更し、非同期に適した方法で呼び出すために、式全体の前に <code class="docutils literal notranslate"><span class="pre">await</span></code> を使用します。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>もし <code class="docutils literal notranslate"><span class="pre">await</span></code> の部分を入れ忘れると、 <em>&quot;coroutine object has no attribute x &quot;</em> や <em>&quot;&lt;coroutine ...&gt;&quot;</em> のようなエラーがモデルインスタンスの代わりに表示されるかもしれません。このようなエラーが表示される場合は、コルーチンを実際の値に変換するための <code class="docutils literal notranslate"><span class="pre">await</span></code> 部分が不足しています。</p>
</div>
</section>
<section id="s-transactions">
<span id="transactions"></span><h3>トランザクション<a class="headerlink" href="#transactions" title="Link to this heading">¶</a></h3>
<p>トランザクションは現在、非同期クエリや更新ではサポートされていません。これを使用しようとすると <code class="docutils literal notranslate"><span class="pre">SynchronousOnlyOperation</span></code> が発生します。</p>
<p>トランザクションを使用したい場合は、ORMコードを別の同期関数の中に記述し、 <code class="docutils literal notranslate"><span class="pre">sync_to_async</span></code> を使用して呼び出すことをおすすめします。詳しくは <a class="reference internal" href="../async.html"><span class="doc">非同期サポート</span></a> を参照してください。</p>
</section>
</section>
<section id="s-querying-jsonfield">
<span id="s-id9"></span><span id="querying-jsonfield"></span><span id="id9"></span><h2><code class="docutils literal notranslate"><span class="pre">JSONField</span></code> へのクエリ<a class="headerlink" href="#querying-jsonfield" title="Link to this heading">¶</a></h2>
<p><a class="reference internal" href="../../ref/models/fields.html#django.db.models.JSONField" title="django.db.models.JSONField"><code class="xref py py-class docutils literal notranslate"><span class="pre">JSONField</span></code></a> では、ルックアップの実装は主にキーのトランスフォーム（変換）の存在によって異なります。デモンストレーションのために、次のモデル例を使います:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">django.db</span><span class="w"> </span><span class="kn">import</span> <span class="n">models</span>


<span class="k">class</span><span class="w"> </span><span class="nc">Dog</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">200</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">JSONField</span><span class="p">(</span><span class="n">null</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
</pre></div>
</div>
<section id="s-storing-and-querying-for-none">
<span id="storing-and-querying-for-none"></span><h3><code class="docutils literal notranslate"><span class="pre">None</span></code> の保存とクエリ<a class="headerlink" href="#storing-and-querying-for-none" title="Link to this heading">¶</a></h3>
<p>他のフィールドと同様に、フィールドの値として <code class="docutils literal notranslate"><span class="pre">None</span></code> を格納すると、SQL の <code class="docutils literal notranslate"><span class="pre">NULL</span></code> として格納されます。推奨はしませんが、 <a class="reference internal" href="../../ref/models/expressions.html#django.db.models.Value" title="django.db.models.Value"><code class="xref py py-class docutils literal notranslate"><span class="pre">Value(None,</span> <span class="pre">JSONField())</span></code></a> を使用することで、 SQL の <code class="docutils literal notranslate"><span class="pre">NULL</span></code> の代わりに JSON のスカラー値 <code class="docutils literal notranslate"><span class="pre">null</span></code> を格納できます。</p>
<p>どちらの値が格納されていても、データベースから取得したとき、JSON のスカラー <code class="docutils literal notranslate"><span class="pre">null</span></code> の Python 表現は SQL の <code class="docutils literal notranslate"><span class="pre">NULL</span></code> と同じ、つまり <code class="docutils literal notranslate"><span class="pre">None</span></code> になります。そのため、両者を区別するのは難しいでしょう。</p>
<p>これはフィールドのトップレベルの値としての <code class="docutils literal notranslate"><span class="pre">None</span></code> にだけ適用されます。もし <code class="docutils literal notranslate"><span class="pre">None</span></code> が <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.13)"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a> や <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.13)"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> の中にある場合、常に JSON の <code class="docutils literal notranslate"><span class="pre">null</span></code> として解釈されます。</p>
<p>クエリの際、 <code class="docutils literal notranslate"><span class="pre">None</span></code> 値は常に JSON <code class="docutils literal notranslate"><span class="pre">null</span></code> として解釈されます。SQL の <code class="docutils literal notranslate"><span class="pre">NULL</span></code> をクエリするには <a class="reference internal" href="../../ref/models/querysets.html#std-fieldlookup-isnull"><code class="xref std std-lookup docutils literal notranslate"><span class="pre">isnull</span></code></a> を使用します:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Dog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Max&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>  <span class="c1"># SQL NULL.</span>
<span class="go">&lt;Dog: Max&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Dog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Archie&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">Value</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">JSONField</span><span class="p">()))</span>  <span class="c1"># JSON null.</span>
<span class="go">&lt;Dog: Archie&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Dog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="go">&lt;QuerySet [&lt;Dog: Archie&gt;]&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Dog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">Value</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">JSONField</span><span class="p">()))</span>
<span class="go">&lt;QuerySet [&lt;Dog: Archie&gt;]&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Dog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">data__isnull</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">&lt;QuerySet [&lt;Dog: Max&gt;]&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Dog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">data__isnull</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">&lt;QuerySet [&lt;Dog: Archie&gt;]&gt;</span>
</pre></div>
</div>
<p>SQL の <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 値を使いたいのでなければ、 <code class="docutils literal notranslate"><span class="pre">null=False</span></code> を設定し、 <code class="docutils literal notranslate"><span class="pre">default=dict</span></code> のように空の値に対して適切なデフォルト値を指定することを検討してください。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>JSON スカラー値の <code class="docutils literal notranslate"><span class="pre">null</span></code> を格納することは <a class="reference internal" href="../../ref/models/fields.html#django.db.models.Field.null" title="django.db.models.Field.null"><code class="xref py py-attr docutils literal notranslate"><span class="pre">null=False</span></code></a> に反しません。</p>
</div>
</section>
<section id="s-key-index-and-path-transforms">
<span id="s-std-fieldlookup-jsonfield.key"></span><span id="key-index-and-path-transforms"></span><span id="std-fieldlookup-jsonfield.key"></span><h3>キー、インデックス、パス（経路）のトランスフォーム（変換）<a class="headerlink" href="#key-index-and-path-transforms" title="Link to this heading">¶</a></h3>
<p>指定された辞書のキーに基づいてクエリを実行するには、そのキーをルックアップ名として使います:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Dog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Rufus&quot;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">data</span><span class="o">=</span><span class="p">{</span>
<span class="gp">... </span>        <span class="s2">&quot;breed&quot;</span><span class="p">:</span> <span class="s2">&quot;labrador&quot;</span><span class="p">,</span>
<span class="gp">... </span>        <span class="s2">&quot;owner&quot;</span><span class="p">:</span> <span class="p">{</span>
<span class="gp">... </span>            <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;Bob&quot;</span><span class="p">,</span>
<span class="gp">... </span>            <span class="s2">&quot;other_pets&quot;</span><span class="p">:</span> <span class="p">[</span>
<span class="gp">... </span>                <span class="p">{</span>
<span class="gp">... </span>                    <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;Fishy&quot;</span><span class="p">,</span>
<span class="gp">... </span>                <span class="p">}</span>
<span class="gp">... </span>            <span class="p">],</span>
<span class="gp">... </span>        <span class="p">},</span>
<span class="gp">... </span>    <span class="p">},</span>
<span class="gp">... </span><span class="p">)</span>
<span class="go">&lt;Dog: Rufus&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Dog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Meg&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;breed&quot;</span><span class="p">:</span> <span class="s2">&quot;collie&quot;</span><span class="p">,</span> <span class="s2">&quot;owner&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">})</span>
<span class="go">&lt;Dog: Meg&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Dog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">data__breed</span><span class="o">=</span><span class="s2">&quot;collie&quot;</span><span class="p">)</span>
<span class="go">&lt;QuerySet [&lt;Dog: Meg&gt;]&gt;</span>
</pre></div>
</div>
<p>複数のキーを連結して1本のルックアップパス（経路）を形成することもできます。</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Dog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">data__owner__name</span><span class="o">=</span><span class="s2">&quot;Bob&quot;</span><span class="p">)</span>
<span class="go">&lt;QuerySet [&lt;Dog: Rufus&gt;]&gt;</span>
</pre></div>
</div>
<p>キーが整数の場合は、配列のインデックスのトランスフォームとして解釈されます:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Dog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">data__owner__other_pets__0__name</span><span class="o">=</span><span class="s2">&quot;Fishy&quot;</span><span class="p">)</span>
<span class="go">&lt;QuerySet [&lt;Dog: Rufus&gt;]&gt;</span>
</pre></div>
</div>
<p>クエリしたいキーが他のルックアップ名と衝突する場合は、代わりに <a class="reference internal" href="#std-fieldlookup-jsonfield.contains"><code class="xref std std-lookup docutils literal notranslate"><span class="pre">contains</span></code></a> ルックアップを使用してください。</p>
<p>欠損したキーをクエリで探したいときは、 <code class="docutils literal notranslate"><span class="pre">isnull</span></code> ルックアップを使用します:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Dog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Shep&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;breed&quot;</span><span class="p">:</span> <span class="s2">&quot;collie&quot;</span><span class="p">})</span>
<span class="go">&lt;Dog: Shep&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Dog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">data__owner__isnull</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">&lt;QuerySet [&lt;Dog: Shep&gt;]&gt;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>上記のルックアップ例は暗黙的に <a class="reference internal" href="../../ref/models/querysets.html#std-fieldlookup-exact"><code class="xref std std-lookup docutils literal notranslate"><span class="pre">exact</span></code></a> ルックアップを使用しています。キー、インデックス、およびパス（経路）のトランスフォーム（変換）は、 <a class="reference internal" href="../../ref/models/querysets.html#std-fieldlookup-icontains"><code class="xref std std-lookup docutils literal notranslate"><span class="pre">icontains</span></code></a>, <a class="reference internal" href="../../ref/models/querysets.html#std-fieldlookup-endswith"><code class="xref std std-lookup docutils literal notranslate"><span class="pre">endswith</span></code></a>, <a class="reference internal" href="../../ref/models/querysets.html#std-fieldlookup-iendswith"><code class="xref std std-lookup docutils literal notranslate"><span class="pre">iendswith</span></code></a>, <a class="reference internal" href="../../ref/models/querysets.html#std-fieldlookup-iexact"><code class="xref std std-lookup docutils literal notranslate"><span class="pre">iexact</span></code></a>, <a class="reference internal" href="../../ref/models/querysets.html#std-fieldlookup-regex"><code class="xref std std-lookup docutils literal notranslate"><span class="pre">regex</span></code></a>, <a class="reference internal" href="../../ref/models/querysets.html#std-fieldlookup-iregex"><code class="xref std std-lookup docutils literal notranslate"><span class="pre">iregex</span></code></a>, <a class="reference internal" href="../../ref/models/querysets.html#std-fieldlookup-startswith"><code class="xref std std-lookup docutils literal notranslate"><span class="pre">startswith</span></code></a>, <a class="reference internal" href="../../ref/models/querysets.html#std-fieldlookup-istartswith"><code class="xref std std-lookup docutils literal notranslate"><span class="pre">istartswith</span></code></a>, <a class="reference internal" href="../../ref/models/querysets.html#std-fieldlookup-lt"><code class="xref std std-lookup docutils literal notranslate"><span class="pre">lt</span></code></a>, <a class="reference internal" href="../../ref/models/querysets.html#std-fieldlookup-lte"><code class="xref std std-lookup docutils literal notranslate"><span class="pre">lte</span></code></a>, <a class="reference internal" href="../../ref/models/querysets.html#std-fieldlookup-gt"><code class="xref std std-lookup docutils literal notranslate"><span class="pre">gt</span></code></a>, および <a class="reference internal" href="../../ref/models/querysets.html#std-fieldlookup-gte"><code class="xref std std-lookup docutils literal notranslate"><span class="pre">gte</span></code></a> に加え、 <a class="reference internal" href="#containment-and-key-lookups"><span class="std std-ref">contain の概念とキーのルックアップ</span></a> とも連結できます。</p>
</div>
<section id="s-module-django.db.models.fields.json">
<span id="s-kt-expressions"></span><span id="module-django.db.models.fields.json"></span><span id="kt-expressions"></span><h4><code class="docutils literal notranslate"><span class="pre">KT()</span></code> 式<a class="headerlink" href="#module-django.db.models.fields.json" title="Link to this heading">¶</a></h4>
<dl class="py class">
<dt class="sig sig-object py" id="django.db.models.fields.json.KT">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">KT</span></span>(<em class="sig-param"><span class="n"><span class="pre">lookup</span></span></em>)<a class="headerlink" href="#django.db.models.fields.json.KT" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="../../ref/models/fields.html#django.db.models.JSONField" title="django.db.models.JSONField"><code class="xref py py-class docutils literal notranslate"><span class="pre">JSONField</span></code></a> のキー、インデックス、パス（経路）のトランスフォーム（変換）のテキスト値を表します。 <code class="docutils literal notranslate"><span class="pre">lookup</span></code> で2重アンダースコア表記を使用すると、辞書のキーやインデックス変換を連結できます。</p>
<p>例えば次のようにします:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">django.db.models.fields.json</span><span class="w"> </span><span class="kn">import</span> <span class="n">KT</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Dog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Shep&quot;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">data</span><span class="o">=</span><span class="p">{</span>
<span class="gp">... </span>        <span class="s2">&quot;owner&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;Bob&quot;</span><span class="p">},</span>
<span class="gp">... </span>        <span class="s2">&quot;breed&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;collie&quot;</span><span class="p">,</span> <span class="s2">&quot;lhasa apso&quot;</span><span class="p">],</span>
<span class="gp">... </span>    <span class="p">},</span>
<span class="gp">... </span><span class="p">)</span>
<span class="go">&lt;Dog: Shep&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Dogs</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">first_breed</span><span class="o">=</span><span class="n">KT</span><span class="p">(</span><span class="s2">&quot;data__breed__1&quot;</span><span class="p">),</span> <span class="n">owner_name</span><span class="o">=</span><span class="n">KT</span><span class="p">(</span><span class="s2">&quot;data__owner__name&quot;</span><span class="p">)</span>
<span class="gp">... </span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">first_breed__startswith</span><span class="o">=</span><span class="s2">&quot;lhasa&quot;</span><span class="p">,</span> <span class="n">owner_name</span><span class="o">=</span><span class="s2">&quot;Bob&quot;</span><span class="p">)</span>
<span class="go">&lt;QuerySet [&lt;Dog: Shep&gt;]&gt;</span>
</pre></div>
</div>
</dd></dl>

<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>キーパスクエリの動作上、 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.exclude" title="django.db.models.query.QuerySet.exclude"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exclude()</span></code></a> と <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.filter" title="django.db.models.query.QuerySet.filter"><code class="xref py py-meth docutils literal notranslate"><span class="pre">filter()</span></code></a> は網羅的なセットを生成することを保証しません。パスを持たないオブジェクトを含めたい場合は、 <code class="docutils literal notranslate"><span class="pre">isnull</span></code> ルックアップを追加してください。</p>
</div>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>JSON オブジェクトでは、どのような文字列もキーになる可能性があるため、以下に示す以外のルックアップはキーのルックアップとして解釈されます。エラーは発生しません。タイプミスに十分注意し、クエリが意図したとおりに動作することを常に確認してください。</p>
</div>
<div class="admonition-mariadb-and-oracle-users admonition">
<p class="admonition-title">MariaDB または Oracle ユーザーの場合</p>
<p>キー、インデックス、パスのトランスフォームで <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.order_by" title="django.db.models.query.QuerySet.order_by"><code class="xref py py-meth docutils literal notranslate"><span class="pre">order_by()</span></code></a> を使用すると、値の文字列表現を使ってオブジェクトをソートします。これは、MariaDB と Oracle Database が JSON 値を同等の SQL 値に変換する関数を提供していないからです。</p>
</div>
<div class="admonition-oracle-users admonition">
<p class="admonition-title">Oracle ユーザーの場合</p>
<p>Oracle Databaseで、 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.exclude" title="django.db.models.query.QuerySet.exclude"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exclude()</span></code></a> クエリ内でルックアップ値として <code class="docutils literal notranslate"><span class="pre">None</span></code> を使用すると、指定されたパスで <code class="docutils literal notranslate"><span class="pre">null</span></code> でない値を持つオブジェクト、およびパスを持たないオブジェクトが返されます。他のデータベースバックエンドでは、クエリはパスを持ち、かつ値が <code class="docutils literal notranslate"><span class="pre">null</span></code> でないオブジェクトを返します。</p>
</div>
<div class="admonition-postgresql-users admonition">
<p class="admonition-title">PostgreSQL の場合</p>
<p>PostgreSQLでは、キーやインデックスが1つしか使用されない場合、SQL演算子 <code class="docutils literal notranslate"><span class="pre">-&gt;</span></code> が使用されます。複数の演算子を使用する場合は <code class="docutils literal notranslate"><span class="pre">#&gt;</span></code> 演算子が使用されます。</p>
</div>
<div class="admonition-sqlite-users admonition">
<p class="admonition-title">SQLite ユーザーの場合</p>
<p>SQLite では、文字列 <code class="docutils literal notranslate"><span class="pre">&quot;true&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;false&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;null&quot;</span></code> は常にそれぞれ <code class="docutils literal notranslate"><span class="pre">True</span></code>, <code class="docutils literal notranslate"><span class="pre">False</span></code>, JSON <code class="docutils literal notranslate"><span class="pre">null</span></code> として解釈されます。</p>
</div>
</section>
</section>
<section id="s-containment-and-key-lookups">
<span id="s-id10"></span><span id="containment-and-key-lookups"></span><span id="id10"></span><h3><code class="docutils literal notranslate"><span class="pre">contain</span></code> の概念とキーのルックアップ<a class="headerlink" href="#containment-and-key-lookups" title="Link to this heading">¶</a></h3>
<section id="s-contains">
<span id="s-std-fieldlookup-jsonfield.contains"></span><span id="contains"></span><span id="std-fieldlookup-jsonfield.contains"></span><h4><code class="docutils literal notranslate"><span class="pre">contains</span></code><a class="headerlink" href="#contains" title="Link to this heading">¶</a></h4>
<p><a class="reference internal" href="../../ref/models/querysets.html#std-fieldlookup-contains"><code class="xref std std-lookup docutils literal notranslate"><span class="pre">contains</span></code></a> ルックアップは <code class="docutils literal notranslate"><span class="pre">JSONField</span></code> でオーバーライドされます。返されるオブジェクトは、与えられた <code class="docutils literal notranslate"><span class="pre">dict</span></code> キーと値のペアが、フィールドのトップレベルにすべて含まれているものです。たとえば、次のようになります:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Dog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Rufus&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;breed&quot;</span><span class="p">:</span> <span class="s2">&quot;labrador&quot;</span><span class="p">,</span> <span class="s2">&quot;owner&quot;</span><span class="p">:</span> <span class="s2">&quot;Bob&quot;</span><span class="p">})</span>
<span class="go">&lt;Dog: Rufus&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Dog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Meg&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;breed&quot;</span><span class="p">:</span> <span class="s2">&quot;collie&quot;</span><span class="p">,</span> <span class="s2">&quot;owner&quot;</span><span class="p">:</span> <span class="s2">&quot;Bob&quot;</span><span class="p">})</span>
<span class="go">&lt;Dog: Meg&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Dog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Fred&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="p">{})</span>
<span class="go">&lt;Dog: Fred&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Dog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">data__contains</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;owner&quot;</span><span class="p">:</span> <span class="s2">&quot;Bob&quot;</span><span class="p">})</span>
<span class="go">&lt;QuerySet [&lt;Dog: Rufus&gt;, &lt;Dog: Meg&gt;]&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Dog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">data__contains</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;breed&quot;</span><span class="p">:</span> <span class="s2">&quot;collie&quot;</span><span class="p">})</span>
<span class="go">&lt;QuerySet [&lt;Dog: Meg&gt;]&gt;</span>
</pre></div>
</div>
<div class="admonition-oracle-and-sqlite admonition">
<p class="admonition-title">Oracle と SQLite の場合</p>
<p><code class="docutils literal notranslate"><span class="pre">JSONField</span></code> に対する <code class="docutils literal notranslate"><span class="pre">contains</span></code> ルックアップは Oracle と SQLite ではサポートされていません。</p>
</div>
</section>
<section id="s-contained-by">
<span id="s-std-fieldlookup-jsonfield.contained_by"></span><span id="contained-by"></span><span id="std-fieldlookup-jsonfield.contained_by"></span><h4><code class="docutils literal notranslate"><span class="pre">contained_by</span></code><a class="headerlink" href="#contained-by" title="Link to this heading">¶</a></h4>
<p>これは <a class="reference internal" href="#std-fieldlookup-jsonfield.contains"><code class="xref std std-lookup docutils literal notranslate"><span class="pre">contains</span></code></a> ルックアップの逆です。そのオブジェクト上のキーと値のペアが、引数で渡されたJSON値のサブセットになるようなオブジェクトを返します。例えば:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Dog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Rufus&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;breed&quot;</span><span class="p">:</span> <span class="s2">&quot;labrador&quot;</span><span class="p">,</span> <span class="s2">&quot;owner&quot;</span><span class="p">:</span> <span class="s2">&quot;Bob&quot;</span><span class="p">})</span>
<span class="go">&lt;Dog: Rufus&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Dog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Meg&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;breed&quot;</span><span class="p">:</span> <span class="s2">&quot;collie&quot;</span><span class="p">,</span> <span class="s2">&quot;owner&quot;</span><span class="p">:</span> <span class="s2">&quot;Bob&quot;</span><span class="p">})</span>
<span class="go">&lt;Dog: Meg&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Dog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Fred&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="p">{})</span>
<span class="go">&lt;Dog: Fred&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Dog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">data__contained_by</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;breed&quot;</span><span class="p">:</span> <span class="s2">&quot;collie&quot;</span><span class="p">,</span> <span class="s2">&quot;owner&quot;</span><span class="p">:</span> <span class="s2">&quot;Bob&quot;</span><span class="p">})</span>
<span class="go">&lt;QuerySet [&lt;Dog: Meg&gt;, &lt;Dog: Fred&gt;]&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Dog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">data__contained_by</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;breed&quot;</span><span class="p">:</span> <span class="s2">&quot;collie&quot;</span><span class="p">})</span>
<span class="go">&lt;QuerySet [&lt;Dog: Fred&gt;]&gt;</span>
</pre></div>
</div>
<div class="admonition-oracle-and-sqlite admonition">
<p class="admonition-title">Oracle と SQLite の場合</p>
<p><code class="docutils literal notranslate"><span class="pre">JSONField</span></code> に対する <code class="docutils literal notranslate"><span class="pre">contained_by</span></code> ルックアップは Oracle と SQLite ではサポートされていません。</p>
</div>
</section>
<section id="s-has-key">
<span id="s-std-fieldlookup-jsonfield.has_key"></span><span id="has-key"></span><span id="std-fieldlookup-jsonfield.has_key"></span><h4><code class="docutils literal notranslate"><span class="pre">has_key</span></code><a class="headerlink" href="#has-key" title="Link to this heading">¶</a></h4>
<p>与えられたキーがデータのトップレベルにあるオブジェクトを返します。たとえば次のようになります:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Dog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Rufus&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;breed&quot;</span><span class="p">:</span> <span class="s2">&quot;labrador&quot;</span><span class="p">})</span>
<span class="go">&lt;Dog: Rufus&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Dog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Meg&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;breed&quot;</span><span class="p">:</span> <span class="s2">&quot;collie&quot;</span><span class="p">,</span> <span class="s2">&quot;owner&quot;</span><span class="p">:</span> <span class="s2">&quot;Bob&quot;</span><span class="p">})</span>
<span class="go">&lt;Dog: Meg&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Dog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">data__has_key</span><span class="o">=</span><span class="s2">&quot;owner&quot;</span><span class="p">)</span>
<span class="go">&lt;QuerySet [&lt;Dog: Meg&gt;]&gt;</span>
</pre></div>
</div>
</section>
<section id="s-has-keys">
<span id="s-std-fieldlookup-jsonfield.has_any_keys"></span><span id="has-keys"></span><span id="std-fieldlookup-jsonfield.has_any_keys"></span><h4><code class="docutils literal notranslate"><span class="pre">has_keys</span></code><a class="headerlink" href="#has-keys" title="Link to this heading">¶</a></h4>
<p>与えられたキーがすべて、データのトップレベルにあるオブジェクトを返します。たとえば次のようになります:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Dog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Rufus&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;breed&quot;</span><span class="p">:</span> <span class="s2">&quot;labrador&quot;</span><span class="p">})</span>
<span class="go">&lt;Dog: Rufus&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Dog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Meg&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;breed&quot;</span><span class="p">:</span> <span class="s2">&quot;collie&quot;</span><span class="p">,</span> <span class="s2">&quot;owner&quot;</span><span class="p">:</span> <span class="s2">&quot;Bob&quot;</span><span class="p">})</span>
<span class="go">&lt;Dog: Meg&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Dog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">data__has_keys</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;breed&quot;</span><span class="p">,</span> <span class="s2">&quot;owner&quot;</span><span class="p">])</span>
<span class="go">&lt;QuerySet [&lt;Dog: Meg&gt;]&gt;</span>
</pre></div>
</div>
</section>
<section id="s-has-any-keys">
<span id="s-std-fieldlookup-jsonfield.has_keys"></span><span id="has-any-keys"></span><span id="std-fieldlookup-jsonfield.has_keys"></span><h4><code class="docutils literal notranslate"><span class="pre">has_any_keys</span></code><a class="headerlink" href="#has-any-keys" title="Link to this heading">¶</a></h4>
<p>与えられたキーのいずれかがデータのトップレベルにあるオブジェクトを返します。たとえば次のようになります:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Dog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Rufus&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;breed&quot;</span><span class="p">:</span> <span class="s2">&quot;labrador&quot;</span><span class="p">})</span>
<span class="go">&lt;Dog: Rufus&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Dog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Meg&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;owner&quot;</span><span class="p">:</span> <span class="s2">&quot;Bob&quot;</span><span class="p">})</span>
<span class="go">&lt;Dog: Meg&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Dog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">data__has_any_keys</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;owner&quot;</span><span class="p">,</span> <span class="s2">&quot;breed&quot;</span><span class="p">])</span>
<span class="go">&lt;QuerySet [&lt;Dog: Rufus&gt;, &lt;Dog: Meg&gt;]&gt;</span>
</pre></div>
</div>
</section>
</section>
</section>
<section id="s-complex-lookups-with-q-objects">
<span id="s-complex-lookups-with-q"></span><span id="complex-lookups-with-q-objects"></span><span id="complex-lookups-with-q"></span><h2><code class="docutils literal notranslate"><span class="pre">Q</span></code> オブジェクトを使った複雑なルックアップ<a class="headerlink" href="#complex-lookups-with-q-objects" title="Link to this heading">¶</a></h2>
<p>キーワード引数クエリ (<a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.filter" title="django.db.models.query.QuerySet.filter"><code class="xref py py-meth docutils literal notranslate"><span class="pre">filter()</span></code></a> などで使用されるもの) は &quot;AND&quot; 条件で結合されます。もしより複雑なクエリ（例えば、 &quot;OR&quot; 文を含むクエリ）を実行する必要がある場合、 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.Q" title="django.db.models.Q"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qオブジェクト</span></code></a> を使用できます。</p>
<p><a class="reference internal" href="../../ref/models/querysets.html#django.db.models.Q" title="django.db.models.Q"><code class="xref py py-class docutils literal notranslate"><span class="pre">Q</span> <span class="pre">オブジェクト</span></code></a> (<code class="docutils literal notranslate"><span class="pre">django.db.models.Q</span></code>) はキーワード引数のコレクションをカプセル化するためのオブジェクトです。これらのキーワード引数は上記の &quot;フィールドルックアップ&quot; のように指定します。</p>
<p>たとえば、次の <code class="docutils literal notranslate"><span class="pre">Q</span></code> オブジェクトは、1つの <code class="docutils literal notranslate"><span class="pre">LIKE</span></code> クエリをカプセル化しています。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">django.db.models</span><span class="w"> </span><span class="kn">import</span> <span class="n">Q</span>

<span class="n">Q</span><span class="p">(</span><span class="n">question__startswith</span><span class="o">=</span><span class="s2">&quot;What&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Q</span></code> オブジェクトは <code class="docutils literal notranslate"><span class="pre">&amp;</span></code>, <code class="docutils literal notranslate"><span class="pre">|</span></code>, <code class="docutils literal notranslate"><span class="pre">^</span></code> 演算子を使って結合できます。演算子を2つの <code class="docutils literal notranslate"><span class="pre">Q</span></code> オブジェクトに使用すると、新しい <code class="docutils literal notranslate"><span class="pre">Q</span></code> オブジェクトが生成されます。</p>
<p>たとえば、次の文は2つの <code class="docutils literal notranslate"><span class="pre">&quot;question__startswith&quot;</span></code> の &quot;OR&quot; を表す、1つの <code class="docutils literal notranslate"><span class="pre">Q</span></code> オブジェクトを生み出します。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Q</span><span class="p">(</span><span class="n">question__startswith</span><span class="o">=</span><span class="s2">&quot;Who&quot;</span><span class="p">)</span> <span class="o">|</span> <span class="n">Q</span><span class="p">(</span><span class="n">question__startswith</span><span class="o">=</span><span class="s2">&quot;What&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>このコードは次の SQL の <code class="docutils literal notranslate"><span class="pre">WHERE</span></code> 句と同等です:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">WHERE</span><span class="w"> </span><span class="n">question</span><span class="w"> </span><span class="k">LIKE</span><span class="w"> </span><span class="s1">&#39;Who%&#39;</span><span class="w"> </span><span class="k">OR</span><span class="w"> </span><span class="n">question</span><span class="w"> </span><span class="k">LIKE</span><span class="w"> </span><span class="s1">&#39;What%&#39;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Q</span></code> オブジェクトと <code class="docutils literal notranslate"><span class="pre">&amp;</span></code>, <code class="docutils literal notranslate"><span class="pre">|</span></code>, <code class="docutils literal notranslate"><span class="pre">^</span></code> 演算子を組み合わせ、括弧でグループ化することで、任意の複雑な文を作成できます。また、 <code class="docutils literal notranslate"><span class="pre">Q</span></code> オブジェクトは <code class="docutils literal notranslate"><span class="pre">~</span></code> 演算子を使用して否定することができ、通常のクエリと否定された (<code class="docutils literal notranslate"><span class="pre">NOT</span></code>) クエリの両方を組み合わせてルックアップできます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Q</span><span class="p">(</span><span class="n">question__startswith</span><span class="o">=</span><span class="s2">&quot;Who&quot;</span><span class="p">)</span> <span class="o">|</span> <span class="o">~</span><span class="n">Q</span><span class="p">(</span><span class="n">pub_date__year</span><span class="o">=</span><span class="mi">2005</span><span class="p">)</span>
</pre></div>
</div>
<p>キーワード引数を取るルックアップ関数 (例えば <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.filter" title="django.db.models.query.QuerySet.filter"><code class="xref py py-meth docutils literal notranslate"><span class="pre">filter()</span></code></a>, <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.exclude" title="django.db.models.query.QuerySet.exclude"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exclude()</span></code></a>, <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.get" title="django.db.models.query.QuerySet.get"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get()</span></code></a>) には、1つ以上の <code class="docutils literal notranslate"><span class="pre">Q</span></code> オブジェクトを（名前なし）位置引数として渡すこともできます。複数の <code class="docutils literal notranslate"><span class="pre">Q</span></code> オブジェクトの引数をルックアップ関数に渡すと、引数は &quot;AND&quot; されます。たとえば、次のようになります:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Poll</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
    <span class="n">Q</span><span class="p">(</span><span class="n">question__startswith</span><span class="o">=</span><span class="s2">&quot;Who&quot;</span><span class="p">),</span>
    <span class="n">Q</span><span class="p">(</span><span class="n">pub_date</span><span class="o">=</span><span class="n">date</span><span class="p">(</span><span class="mi">2005</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span> <span class="o">|</span> <span class="n">Q</span><span class="p">(</span><span class="n">pub_date</span><span class="o">=</span><span class="n">date</span><span class="p">(</span><span class="mi">2005</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">)),</span>
<span class="p">)</span>
</pre></div>
</div>
<p>... これは大ざっぱにSQLに翻訳すると次のようになります:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">polls</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">question</span><span class="w"> </span><span class="k">LIKE</span><span class="w"> </span><span class="s1">&#39;Who%&#39;</span>
<span class="w">    </span><span class="k">AND</span><span class="w"> </span><span class="p">(</span><span class="n">pub_date</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;2005-05-02&#39;</span><span class="w"> </span><span class="k">OR</span><span class="w"> </span><span class="n">pub_date</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;2005-05-06&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>ルックアップ関数は <code class="docutils literal notranslate"><span class="pre">Q</span></code> オブジェクトとキーワード引数を混ぜて使うことができます。ルックアップ関数に提供されたすべての引数は（キーワード引数でも <code class="docutils literal notranslate"><span class="pre">Q</span></code> オブジェクトでも） &quot;AND&quot; で結合されます。しかし、もし <code class="docutils literal notranslate"><span class="pre">Q</span></code> オブジェクトが指定された場合は、キーワード引数の定義よりも前に指定する必要があります。たとえば次のようにします:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Poll</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
    <span class="n">Q</span><span class="p">(</span><span class="n">pub_date</span><span class="o">=</span><span class="n">date</span><span class="p">(</span><span class="mi">2005</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span> <span class="o">|</span> <span class="n">Q</span><span class="p">(</span><span class="n">pub_date</span><span class="o">=</span><span class="n">date</span><span class="p">(</span><span class="mi">2005</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">)),</span>
    <span class="n">question__startswith</span><span class="o">=</span><span class="s2">&quot;Who&quot;</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>
</div>
<p>...上記は有効なクエリで、1つ前の例と同じです。しかし、:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># INVALID QUERY</span>
<span class="n">Poll</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
    <span class="n">question__startswith</span><span class="o">=</span><span class="s2">&quot;Who&quot;</span><span class="p">,</span>
    <span class="n">Q</span><span class="p">(</span><span class="n">pub_date</span><span class="o">=</span><span class="n">date</span><span class="p">(</span><span class="mi">2005</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span> <span class="o">|</span> <span class="n">Q</span><span class="p">(</span><span class="n">pub_date</span><span class="o">=</span><span class="n">date</span><span class="p">(</span><span class="mi">2005</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">)),</span>
<span class="p">)</span>
</pre></div>
</div>
<p>...これは無効なクエリです。</p>
<div class="admonition seealso">
<p class="admonition-title">参考</p>
<p>Django のユニットテストにある <a class="extlink-source reference external" href="https://github.com/django/django/blob/main/tests/or_lookups/tests.py">OR ルックアップの例</a> は <code class="docutils literal notranslate"><span class="pre">Q</span></code> の可能な使い方をいくつか示しています。</p>
</div>
</section>
<section id="s-comparing-objects">
<span id="comparing-objects"></span><h2>オブジェクトを比較する<a class="headerlink" href="#comparing-objects" title="Link to this heading">¶</a></h2>
<p>2つのモデルインスタンスを比較するには、Pythonの標準的な比較演算子である二重の等号 <code class="docutils literal notranslate"><span class="pre">==</span></code> を使います。裏では、2つのモデルのプライマリキーの値を比較します。</p>
<p>上記の <code class="docutils literal notranslate"><span class="pre">Entry</span></code> を例にすると、次の2つの文は等価です:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">some_entry</span> <span class="o">==</span> <span class="n">other_entry</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">some_entry</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">other_entry</span><span class="o">.</span><span class="n">id</span>
</pre></div>
</div>
<p>モデルのプライマリキーが <code class="docutils literal notranslate"><span class="pre">id</span></code> という名前でなくても問題ありません。どのような名前であっても、比較は常にプライマリキーを使用します。たとえば、モデルのプライマリキーフィールドが <code class="docutils literal notranslate"><span class="pre">name</span></code> と呼ばれている場合、これら2つの文は等価です:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">some_obj</span> <span class="o">==</span> <span class="n">other_obj</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">some_obj</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">other_obj</span><span class="o">.</span><span class="n">name</span>
</pre></div>
</div>
</section>
<section id="s-deleting-objects">
<span id="s-topics-db-queries-delete"></span><span id="deleting-objects"></span><span id="topics-db-queries-delete"></span><h2>オブジェクトを削除する<a class="headerlink" href="#deleting-objects" title="Link to this heading">¶</a></h2>
<p>削除メソッドは便利なことに <a class="reference internal" href="../../ref/models/instances.html#django.db.models.Model.delete" title="django.db.models.Model.delete"><code class="xref py py-meth docutils literal notranslate"><span class="pre">delete()</span></code></a> という名前です。このメソッドはオブジェクトを即座に削除し、削除されたオブジェクトの数と、オブジェクトの種類ごとの削除数を辞書として返します。例:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">delete</span><span class="p">()</span>
<span class="go">(1, {&#39;blog.Entry&#39;: 1})</span>
</pre></div>
</div>
<p>オブジェクトを一括で削除することもできます。すべての <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> は <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.delete" title="django.db.models.query.QuerySet.delete"><code class="xref py py-meth docutils literal notranslate"><span class="pre">delete()</span></code></a> メソッドを持っており、その <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> のすべてのメンバーを削除します。</p>
<p>たとえば、これは <code class="docutils literal notranslate"><span class="pre">pub_date</span></code> が2005年の <code class="docutils literal notranslate"><span class="pre">Entry</span></code> オブジェクトをすべて削除します:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">pub_date__year</span><span class="o">=</span><span class="mi">2005</span><span class="p">)</span><span class="o">.</span><span class="n">delete</span><span class="p">()</span>
<span class="go">(5, {&#39;webapp.Entry&#39;: 5})</span>
</pre></div>
</div>
<p>これは可能な限り純粋にSQLで実行されます。そのため、処理中に個々のオブジェクトインスタンスの <code class="docutils literal notranslate"><span class="pre">delete()</span></code> メソッドが呼び出される必要はないことに注意してください。もしあなたが独自の <code class="docutils literal notranslate"><span class="pre">delete()</span></code> メソッドをモデルクラスに定義しており、それを確実に呼び出したい場合は、<a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> の <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.delete" title="django.db.models.query.QuerySet.delete"><code class="xref py py-meth docutils literal notranslate"><span class="pre">delete()</span></code></a> メソッドを使って一括削除するのではなく、「手動で」そのモデルインスタンスを削除する必要があります（たとえば、 QuerySet をイテレートして各オブジェクトに対し個別に <code class="docutils literal notranslate"><span class="pre">delete()</span></code> を呼び出します）。</p>
<p>Django がオブジェクトを削除するとき、デフォルトでは SQL の制約 <code class="docutils literal notranslate"><span class="pre">ON</span> <span class="pre">DELETE</span> <span class="pre">CASCADE</span></code> の動作をエミュレートします。言い換えると、削除するオブジェクトを指している外部キーを持つすべてのオブジェクトは、ともに削除されます。たとえば、</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">b</span> <span class="o">=</span> <span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">pk</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="c1"># This will delete the Blog and all of its Entry objects.</span>
<span class="n">b</span><span class="o">.</span><span class="n">delete</span><span class="p">()</span>
</pre></div>
</div>
<p>このカスケード動作は、<a class="reference internal" href="../../ref/models/fields.html#django.db.models.ForeignKey" title="django.db.models.ForeignKey"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForeignKey</span></code></a> の <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ForeignKey.on_delete" title="django.db.models.ForeignKey.on_delete"><code class="xref py py-attr docutils literal notranslate"><span class="pre">on_delete</span></code></a> 引数でカスタマイズできます。</p>
<p>注意点として、 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.delete" title="django.db.models.query.QuerySet.delete"><code class="xref py py-meth docutils literal notranslate"><span class="pre">delete()</span></code></a> は、 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> メソッドの中で唯一、 <a class="reference internal" href="managers.html#django.db.models.Manager" title="django.db.models.Manager"><code class="xref py py-class docutils literal notranslate"><span class="pre">Manager</span></code></a> 自身からは公開されていません。これは、誤って <code class="docutils literal notranslate"><span class="pre">Entry.objects.delete()</span></code> を呼び出して <em>すべての</em> エントリを削除してしまわないようにするための安全対策です。もしあなたが <em>本当に</em> すべてのオブジェクトを削除したい場合は、下記のように明示的に完全なクエリセットに対して呼び出す必要があります。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">()</span><span class="o">.</span><span class="n">delete</span><span class="p">()</span>
</pre></div>
</div>
</section>
<section id="s-copying-model-instances">
<span id="s-topics-db-queries-copy"></span><span id="copying-model-instances"></span><span id="topics-db-queries-copy"></span><h2>モデルのインスタンスを複製する<a class="headerlink" href="#copying-model-instances" title="Link to this heading">¶</a></h2>
<p>モデルインスタンスをコピーする組み込みメソッドはありませんが、全てのフィールドの値をコピーした新しいインスタンスは簡単に作ることができます。最も単純なケースでは、 <code class="docutils literal notranslate"><span class="pre">pk</span></code> を <code class="docutils literal notranslate"><span class="pre">None</span></code> に設定し、 <a class="reference internal" href="../../ref/models/instances.html#django.db.models.Model._state" title="django.db.models.Model._state"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_state.adding</span></code></a> を <code class="docutils literal notranslate"><span class="pre">True</span></code> に設定します。ブログの例で説明すると、次のようになります:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">blog</span> <span class="o">=</span> <span class="n">Blog</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;My blog&quot;</span><span class="p">,</span> <span class="n">tagline</span><span class="o">=</span><span class="s2">&quot;Blogging is easy&quot;</span><span class="p">)</span>
<span class="n">blog</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>  <span class="c1"># blog.pk == 1</span>

<span class="n">blog</span><span class="o">.</span><span class="n">pk</span> <span class="o">=</span> <span class="kc">None</span>
<span class="n">blog</span><span class="o">.</span><span class="n">_state</span><span class="o">.</span><span class="n">adding</span> <span class="o">=</span> <span class="kc">True</span>
<span class="n">blog</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>  <span class="c1"># blog.pk == 2</span>
</pre></div>
</div>
<p>継承を使っている場合、もっと複雑になります。<code class="docutils literal notranslate"><span class="pre">Blog</span></code> のサブクラスを考えると:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">ThemeBlog</span><span class="p">(</span><span class="n">Blog</span><span class="p">):</span>
    <span class="n">theme</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">200</span><span class="p">)</span>


<span class="n">django_blog</span> <span class="o">=</span> <span class="n">ThemeBlog</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Django&quot;</span><span class="p">,</span> <span class="n">tagline</span><span class="o">=</span><span class="s2">&quot;Django is easy&quot;</span><span class="p">,</span> <span class="n">theme</span><span class="o">=</span><span class="s2">&quot;python&quot;</span><span class="p">)</span>
<span class="n">django_blog</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>  <span class="c1"># django_blog.pk == 3</span>
</pre></div>
</div>
<p>継承のしくみ上、<code class="docutils literal notranslate"><span class="pre">pk</span></code> と <code class="docutils literal notranslate"><span class="pre">id</span></code> の両方を <code class="docutils literal notranslate"><span class="pre">None</span></code> に設定し、 <code class="docutils literal notranslate"><span class="pre">_state.adding</span></code> を <code class="docutils literal notranslate"><span class="pre">True</span></code> に設定する必要があります:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">django_blog</span><span class="o">.</span><span class="n">pk</span> <span class="o">=</span> <span class="kc">None</span>
<span class="n">django_blog</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="kc">None</span>
<span class="n">django_blog</span><span class="o">.</span><span class="n">_state</span><span class="o">.</span><span class="n">adding</span> <span class="o">=</span> <span class="kc">True</span>
<span class="n">django_blog</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>  <span class="c1"># django_blog.pk == 4</span>
</pre></div>
</div>
<p>この処理では、モデルのデータベーステーブルの一部ではないリレーションは複製しません。例えば、<code class="docutils literal notranslate"><span class="pre">Entry</span></code> は <code class="docutils literal notranslate"><span class="pre">Author</span></code> への <code class="docutils literal notranslate"><span class="pre">ManyToManyField</span></code> を持ちます。entry の複製後、新しい entry に対して多対多のリレーションをセットする必要があります:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">entry</span> <span class="o">=</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># some previous entry</span>
<span class="n">old_authors</span> <span class="o">=</span> <span class="n">entry</span><span class="o">.</span><span class="n">authors</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
<span class="n">entry</span><span class="o">.</span><span class="n">pk</span> <span class="o">=</span> <span class="kc">None</span>
<span class="n">entry</span><span class="o">.</span><span class="n">_state</span><span class="o">.</span><span class="n">adding</span> <span class="o">=</span> <span class="kc">True</span>
<span class="n">entry</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
<span class="n">entry</span><span class="o">.</span><span class="n">authors</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">old_authors</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">OneToOneField</span></code> については、1 対 1 のユニーク制約への違反を避けるため、リレーション先オブジェクトを複製して新しいオブジェクトのフィールドに割り当てる必要があります。たとえば上記のように <code class="docutils literal notranslate"><span class="pre">entry</span></code> がすでに複製されている場合、次のようにします。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">detail</span> <span class="o">=</span> <span class="n">EntryDetail</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">detail</span><span class="o">.</span><span class="n">pk</span> <span class="o">=</span> <span class="kc">None</span>
<span class="n">detail</span><span class="o">.</span><span class="n">_state</span><span class="o">.</span><span class="n">adding</span> <span class="o">=</span> <span class="kc">True</span>
<span class="n">detail</span><span class="o">.</span><span class="n">entry</span> <span class="o">=</span> <span class="n">entry</span>
<span class="n">detail</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
</pre></div>
</div>
</section>
<section id="s-updating-multiple-objects-at-once">
<span id="s-topics-db-queries-update"></span><span id="updating-multiple-objects-at-once"></span><span id="topics-db-queries-update"></span><h2>複数のオブジェクトを一括で更新する<a class="headerlink" href="#updating-multiple-objects-at-once" title="Link to this heading">¶</a></h2>
<p><a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> のすべてのオブジェクトに、特定の値をセットしたい場合があります。<a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.update" title="django.db.models.query.QuerySet.update"><code class="xref py py-meth docutils literal notranslate"><span class="pre">update()</span></code></a> を使えば実現できます。例えば:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Update all the headlines with pub_date in 2007.</span>
<span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">pub_date__year</span><span class="o">=</span><span class="mi">2007</span><span class="p">)</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">headline</span><span class="o">=</span><span class="s2">&quot;Everything is the same&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>このメソッドを使ってセットできるのは非リレーションフィールドと <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ForeignKey" title="django.db.models.ForeignKey"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForeignKey</span></code></a> フィールドのみです。非リレーションフィールドを更新するには、新しい値を定数として渡します。 <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ForeignKey" title="django.db.models.ForeignKey"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForeignKey</span></code></a> フィールドを更新するには、結び付けたい新しいモデルインスタンスを新しい値にセットしてください。たとえば、次のようにします:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">pk</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="go"># Change every Entry so that it belongs to this Blog.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">blog</span><span class="o">=</span><span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">update()</span></code> は即座に適用され、クエリにマッチした行数を返します (行はすでに新しい値を持っていることがあるので、更新された行の数と一致するとは限りません)。更新する <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> の唯一の制限は、1 つのデータベーステーブル (モデルのメインテーブル) にしかアクセスできないことです。リレーション先のフィールドでフィルタすることもできますが、モデルのメインテーブルのカラムしか更新できません。例えば:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">pk</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="go"># Update all the headlines belonging to this Blog.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">blog</span><span class="o">=</span><span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">headline</span><span class="o">=</span><span class="s2">&quot;Everything is the same&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">update()</span></code> は直接 SQL文に変換されることに注意してください。これは、直接更新する一括操作です。 <a class="reference internal" href="../../ref/models/instances.html#django.db.models.Model.save" title="django.db.models.Model.save"><code class="xref py py-meth docutils literal notranslate"><span class="pre">save()</span></code></a> を実行することは一切なく、(<a class="reference internal" href="../../ref/models/instances.html#django.db.models.Model.save" title="django.db.models.Model.save"><code class="xref py py-meth docutils literal notranslate"><span class="pre">save()</span></code></a> を呼び出した結果である) <code class="docutils literal notranslate"><span class="pre">pre_save</span></code> や <code class="docutils literal notranslate"><span class="pre">post_save</span></code> のシグナルも出しません。 <a class="reference internal" href="../../ref/models/fields.html#django.db.models.DateField.auto_now" title="django.db.models.DateField.auto_now"><code class="xref py py-attr docutils literal notranslate"><span class="pre">auto_now</span></code></a> フィールドオプションも実施しません。 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> のすべてのアイテムを保存し、各インスタンスで <a class="reference internal" href="../../ref/models/instances.html#django.db.models.Model.save" title="django.db.models.Model.save"><code class="xref py py-meth docutils literal notranslate"><span class="pre">save()</span></code></a> メソッドが確実に呼ばれるようにしたい場合、特別な機能は不要です。これらをループし、 <a class="reference internal" href="../../ref/models/instances.html#django.db.models.Model.save" title="django.db.models.Model.save"><code class="xref py py-meth docutils literal notranslate"><span class="pre">save()</span></code></a> を呼び出してください:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">my_queryset</span><span class="p">:</span>
    <span class="n">item</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
</pre></div>
</div>
<p>update の呼び出しでは、 <a class="reference internal" href="../../ref/models/expressions.html#django.db.models.F" title="django.db.models.F"><code class="xref py py-class docutils literal notranslate"><span class="pre">F</span> <span class="pre">式</span></code></a> を使ってモデル内の別のフィールドの値に基づいてフィールドを更新することもできます。これは、現在値に基づいてカウンタを増加させる場合に特に有用です。例えば、ブログの各 entry の pingback カウントを増加させるには:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">number_of_pingbacks</span><span class="o">=</span><span class="n">F</span><span class="p">(</span><span class="s2">&quot;number_of_pingbacks&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>しかし、filter および exclude 句での <code class="docutils literal notranslate"><span class="pre">F()</span></code> オブジェクトとは異なり、update で <code class="docutils literal notranslate"><span class="pre">F()</span></code> オブジェクトを使うときはテーブル結合はできません。できるのは、更新されるモデルに関係付けられたフィールドを参照することだけです。 <code class="docutils literal notranslate"><span class="pre">F()</span></code> オブジェクト内でテーブル結合が必要なルックアップを行おうとすると、 <code class="docutils literal notranslate"><span class="pre">FieldError</span></code> が送出されます。</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="go"># This will raise a FieldError</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">headline</span><span class="o">=</span><span class="n">F</span><span class="p">(</span><span class="s2">&quot;blog__name&quot;</span><span class="p">))</span>
</pre></div>
</div>
</section>
<section id="s-related-objects">
<span id="s-topics-db-queries-related"></span><span id="related-objects"></span><span id="topics-db-queries-related"></span><h2>リレーション先のオブジェクト<a class="headerlink" href="#related-objects" title="Link to this heading">¶</a></h2>
<p>モデルでリレーションシップを定義した場合 (例えば <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ForeignKey" title="django.db.models.ForeignKey"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForeignKey</span></code></a>、<a class="reference internal" href="../../ref/models/fields.html#django.db.models.OneToOneField" title="django.db.models.OneToOneField"><code class="xref py py-class docutils literal notranslate"><span class="pre">OneToOneField</span></code></a>、<a class="reference internal" href="../../ref/models/fields.html#django.db.models.ManyToManyField" title="django.db.models.ManyToManyField"><code class="xref py py-class docutils literal notranslate"><span class="pre">ManyToManyField</span></code></a> の 3 つです)、そのモデルのインスタンスはリレーション先のオブジェクトにアクセスするための便利な API を持ちます。</p>
<p>このページで最初に提示したモデルを使うと、例えば、<code class="docutils literal notranslate"><span class="pre">Entry</span></code> オブジェクト <code class="docutils literal notranslate"><span class="pre">e</span></code> は、<code class="docutils literal notranslate"><span class="pre">blog</span></code> 属性 (<code class="docutils literal notranslate"><span class="pre">e.blog</span></code>) にアクセスすることで、関連付けられた <code class="docutils literal notranslate"><span class="pre">Blog</span></code> オブジェクトを得ることができます。</p>
<p>(裏では、この機能は Python <a class="reference external" href="https://docs.python.org/3/howto/descriptor.html" title="(in Python v3.13)"><span class="xref std std-doc">descriptors</span></a> によって実装されています。これはとくに重要ではありませんが、興味がある人のためにここに書いておきます)。</p>
<p>Djangoは、リレーションシップの「反対」側のためのAPIアクセサも作成します。関連付けられた相手のモデルから、リレーションシップが定義されている元のモデルへのリンクです。たとえば、<code class="docutils literal notranslate"><span class="pre">Blog</span></code> オブジェクト <code class="docutils literal notranslate"><span class="pre">b</span></code> は、関連付けられたすべての <code class="docutils literal notranslate"><span class="pre">Entry</span></code> オブジェクトに対するリンクを、<code class="docutils literal notranslate"><span class="pre">entry_set</span></code> 属性を通じて、<code class="docutils literal notranslate"><span class="pre">b.entry_set.all()</span></code> のようにアクセスできます。</p>
<p>このセクションのすべての例で使われたサンプルの <code class="docutils literal notranslate"><span class="pre">Blog</span></code>、<code class="docutils literal notranslate"><span class="pre">Author</span></code>、<code class="docutils literal notranslate"><span class="pre">Entry</span></code> モデルは、このページの最初で定義したものです。</p>
<section id="s-one-to-many-relationships">
<span id="one-to-many-relationships"></span><h3>一対多のリレーションシップ<a class="headerlink" href="#one-to-many-relationships" title="Link to this heading">¶</a></h3>
<section id="s-forward">
<span id="forward"></span><h4>順方向のアクセス<a class="headerlink" href="#forward" title="Link to this heading">¶</a></h4>
<p>モデルに <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ForeignKey" title="django.db.models.ForeignKey"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForeignKey</span></code></a> がある場合、そのモデルのインスタンスは、モデルの属性を介してリレーション先の（外部）オブジェクトにアクセスできます。</p>
<p>例:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">blog</span>  <span class="c1"># Returns the related Blog object.</span>
</pre></div>
</div>
<p>外部キー属性を介して値を取得したりセットしたりできます。他の例と同様、外部キーの変更は次のように <a class="reference internal" href="../../ref/models/instances.html#django.db.models.Model.save" title="django.db.models.Model.save"><code class="xref py py-meth docutils literal notranslate"><span class="pre">save()</span></code></a> を呼び出すまでデータベースには保存されません。</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">blog</span> <span class="o">=</span> <span class="n">some_blog</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
</pre></div>
</div>
<p><a class="reference internal" href="../../ref/models/fields.html#django.db.models.ForeignKey" title="django.db.models.ForeignKey"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForeignKey</span></code></a> フィールドに <code class="docutils literal notranslate"><span class="pre">null=True</span></code> が設定されている場合 (つまり、 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 値を許可している場合)、次のように、 <code class="docutils literal notranslate"><span class="pre">None</span></code> を代入することでリレーションを削除できます。</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">blog</span> <span class="o">=</span> <span class="kc">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>  <span class="c1"># &quot;UPDATE blog_entry SET blog_id = NULL ...;&quot;</span>
</pre></div>
</div>
<p>一対多のリレーションシップへの順方向のアクセスは、リレーション先オブジェクトに最初にアクセスしたときにキャッシュされます。同じオブジェクトインスタンスの外部キーへのその後のアクセスはキャッシュされます。例えば次のコードはキャッシュを使います。</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">blog</span><span class="p">)</span>  <span class="c1"># Hits the database to retrieve the associated Blog.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">blog</span><span class="p">)</span>  <span class="c1"># Doesn&#39;t hit the database; uses cached version.</span>
</pre></div>
</div>
<p><a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> のメソッドである <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.select_related" title="django.db.models.query.QuerySet.select_related"><code class="xref py py-meth docutils literal notranslate"><span class="pre">select_related()</span></code></a> は、全ての一対多のリレーションシップのキャッシュを再帰的に先読みします。たとえば次のようになります。</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">select_related</span><span class="p">()</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">blog</span><span class="p">)</span>  <span class="c1"># Doesn&#39;t hit the database; uses cached version.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">blog</span><span class="p">)</span>  <span class="c1"># Doesn&#39;t hit the database; uses cached version.</span>
</pre></div>
</div>
</section>
<section id="s-following-relationships-backward">
<span id="s-backwards-related-objects"></span><span id="following-relationships-backward"></span><span id="backwards-related-objects"></span><h4>&quot;逆方向&quot; のリレーションシップ<a class="headerlink" href="#following-relationships-backward" title="Link to this heading">¶</a></h4>
<p>モデルが <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ForeignKey" title="django.db.models.ForeignKey"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForeignKey</span></code></a> を持つ場合、外部キーのモデルのインスタンスは最初のモデルのインスタンスを返す <a class="reference internal" href="managers.html#django.db.models.Manager" title="django.db.models.Manager"><code class="xref py py-class docutils literal notranslate"><span class="pre">Manager</span></code></a> にアクセスできます。デフォルトでは、この <a class="reference internal" href="managers.html#django.db.models.Manager" title="django.db.models.Manager"><code class="xref py py-class docutils literal notranslate"><span class="pre">Manager</span></code></a> は <code class="docutils literal notranslate"><span class="pre">FOO_set</span></code> と名付けられており、<code class="docutils literal notranslate"><span class="pre">FOO</span></code> には元のモデル名が小文字で入ります。この <a class="reference internal" href="managers.html#django.db.models.Manager" title="django.db.models.Manager"><code class="xref py py-class docutils literal notranslate"><span class="pre">Manager</span></code></a> は <code class="docutils literal notranslate"><span class="pre">QuerySets</span></code> を返し、上述の &quot;オブジェクトを取り出す&quot; セクションで説明したようにフィルタおよび操作が可能です。</p>
<p>例:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">entry_set</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>  <span class="c1"># Returns all Entry objects related to Blog.</span>

<span class="go"># b.entry_set is a Manager that returns QuerySets.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">entry_set</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">headline__contains</span><span class="o">=</span><span class="s2">&quot;Lennon&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">entry_set</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>
</pre></div>
</div>
<p><a class="reference internal" href="../../ref/models/fields.html#django.db.models.ForeignKey" title="django.db.models.ForeignKey"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForeignKey</span></code></a> 定義の <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ForeignKey.related_name" title="django.db.models.ForeignKey.related_name"><code class="xref py py-attr docutils literal notranslate"><span class="pre">related_name</span></code></a> パラメータを指定することで、 <code class="docutils literal notranslate"><span class="pre">FOO_set</span></code> の名前を上書きできます。たとえば、 <code class="docutils literal notranslate"><span class="pre">Entry</span></code> モデルを <code class="docutils literal notranslate"><span class="pre">blog</span> <span class="pre">=</span> <span class="pre">ForeignKey(Blog,</span> <span class="pre">on_delete=models.CASCADE,</span> <span class="pre">related_name='entries')</span></code> に変更した場合、上記のコード例は次のようになります:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">entries</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>  <span class="c1"># Returns all Entry objects related to Blog.</span>

<span class="go"># b.entries is a Manager that returns QuerySets.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">entries</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">headline__contains</span><span class="o">=</span><span class="s2">&quot;Lennon&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">entries</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>
</pre></div>
</div>
</section>
<section id="s-using-a-custom-reverse-manager">
<span id="s-using-custom-reverse-manager"></span><span id="using-a-custom-reverse-manager"></span><span id="using-custom-reverse-manager"></span><h4>カスタムのリバースマネージャを使う<a class="headerlink" href="#using-a-custom-reverse-manager" title="Link to this heading">¶</a></h4>
<p>デフォルトでは、逆方向のリレーションシップに使われる <a class="reference internal" href="../../ref/models/relations.html#django.db.models.fields.related.RelatedManager" title="django.db.models.fields.related.RelatedManager"><code class="xref py py-class docutils literal notranslate"><span class="pre">RelatedManager</span></code></a> はモデルに対する <a class="reference internal" href="managers.html#manager-names"><span class="std std-ref">デフォルト マネージャ</span></a> のサブクラスです。与えられたクエリに対して別のマネージャを指定したい場合、以下の構文が使用できます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">django.db</span><span class="w"> </span><span class="kn">import</span> <span class="n">models</span>


<span class="k">class</span><span class="w"> </span><span class="nc">Entry</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="c1"># ...</span>
    <span class="n">objects</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">Manager</span><span class="p">()</span>  <span class="c1"># Default Manager</span>
    <span class="n">entries</span> <span class="o">=</span> <span class="n">EntryManager</span><span class="p">()</span>  <span class="c1"># Custom Manager</span>


<span class="n">b</span> <span class="o">=</span> <span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">b</span><span class="o">.</span><span class="n">entry_set</span><span class="p">(</span><span class="n">manager</span><span class="o">=</span><span class="s2">&quot;entries&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">EntryManager</span></code> が、<code class="docutils literal notranslate"><span class="pre">get_queryset()</span></code> メソッドでデフォルトのフィルタ動作をした場合、<code class="docutils literal notranslate"><span class="pre">all()</span></code> の呼び出しに適用されます。</p>
<p>カスタムリバースマネージャを指定すると、そのカスタムメソッドを呼び出すこともできます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">b</span><span class="o">.</span><span class="n">entry_set</span><span class="p">(</span><span class="n">manager</span><span class="o">=</span><span class="s2">&quot;entries&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">is_published</span><span class="p">()</span>
</pre></div>
</div>
<div class="admonition-interaction-with-prefetching admonition">
<p class="admonition-title">プリフェッチ（先読み）との関係</p>
<p>逆リレーションを指定して <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.prefetch_related" title="django.db.models.query.QuerySet.prefetch_related"><code class="xref py py-meth docutils literal notranslate"><span class="pre">prefetch_related()</span></code></a> をコールすると、 デフォルトのマネージャが使用されます。カスタムのリバースマネージャを使用して リレーション先のオブジェクトをプリフェッチしたい場合は、 <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.Prefetch" title="django.db.models.Prefetch"><code class="xref py py-class docutils literal notranslate"><span class="pre">Prefetch()</span></code></a> を使用します。たとえば次のようになります:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">django.db.models</span><span class="w"> </span><span class="kn">import</span> <span class="n">Prefetch</span>

<span class="n">prefetch_manager</span> <span class="o">=</span> <span class="n">Prefetch</span><span class="p">(</span><span class="s2">&quot;entry_set&quot;</span><span class="p">,</span> <span class="n">queryset</span><span class="o">=</span><span class="n">Entry</span><span class="o">.</span><span class="n">entries</span><span class="o">.</span><span class="n">all</span><span class="p">())</span>
<span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">prefetch_related</span><span class="p">(</span><span class="n">prefetch_manager</span><span class="p">)</span>
</pre></div>
</div>
</div>
</section>
<section id="s-additional-methods-to-handle-related-objects">
<span id="additional-methods-to-handle-related-objects"></span><h4>リレーション先オブジェクトを処理する他のメソッド<a class="headerlink" href="#additional-methods-to-handle-related-objects" title="Link to this heading">¶</a></h4>
<p>上述の &quot;オブジェクトを取り出す&quot; で定義した <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> メソッドに加えて、<a class="reference internal" href="../../ref/models/fields.html#django.db.models.ForeignKey" title="django.db.models.ForeignKey"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForeignKey</span></code></a> <a class="reference internal" href="managers.html#django.db.models.Manager" title="django.db.models.Manager"><code class="xref py py-class docutils literal notranslate"><span class="pre">Manager</span></code></a> はリレーション先オブジェクトのセットを処理するために使われる他のメソッドを持っています。それぞれの概略は以下の通りです。完全な詳細は <a class="reference internal" href="../../ref/models/relations.html"><span class="doc">リレーション先オブジェクトのリファレンス</span></a> で確認できます。</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">add(obj1,</span> <span class="pre">obj2,</span> <span class="pre">...)</span></code></dt><dd><p>指定したモデルオブジェクトをリレーション先オブジェクトのセットに追加します。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">create(**kwargs)</span></code></dt><dd><p>新しいオブジェクトを作成、保存して、リレーション先オブジェクトのセットに格納します。新しく作成されたオブジェクトを返します。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">remove(obj1,</span> <span class="pre">obj2,</span> <span class="pre">...)</span></code></dt><dd><p>リレーション先オブジェクトのセットから、指定したモデルオブジェクトを削除します。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">clear()</span></code></dt><dd><p>リレーション先オブジェクトのセットからすべてのオブジェクトを削除します。</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">set(objs)</span></code></dt><dd><p>リレーション先オブジェクトのセットを置き換えます。</p>
</dd>
</dl>
<p>リレーション先のセットのメンバーを代入するには、オブジェクトインスタンスのイテラブルとともに <code class="docutils literal notranslate"><span class="pre">set()</span></code> メソッドを使ってください。 例えば、<code class="docutils literal notranslate"><span class="pre">e1</span></code> と <code class="docutils literal notranslate"><span class="pre">e2</span></code> が <code class="docutils literal notranslate"><span class="pre">Entry</span></code> のインスタンスだとして:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">b</span> <span class="o">=</span> <span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">b</span><span class="o">.</span><span class="n">entry_set</span><span class="o">.</span><span class="n">set</span><span class="p">([</span><span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">])</span>
</pre></div>
</div>
<p>もし <code class="docutils literal notranslate"><span class="pre">clear()</span></code> メソッドが利用可能なら、既存のオブジェクトは <code class="docutils literal notranslate"><span class="pre">entry_set</span></code> から削除された後、イテラブル (この場合はリスト) のすべてのオブジェクトがセットに追加されます。もし <code class="docutils literal notranslate"><span class="pre">clear()</span></code> メソッドが利用可能 <em>でない</em> 場合は、既存の要素を削除することなく、イテラブル内のすべてのオブジェクトが追加されます。</p>
<p>このセクションで説明した &quot;逆方向&quot; の操作は、すべて即座にデータベースに反映されます。すべての追加、作成、削除の操作は自動的にデータベースに保存されます。</p>
</section>
</section>
<section id="s-many-to-many-relationships">
<span id="s-m2m-reverse-relationships"></span><span id="many-to-many-relationships"></span><span id="m2m-reverse-relationships"></span><h3>多対多 (many-to-many) 関係<a class="headerlink" href="#many-to-many-relationships" title="Link to this heading">¶</a></h3>
<p>多対多リレーションシップの両方の側で、もう片方に対する自動的な API アクセスを使えます。API は、上述の &quot;逆方向&quot; の1 対多リレーションシップと似た形で動作します。</p>
<p>一つの違いは属性の命名です。 <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ManyToManyField" title="django.db.models.ManyToManyField"><code class="xref py py-class docutils literal notranslate"><span class="pre">ManyToManyField</span></code></a> を定義するモデルでは、そのフィールドの属性名そのものを使いますが、&quot;逆&quot; モデルでは元のモデルの小文字のモデル名に <code class="docutils literal notranslate"><span class="pre">'_set'</span></code> を加えたものを使います (逆の一対多リレーションシップと同じです)。</p>
<p>例を挙げるとわかりやすいでしょう:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">e</span> <span class="o">=</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">e</span><span class="o">.</span><span class="n">authors</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>  <span class="c1"># Returns all Author objects for this Entry.</span>
<span class="n">e</span><span class="o">.</span><span class="n">authors</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>
<span class="n">e</span><span class="o">.</span><span class="n">authors</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">name__contains</span><span class="o">=</span><span class="s2">&quot;John&quot;</span><span class="p">)</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">Author</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="n">a</span><span class="o">.</span><span class="n">entry_set</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>  <span class="c1"># Returns all Entry objects for this Author.</span>
</pre></div>
</div>
<p><a class="reference internal" href="../../ref/models/fields.html#django.db.models.ForeignKey" title="django.db.models.ForeignKey"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForeignKey</span></code></a> と同様に、<a class="reference internal" href="../../ref/models/fields.html#django.db.models.ManyToManyField" title="django.db.models.ManyToManyField"><code class="xref py py-class docutils literal notranslate"><span class="pre">ManyToManyField</span></code></a> も <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ManyToManyField.related_name" title="django.db.models.ManyToManyField.related_name"><code class="xref py py-attr docutils literal notranslate"><span class="pre">related_name</span></code></a> を指定できます。上記の例で、もし <code class="docutils literal notranslate"><span class="pre">Entry</span></code> の <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ManyToManyField" title="django.db.models.ManyToManyField"><code class="xref py py-class docutils literal notranslate"><span class="pre">ManyToManyField</span></code></a> が <code class="docutils literal notranslate"><span class="pre">related_name='entries'</span></code> を指定していた場合、各 <code class="docutils literal notranslate"><span class="pre">Author</span></code> インスタンスは <code class="docutils literal notranslate"><span class="pre">entry_set</span></code> の代わりに <code class="docutils literal notranslate"><span class="pre">entries</span></code> 属性を持つことになります。</p>
<p>一対多のリレーションシップとのもう一つの違いは、モデルインスタンスに加えて、多対多のリレーションシップの <code class="docutils literal notranslate"><span class="pre">add()</span></code>, <code class="docutils literal notranslate"><span class="pre">set()</span></code>, <code class="docutils literal notranslate"><span class="pre">remove()</span></code> メソッドでもプライマリキーの値を受け付けることです。たとえば、 <code class="docutils literal notranslate"><span class="pre">e1</span></code> と <code class="docutils literal notranslate"><span class="pre">e2</span></code> が <code class="docutils literal notranslate"><span class="pre">Entry</span></code> インスタンスである場合、これらの <code class="docutils literal notranslate"><span class="pre">set()</span></code> 呼び出しは同じように動作します:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="n">Author</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="n">a</span><span class="o">.</span><span class="n">entry_set</span><span class="o">.</span><span class="n">set</span><span class="p">([</span><span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">])</span>
<span class="n">a</span><span class="o">.</span><span class="n">entry_set</span><span class="o">.</span><span class="n">set</span><span class="p">([</span><span class="n">e1</span><span class="o">.</span><span class="n">pk</span><span class="p">,</span> <span class="n">e2</span><span class="o">.</span><span class="n">pk</span><span class="p">])</span>
</pre></div>
</div>
</section>
<section id="s-one-to-one-relationships">
<span id="one-to-one-relationships"></span><h3>一対一 (one-to-one) 関係<a class="headerlink" href="#one-to-one-relationships" title="Link to this heading">¶</a></h3>
<p>一対一のリレーションシップは多対一のリレーションシップとよく似ています。モデルに <a class="reference internal" href="../../ref/models/fields.html#django.db.models.OneToOneField" title="django.db.models.OneToOneField"><code class="xref py py-class docutils literal notranslate"><span class="pre">OneToOneField</span></code></a> を定義すると、そのモデルのインスタンスはモデルの属性を介してリレーション先オブジェクトにアクセスできるようになります。</p>
<p>例:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">EntryDetail</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">entry</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">OneToOneField</span><span class="p">(</span><span class="n">Entry</span><span class="p">,</span> <span class="n">on_delete</span><span class="o">=</span><span class="n">models</span><span class="o">.</span><span class="n">CASCADE</span><span class="p">)</span>
    <span class="n">details</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">TextField</span><span class="p">()</span>


<span class="n">ed</span> <span class="o">=</span> <span class="n">EntryDetail</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">ed</span><span class="o">.</span><span class="n">entry</span>  <span class="c1"># Returns the related Entry object.</span>
</pre></div>
</div>
<p>違いは &quot;逆&quot; クエリにあります。一対一のリレーション先モデルも <a class="reference internal" href="managers.html#django.db.models.Manager" title="django.db.models.Manager"><code class="xref py py-class docutils literal notranslate"><span class="pre">Manager</span></code></a> オブジェクトにアクセスできますが、 <a class="reference internal" href="managers.html#django.db.models.Manager" title="django.db.models.Manager"><code class="xref py py-class docutils literal notranslate"><span class="pre">Manager</span></code></a> はオブジェクトのコレクションではなく、単一のオブジェクトを表します：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">e</span> <span class="o">=</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">e</span><span class="o">.</span><span class="n">entrydetail</span>  <span class="c1"># returns the related EntryDetail object</span>
</pre></div>
</div>
<p>このリレーションシップにオブジェクトが割り当てられていない場合、 Django は <code class="docutils literal notranslate"><span class="pre">DoesNotExist</span></code> 例外を発生させます。</p>
<p>インスタンスは、順方向のリレーションシップを割り当てるのと同じ方法で、逆方向のリレーションシップに割り当てることができます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">e</span><span class="o">.</span><span class="n">entrydetail</span> <span class="o">=</span> <span class="n">ed</span>
</pre></div>
</div>
</section>
<section id="s-how-are-the-backward-relationships-possible">
<span id="how-are-the-backward-relationships-possible"></span><h3>どうやって逆方向のリレーションシップを実現しているのか？<a class="headerlink" href="#how-are-the-backward-relationships-possible" title="Link to this heading">¶</a></h3>
<p>他のオブジェクトリレーショナルマッパでは、リレーションシップを両サイドで定義する必要があります。Django の開発陣はこれは DRY (Don't Repeat Yourself) の原則に反していると考えており、Django では片側でリレーションシップを定義する必要があるだけとなりました。</p>
<p>しかし、どのようにして実現しているのでしょうか? モデルクラスは、他のどのモデルクラスと関係しているのか、関係先のモデルクラスが読み込まれるまで分からないはずです。</p>
<p>答えは <a class="reference internal" href="../../ref/applications.html#django.apps.apps" title="django.apps.apps"><code class="xref py py-data docutils literal notranslate"><span class="pre">アプリレジストリ</span></code></a> にあります。Djangoが起動すると、<a class="reference internal" href="../../ref/settings.html#std-setting-INSTALLED_APPS"><code class="xref std std-setting docutils literal notranslate"><span class="pre">INSTALLED_APPS</span></code></a> に記載された各アプリケーションをインポートし、その後各アプリケーション内の <code class="docutils literal notranslate"><span class="pre">models</span></code> モジュールをインポートします。新しいモデルクラスが作成されるたびに、Djangoは関連するモデルに逆方向のリレーションシップを追加します。リレーション先のモデルがまだインポートされていない場合、Djangoはこのリレーションシップを追跡し、リレーション先のモデルが最終的にインポートされたときにそれらを追加します。</p>
<p>この理由により、<a class="reference internal" href="../../ref/settings.html#std-setting-INSTALLED_APPS"><code class="xref std std-setting docutils literal notranslate"><span class="pre">INSTALLED_APPS</span></code></a> にリストアップするアプリケーション内に、使おうとしているモデルをすべて定義することが特に重要となります。そうしないと、逆方向のリレーションシップがうまく動作しなくなります。</p>
</section>
<section id="s-queries-over-related-objects">
<span id="queries-over-related-objects"></span><h3>リレーション先オブジェクトをまたいだクエリ<a class="headerlink" href="#queries-over-related-objects" title="Link to this heading">¶</a></h3>
<p>リレーション先オブジェクトを含むクエリは、通常の値フィールドを含むクエリと同じルールに従います。クエリにマッチするための値を指定する際、オブジェクトインスタンス自体かオブジェクトのプライマリキー値のどちらかを使用します。</p>
<p>例えば、<code class="docutils literal notranslate"><span class="pre">id=5</span></code> の Blog オブジェクト <code class="docutils literal notranslate"><span class="pre">b</span></code> がある場合、以下の 3 つのクエリは同一となります:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">blog</span><span class="o">=</span><span class="n">b</span><span class="p">)</span>  <span class="c1"># Query using object instance</span>
<span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">blog</span><span class="o">=</span><span class="n">b</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>  <span class="c1"># Query using id from instance</span>
<span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">blog</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>  <span class="c1"># Query using id directly</span>
</pre></div>
</div>
</section>
</section>
<section id="s-falling-back-to-raw-sql">
<span id="falling-back-to-raw-sql"></span><h2>素の SQL にフォールバックする<a class="headerlink" href="#falling-back-to-raw-sql" title="Link to this heading">¶</a></h2>
<p>Django のデータベースマッパが扱うには複雑すぎる SQL クエリを記述する必要がある場合、手書きで SQL を書くことができます。Django には、素の SQL クエリを記述するための方法がいくつかあります。詳しくは <a class="reference internal" href="sql.html"><span class="doc">素の SQL 文の実行</span></a> を参照してください。</p>
<p>最後に、覚えておいてほしい重要な点は、Django のデータベースレイヤはあなたのデータベースに対する単なるインターフェースでしかないということです。あなたは、他のツール、プログラミング言語、データベースフレームワークなどを通じてデータベースを操作することもできます。データベースに関して Django 特有のことは何もありません。</p>
</section>
</section>


          </div>
        </div>
      </div>
      
        
          <div class="yui-b" id="sidebar">
            
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../../contents.html">目次</a></h3>
    <ul>
<li><a class="reference internal" href="#">クエリを作成する</a><ul>
<li><a class="reference internal" href="#creating-objects">オブジェクトを作成する</a></li>
<li><a class="reference internal" href="#saving-changes-to-objects">オブジェクトに対する変更を保存する</a><ul>
<li><a class="reference internal" href="#saving-foreignkey-and-manytomanyfield-fields"><code class="docutils literal notranslate"><span class="pre">ForeignKey</span></code> と <code class="docutils literal notranslate"><span class="pre">ManyToManyField</span></code> フィールドを扱う</a></li>
</ul>
</li>
<li><a class="reference internal" href="#retrieving-objects">オブジェクトを取得する</a><ul>
<li><a class="reference internal" href="#retrieving-all-objects">すべてのオブジェクトを取得する</a></li>
<li><a class="reference internal" href="#retrieving-specific-objects-with-filters">フィルタを使って特定のオブジェクトを取得する</a><ul>
<li><a class="reference internal" href="#chaining-filters">フィルタの連結</a></li>
<li><a class="reference internal" href="#filtered-querysets-are-unique">フィルタを適用した <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code> はユニーク</a></li>
<li><a class="reference internal" href="#querysets-are-lazy"><code class="docutils literal notranslate"><span class="pre">QuerySet</span></code> は遅延評価される</a></li>
</ul>
</li>
<li><a class="reference internal" href="#retrieving-a-single-object-with-get"><code class="docutils literal notranslate"><span class="pre">get()</span></code> を使って1つのオブジェクトを取得する</a></li>
<li><a class="reference internal" href="#other-queryset-methods">その他の <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code> メソッド</a></li>
<li><a class="reference internal" href="#limiting-querysets"><code class="docutils literal notranslate"><span class="pre">QuerySet</span></code> の要素数を制限する</a></li>
<li><a class="reference internal" href="#field-lookups">フィールドルックアップ</a></li>
<li><a class="reference internal" href="#lookups-that-span-relationships">リレーションシップを横断するルックアップ</a><ul>
<li><a class="reference internal" href="#spanning-multi-valued-relationships">複数の値を持つリレーションシップの横断</a></li>
</ul>
</li>
<li><a class="reference internal" href="#filters-can-reference-fields-on-the-model">フィルタはモデルのフィールドを参照できる</a></li>
<li><a class="reference internal" href="#expressions-can-reference-transforms">式はトランスフォーム（Transform）を参照できる</a></li>
<li><a class="reference internal" href="#the-pk-lookup-shortcut"><code class="docutils literal notranslate"><span class="pre">pk</span></code> ルックアップショートカット</a></li>
<li><a class="reference internal" href="#escaping-percent-signs-and-underscores-in-like-statements"><code class="docutils literal notranslate"><span class="pre">LIKE</span></code> 文の中ではパーセント記号とアンダースコアがエスケープされる</a></li>
<li><a class="reference internal" href="#caching-and-querysets">キャッシュと <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code></a><ul>
<li><a class="reference internal" href="#when-querysets-are-not-cached"><code class="docutils literal notranslate"><span class="pre">QuerySet</span></code> がキャッシュされないケース</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#asynchronous-queries">非同期クエリ</a><ul>
<li><a class="reference internal" href="#query-iteration">クエリの繰り返し（イテレーション）</a></li>
<li><a class="reference internal" href="#queryset-and-manager-methods"><code class="docutils literal notranslate"><span class="pre">QuerySet</span></code> とマネージャメソッド</a></li>
<li><a class="reference internal" href="#transactions">トランザクション</a></li>
</ul>
</li>
<li><a class="reference internal" href="#querying-jsonfield"><code class="docutils literal notranslate"><span class="pre">JSONField</span></code> へのクエリ</a><ul>
<li><a class="reference internal" href="#storing-and-querying-for-none"><code class="docutils literal notranslate"><span class="pre">None</span></code> の保存とクエリ</a></li>
<li><a class="reference internal" href="#key-index-and-path-transforms">キー、インデックス、パス（経路）のトランスフォーム（変換）</a><ul>
<li><a class="reference internal" href="#module-django.db.models.fields.json"><code class="docutils literal notranslate"><span class="pre">KT()</span></code> 式</a></li>
</ul>
</li>
<li><a class="reference internal" href="#containment-and-key-lookups"><code class="docutils literal notranslate"><span class="pre">contain</span></code> の概念とキーのルックアップ</a><ul>
<li><a class="reference internal" href="#contains"><code class="docutils literal notranslate"><span class="pre">contains</span></code></a></li>
<li><a class="reference internal" href="#contained-by"><code class="docutils literal notranslate"><span class="pre">contained_by</span></code></a></li>
<li><a class="reference internal" href="#has-key"><code class="docutils literal notranslate"><span class="pre">has_key</span></code></a></li>
<li><a class="reference internal" href="#has-keys"><code class="docutils literal notranslate"><span class="pre">has_keys</span></code></a></li>
<li><a class="reference internal" href="#has-any-keys"><code class="docutils literal notranslate"><span class="pre">has_any_keys</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#complex-lookups-with-q-objects"><code class="docutils literal notranslate"><span class="pre">Q</span></code> オブジェクトを使った複雑なルックアップ</a></li>
<li><a class="reference internal" href="#comparing-objects">オブジェクトを比較する</a></li>
<li><a class="reference internal" href="#deleting-objects">オブジェクトを削除する</a></li>
<li><a class="reference internal" href="#copying-model-instances">モデルのインスタンスを複製する</a></li>
<li><a class="reference internal" href="#updating-multiple-objects-at-once">複数のオブジェクトを一括で更新する</a></li>
<li><a class="reference internal" href="#related-objects">リレーション先のオブジェクト</a><ul>
<li><a class="reference internal" href="#one-to-many-relationships">一対多のリレーションシップ</a><ul>
<li><a class="reference internal" href="#forward">順方向のアクセス</a></li>
<li><a class="reference internal" href="#following-relationships-backward">&quot;逆方向&quot; のリレーションシップ</a></li>
<li><a class="reference internal" href="#using-a-custom-reverse-manager">カスタムのリバースマネージャを使う</a></li>
<li><a class="reference internal" href="#additional-methods-to-handle-related-objects">リレーション先オブジェクトを処理する他のメソッド</a></li>
</ul>
</li>
<li><a class="reference internal" href="#many-to-many-relationships">多対多 (many-to-many) 関係</a></li>
<li><a class="reference internal" href="#one-to-one-relationships">一対一 (one-to-one) 関係</a></li>
<li><a class="reference internal" href="#how-are-the-backward-relationships-possible">どうやって逆方向のリレーションシップを実現しているのか？</a></li>
<li><a class="reference internal" href="#queries-over-related-objects">リレーション先オブジェクトをまたいだクエリ</a></li>
</ul>
</li>
<li><a class="reference internal" href="#falling-back-to-raw-sql">素の SQL にフォールバックする</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>前のトピックへ</h4>
    <p class="topless"><a href="models.html"
                          title="前の章へ">モデル</a></p>
  </div>
  <div>
    <h4>次のトピックへ</h4>
    <p class="topless"><a href="aggregation.html"
                          title="次の章へ">アグリゲーション (集計)</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>このページ</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/topics/db/queries.txt"
            rel="nofollow">ソースコードを表示</a></li>
    </ul>
   </div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">クイック検索</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="検索" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
              <h3>Last update:</h3>
              <p class="topless">1月 22, 2025</p>
          </div>
        
      
    </div>

    <div id="ft">
      <div class="nav">
    &laquo; <a href="models.html" title="モデル">previous</a>
     |
    <a href="../index.html" title="Django を使う" accesskey="U">up</a>
   |
    <a href="aggregation.html" title="アグリゲーション (集計)">next</a> &raquo;</div>
    </div>
  </div>

      <div class="clearer"></div>
    </div>
  </body>
</html>