<!DOCTYPE html>

<html lang="ja" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>データベースのトランザクション &#8212; Django 5.1.6.dev20250122212402 ドキュメント</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=34bb78ad" />
    <link rel="stylesheet" type="text/css" href="../../_static/default.css?v=bf4d74af" />
    <script src="../../_static/documentation_options.js?v=d2885b0a"></script>
    <script src="../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/translations.js?v=4755f45a"></script>
    <link rel="index" title="索引" href="../../genindex.html" />
    <link rel="search" title="検索" href="../../search.html" />
    <link rel="next" title="複数のデータベース" href="multi-db.html" />
    <link rel="prev" title="素の SQL 文の実行" href="sql.html" />



 
<script src="../../templatebuiltins.js"></script>
<script>
(function($) {
    if (!django_template_builtins) {
       // templatebuiltins.js missing, do nothing.
       return;
    }
    $(document).ready(function() {
        // Hyperlink Django template tags and filters
        var base = "../../ref/templates/builtins.html";
        if (base == "#") {
            // Special case for builtins.html itself
            base = "";
        }
        // Tags are keywords, class '.k'
        $("div.highlight\\-html\\+django span.k").each(function(i, elem) {
             var tagname = $(elem).text();
             if ($.inArray(tagname, django_template_builtins.ttags) != -1) {
                 var fragment = tagname.replace(/_/, '-');
                 $(elem).html("<a href='" + base + "#" + fragment + "'>" + tagname + "</a>");
             }
        });
        // Filters are functions, class '.nf'
        $("div.highlight\\-html\\+django span.nf").each(function(i, elem) {
             var filtername = $(elem).text();
             if ($.inArray(filtername, django_template_builtins.tfilters) != -1) {
                 var fragment = filtername.replace(/_/, '-');
                 $(elem).html("<a href='" + base + "#" + fragment + "'>" + filtername + "</a>");
             }
        });
    });
})(jQuery);</script>

  </head><body>

    <div class="document">
  <div id="custom-doc" class="yui-t6">
    <div id="hd">
      <h1><a href="../../index.html">Django 5.1.6.dev20250122212402 ドキュメント</a></h1>
      <div id="global-nav">
        <a title="Home page" href="../../index.html">Home</a>  |
        <a title="Table of contents" href="../../contents.html">Table of contents</a>  |
        <a title="Global index" href="../../genindex.html">Index</a>  |
        <a title="Module index" href="../../py-modindex.html">Modules</a>
      </div>
      <div class="nav">
    &laquo; <a href="sql.html" title="素の SQL 文の実行">previous</a>
     |
    <a href="../index.html" title="Django を使う" accesskey="U">up</a>
   |
    <a href="multi-db.html" title="複数のデータベース">next</a> &raquo;</div>
    </div>

    <div id="bd">
      <div id="yui-main">
        <div class="yui-b">
          <div class="yui-g" id="topics-db-transactions">
            
  <section id="s-module-django.db.transaction">
<span id="s-database-transactions"></span><span id="module-django.db.transaction"></span><span id="database-transactions"></span><h1>データベースのトランザクション<a class="headerlink" href="#module-django.db.transaction" title="Link to this heading">¶</a></h1>
<p>Django では、データベースのトランザクションをコントロールする方法が提供されています。</p>
<section id="s-managing-database-transactions">
<span id="managing-database-transactions"></span><h2>データベースのトランザクションを管理する<a class="headerlink" href="#managing-database-transactions" title="Link to this heading">¶</a></h2>
<section id="s-django-s-default-transaction-behavior">
<span id="django-s-default-transaction-behavior"></span><h3>Django のデフォルトのトランザクションの動作<a class="headerlink" href="#django-s-default-transaction-behavior" title="Link to this heading">¶</a></h3>
<p>Django のデフォルトの動作は、オートコミットモードで実行することです。トランザクションがアクティブでない限り、各クエリは即座にデータベースにコミットされます。<a class="reference internal" href="#autocommit-details"><span class="std std-ref">詳しくは下記を参照してください</span></a>。</p>
<p>Django は、自動的にトランザクションやセーブポイントを使い、特に <a class="reference internal" href="queries.html#topics-db-queries-delete"><span class="std std-ref">delete()</span></a> と <a class="reference internal" href="queries.html#topics-db-queries-update"><span class="std std-ref">update()</span></a> クエリにおいて、複数のクエリを要求する ORM 操作の信頼性を担保します。</p>
<p>Django の <a class="reference internal" href="../testing/tools.html#django.test.TestCase" title="django.test.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> クラスは、パフォーマンス向上のため、各テストをトランザクションでラップします。</p>
</section>
<section id="s-tying-transactions-to-http-requests">
<span id="s-id1"></span><span id="tying-transactions-to-http-requests"></span><span id="id1"></span><h3>HTTP リクエストにトランザクションを結びつける<a class="headerlink" href="#tying-transactions-to-http-requests" title="Link to this heading">¶</a></h3>
<p>ウェブ上でトランザクションを扱う一般的な方法は、各リクエストをトランザクションでラップすることです。この動作を有効化したい各データベースの設定で、<a class="reference internal" href="../../ref/settings.html#std-setting-DATABASE-ATOMIC_REQUESTS"><code class="xref std std-setting docutils literal notranslate"><span class="pre">ATOMIC_REQUESTS</span></code></a> を <code class="docutils literal notranslate"><span class="pre">True</span></code> にセットしてください。</p>
<p>これは、次のように動作します。まず、ビュー関数を呼び出す前に、Django はトランザクションを開始します。レスポンスが問題なく生成された場合は、Django はトランザクションをコミットします。もしビューが例外を生成した場合は、Django はトランザクションをロールバックします。</p>
<p>ビューのコード (通常は <a class="reference internal" href="#django.db.transaction.atomic" title="django.db.transaction.atomic"><code class="xref py py-func docutils literal notranslate"><span class="pre">atomic()</span></code></a> コンテキストマネージャー) の中で、セーブポイントを使ったサブトランザクションを扱うことができます。ただし、ビューの最後では、すべての変更がコミットされるか、何もコミットされないかのどちらかです。</p>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>このトランザクションモデルは簡潔ではありますが、トラフィックが増加するときには非効率となります。全てのビューでトランザクションを扱うとオーバーヘッドが増加します。パフォーマンスへの影響は、アプリケーションのクエリパターンと、どれだけうまくデータベースがロッキングを扱うかに依存します。</p>
</div>
<div class="admonition-per-request-transactions-and-streaming-responses admonition">
<p class="admonition-title">リクエストごとのトランザクションとストリーミングレスポンス</p>
<p>ビューが <a class="reference internal" href="../../ref/request-response.html#django.http.StreamingHttpResponse" title="django.http.StreamingHttpResponse"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamingHttpResponse</span></code></a> を返すとき、レスポンスの内容読み出しが内容を生成するためのコードを実行することがあります。ビューはすでに返されているので、このコードはトランザクションの外で走ります。</p>
<p>一般的に言って、ストリーミングレスポンスが生成されている間はデータベースに書き込みすることは推奨されません。レスポンスを送信開始した後にエラーを扱う適切な方法が存在しないからです。</p>
</div>
<p>実際には、この機能はすべてのビュー関数を以下で説明する <a class="reference internal" href="#django.db.transaction.atomic" title="django.db.transaction.atomic"><code class="xref py py-func docutils literal notranslate"><span class="pre">atomic()</span></code></a> デコレータでラップします。</p>
<p>あなたのビューの実行だけがトランザクションで閉じられることに注意してください。ミドルウェアはトランザクションの外で実行し、テンプレートレスポンスのレンダリングを実行します。</p>
<p><a class="reference internal" href="../../ref/settings.html#std-setting-DATABASE-ATOMIC_REQUESTS"><code class="xref std std-setting docutils literal notranslate"><span class="pre">ATOMIC_REQUESTS</span></code></a> が有効な場合、ビューがトランザクション内で実行するのを防ぐことができます。</p>
<dl class="py function">
<dt class="sig sig-object py" id="django.db.transaction.non_atomic_requests">
<span class="sig-name descname"><span class="pre">non_atomic_requests</span></span>(<em class="sig-param"><span class="n"><span class="pre">using</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>)<a class="reference external" href="https://github.com/django/django/blob/stable/5.1.x/django/db/transaction.py#L334"><span class="viewcode-link"><span class="pre">[ソース]</span></span></a><a class="headerlink" href="#django.db.transaction.non_atomic_requests" title="Link to this definition">¶</a></dt>
<dd><p>このデコレータは、与えられたビューのために <a class="reference internal" href="../../ref/settings.html#std-setting-DATABASE-ATOMIC_REQUESTS"><code class="xref std std-setting docutils literal notranslate"><span class="pre">ATOMIC_REQUESTS</span></code></a> を無効化します。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">django.db</span><span class="w"> </span><span class="kn">import</span> <span class="n">transaction</span>


<span class="nd">@transaction</span><span class="o">.</span><span class="n">non_atomic_requests</span>
<span class="k">def</span><span class="w"> </span><span class="nf">my_view</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="n">do_stuff</span><span class="p">()</span>


<span class="nd">@transaction</span><span class="o">.</span><span class="n">non_atomic_requests</span><span class="p">(</span><span class="n">using</span><span class="o">=</span><span class="s2">&quot;other&quot;</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">my_other_view</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="n">do_stuff_on_the_other_database</span><span class="p">()</span>
</pre></div>
</div>
<p>ビュー自身に適用される場合にのみ作動します。</p>
</dd></dl>

</section>
<section id="s-controlling-transactions-explicitly">
<span id="controlling-transactions-explicitly"></span><h3>明示的にトランザクションをコントロールする<a class="headerlink" href="#controlling-transactions-explicitly" title="Link to this heading">¶</a></h3>
<p>Django は、データベーストランザクションをコントロールするための一つの API を提供しています。</p>
<dl class="py function">
<dt class="sig sig-object py" id="django.db.transaction.atomic">
<span class="sig-name descname"><span class="pre">atomic</span></span>(<em class="sig-param"><span class="n"><span class="pre">using</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">savepoint</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">durable</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>)<a class="reference external" href="https://github.com/django/django/blob/stable/5.1.x/django/db/transaction.py#L316"><span class="viewcode-link"><span class="pre">[ソース]</span></span></a><a class="headerlink" href="#django.db.transaction.atomic" title="Link to this definition">¶</a></dt>
<dd><p>Atomicityは、データベーストランザクションの定義プロパティです。<code class="docutils literal notranslate"><span class="pre">atomic</span></code> は、データベースの atomicity が保証されるコードブロックを作成することを可能にします。 コードブロックが正常に完了すると、変更はデータベースにコミットされます。 例外がある場合、変更はロールバックされます。</p>
<p><code class="docutils literal notranslate"><span class="pre">atomic</span></code> のブロックはネスト可能です。この場合、内側のブロックが成功裏に完了しても、その効果は後で外側のブロックで例外が発生した場合にロールバック可能となっています。</p>
<p>アトミックなブロックを常に一番外側のアトミックなブロックにすることで、そのブロックがエラーにならずに終了したときにデータベースの変更がコミットされるようにすると便利なことがあります。これは耐久性 (durability) と呼ばれ、 <code class="docutils literal notranslate"><span class="pre">durable=True</span></code> を設定することで実現できます。もし <code class="docutils literal notranslate"><span class="pre">atomic</span></code> ブロックが他のブロックの中に入れ子になっている場合、 <code class="docutils literal notranslate"><span class="pre">RuntimeError</span></code> が発生します。</p>
<p><code class="docutils literal notranslate"><span class="pre">atomic</span></code> は、<a class="reference external" href="https://docs.python.org/3/glossary.html#term-decorator" title="(in Python v3.13)"><span class="xref std std-term">decorator</span></a> として使用することも:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">django.db</span><span class="w"> </span><span class="kn">import</span> <span class="n">transaction</span>


<span class="nd">@transaction</span><span class="o">.</span><span class="n">atomic</span>
<span class="k">def</span><span class="w"> </span><span class="nf">viewfunc</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="c1"># This code executes inside a transaction.</span>
    <span class="n">do_stuff</span><span class="p">()</span>
</pre></div>
</div>
<p><a class="reference external" href="https://docs.python.org/3/glossary.html#term-context-manager" title="(in Python v3.13)"><span class="xref std std-term">context manager</span></a> として使用することも可能です:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">django.db</span><span class="w"> </span><span class="kn">import</span> <span class="n">transaction</span>


<span class="k">def</span><span class="w"> </span><span class="nf">viewfunc</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="c1"># This code executes in autocommit mode (Django&#39;s default).</span>
    <span class="n">do_stuff</span><span class="p">()</span>

    <span class="k">with</span> <span class="n">transaction</span><span class="o">.</span><span class="n">atomic</span><span class="p">():</span>
        <span class="c1"># This code executes inside a transaction.</span>
        <span class="n">do_more_stuff</span><span class="p">()</span>
</pre></div>
</div>
<p>try/except ブロック内で <code class="docutils literal notranslate"><span class="pre">atomic</span></code> をラップすると、integrity error を自然な形で処理できます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">django.db</span><span class="w"> </span><span class="kn">import</span> <span class="n">IntegrityError</span><span class="p">,</span> <span class="n">transaction</span>


<span class="nd">@transaction</span><span class="o">.</span><span class="n">atomic</span>
<span class="k">def</span><span class="w"> </span><span class="nf">viewfunc</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="n">create_parent</span><span class="p">()</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="k">with</span> <span class="n">transaction</span><span class="o">.</span><span class="n">atomic</span><span class="p">():</span>
            <span class="n">generate_relationships</span><span class="p">()</span>
    <span class="k">except</span> <span class="n">IntegrityError</span><span class="p">:</span>
        <span class="n">handle_exception</span><span class="p">()</span>

    <span class="n">add_children</span><span class="p">()</span>
</pre></div>
</div>
<p>この例では、 <code class="docutils literal notranslate"><span class="pre">generate_relationships()</span></code> が整合性制約を破ってデータベースエラーを起こしたとしても、 <code class="docutils literal notranslate"><span class="pre">add_children()</span></code> でクエリを実行でき、 <code class="docutils literal notranslate"><span class="pre">create_parent()</span></code> での変更はそのまま同じトランザクションにバインドされます。 <code class="docutils literal notranslate"><span class="pre">generate_relationships()</span></code> 内での試行は、<code class="docutils literal notranslate"><span class="pre">handle_exception()</span></code> が呼び出された時点ですでに安全にロールバックされていることに留意してください。したがって、必要に応じてデータベース上で例外ハンドラを使用できます。</p>
<div class="admonition-avoid-catching-exceptions-inside-atomic admonition">
<p class="admonition-title"><code class="docutils literal notranslate"><span class="pre">atomic</span></code> の内部で例外をキャッチしない！</p>
<p><code class="docutils literal notranslate"><span class="pre">atomic</span></code> ブロックの処理を終える際、Django は通常の終了なのか例外を伴うのかを見て、コミットするかロールバックするかを決定します。<code class="docutils literal notranslate"><span class="pre">atomic</span></code> ブロック内で例外をキャッチしてハンドする場合、Django に対して問題が発生したことを隠すことになります。これは予期しない動作の原因となります。</p>
<p>この挙動は、<a class="reference internal" href="../../ref/exceptions.html#django.db.DatabaseError" title="django.db.DatabaseError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DatabaseError</span></code></a> およびそのサブクラス　(<a class="reference internal" href="../../ref/exceptions.html#django.db.IntegrityError" title="django.db.IntegrityError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">IntegrityError</span></code></a> など) に対する懸念となります。こうしたエラーが起きた場合、Djangoは <code class="docutils literal notranslate"><span class="pre">atomic</span></code> ブロックの最後にロー路バックを実施します。ロールバックが発生する前にデータベースクエリを実行しようとすると、Django は <a class="reference internal" href="../../ref/exceptions.html#django.db.transaction.TransactionManagementError" title="django.db.transaction.TransactionManagementError"><code class="xref py py-class docutils literal notranslate"><span class="pre">TransactionManagementError</span></code></a> を送出します。ORM 関連のシグナルハンドラが例外を送出した際にも同様の挙動となります。</p>
<p>データベースエラーをキャッチする正しい方法は、上記で示した通りの <code class="docutils literal notranslate"><span class="pre">atomic</span></code> ブロックです。必要に応じてさらに <code class="docutils literal notranslate"><span class="pre">atomic</span></code> ブロックを追加してください。このパターンはもう一つのメリットがあります: 例外が発生した場合にどの操作がロールバックされるかを限定できることです。</p>
<p>素の SQL クエリによって発生した例外をキャッチした場合、Django の挙動は決まっておらず、データベースに依存します。</p>
</div>
<div class="admonition-you-may-need-to-manually-revert-app-state-when-rolling-back-a-transaction admonition">
<p class="admonition-title">トランザクションをロールバックする際、アプリの状態を手動で戻す必要がある場合があります。</p>
<p>トランザクションのロールバックが発生しても、モデルのフィールドの値は元に戻りません。これは、手動で元のフィールドの値を復元しない限り、一貫性のないモデルの状態につながる可能性があります。</p>
<p>たとえば、<code class="docutils literal notranslate"><span class="pre">active</span></code> フィールドを持つ <code class="docutils literal notranslate"><span class="pre">MyModel</span></code> が与えられた場合、以下のコードはトランザクション内で <code class="docutils literal notranslate"><span class="pre">active</span></code> の <code class="docutils literal notranslate"><span class="pre">True</span></code> への更新が失敗した場合に、最後の <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">obj.active</span></code> チェックで正しい値が使用されることを保証します:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">django.db</span><span class="w"> </span><span class="kn">import</span> <span class="n">DatabaseError</span><span class="p">,</span> <span class="n">transaction</span>

<span class="n">obj</span> <span class="o">=</span> <span class="n">MyModel</span><span class="p">(</span><span class="n">active</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">obj</span><span class="o">.</span><span class="n">active</span> <span class="o">=</span> <span class="kc">True</span>
<span class="k">try</span><span class="p">:</span>
    <span class="k">with</span> <span class="n">transaction</span><span class="o">.</span><span class="n">atomic</span><span class="p">():</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
<span class="k">except</span> <span class="n">DatabaseError</span><span class="p">:</span>
    <span class="n">obj</span><span class="o">.</span><span class="n">active</span> <span class="o">=</span> <span class="kc">False</span>

<span class="k">if</span> <span class="n">obj</span><span class="o">.</span><span class="n">active</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>これはキャッシュやグローバル変数など、アプリの状態を保持する他のメカニズムにも当てはまります。たとえば、コードがオブジェクトを保存した後にキャッシュ内のデータを積極的に更新する場合、トランザクションが実際にコミットされるまでキャッシュの改変を延期するために、代わりに <a class="reference internal" href="#performing-actions-after-commit"><span class="std std-ref">transaction.on_commit()</span></a> を使用することを推奨します。</p>
</div>
<p>アトミックを保証するために、<code class="docutils literal notranslate"><span class="pre">atomic</span></code> はいくつかの API を無効にします。アトミックな <code class="docutils literal notranslate"><span class="pre">atomic</span></code> ブロック内で、データベースコネクションのコミット、ロールバック、または自動コミットの状態を変更しようとすると、例外が発生します。</p>
<p><code class="docutils literal notranslate"><span class="pre">atomic</span></code> は <code class="docutils literal notranslate"><span class="pre">using</span></code> 引数を取り、データベース名を指定します。この引数が与えられない場合、 Django は <code class="docutils literal notranslate"><span class="pre">&quot;default&quot;</span></code> データベースを使用します。</p>
<p>以下の通り、Djangoのトランザクション管理コードは、:</p>
<ul class="simple">
<li><p>一番外側のアトミックブロックに入るときにトランザクションを開きます;</p></li>
<li><p>内側のアトミックブロックに入るときにセーブポイントを作成します;</p></li>
<li><p>内側のブロックを抜けるときに、セーブポイントを解放するかロールバックします;</p></li>
<li><p>一番外側のブロックを抜けるときに、トランザクションをコミットするかロールバック します。</p></li>
</ul>
<p>引数 <code class="docutils literal notranslate"><span class="pre">savepoint</span></code> を <code class="docutils literal notranslate"><span class="pre">False</span></code> に設定することで、内部ブロックのセーブポイン トの作成を無効にできます。例外が発生した場合、 Django はセーブポイントがあれば最初の親ブロックを、なければ一番外側のブロックを終了するときにロールバックを行います。原子性は外側のトランザクションで保証されたままです。このオプションは、セーブポイントのオーバーヘッドが目立つ場合にのみ使うべきです。このオプションには、上述のエラー処理を壊してしまうという欠点があります。</p>
<p>オートコミットがオフの場合は <code class="docutils literal notranslate"><span class="pre">atomic</span></code> を使用できます。一番外側のブロックであっても、セーブポイントだけを使用します。</p>
</dd></dl>

<div class="admonition-performance-considerations admonition">
<p class="admonition-title">パフォーマンスに関する注意事項</p>
<p>オープン中のトランザクションは、データベース・サーバーにとってパフォーマンス・コストとなります。このオーバヘッドを最小にするために、トランザクションはできるだけ短くしてください。これは特に、 Django のリクエスト/レスポンスサイクル以外の、長時間実行するプロセスで <a class="reference internal" href="#django.db.transaction.atomic" title="django.db.transaction.atomic"><code class="xref py py-func docutils literal notranslate"><span class="pre">atomic()</span></code></a> を使っている場合に重要です。</p>
</div>
</section>
</section>
<section id="s-autocommit">
<span id="autocommit"></span><h2>自動コミット<a class="headerlink" href="#autocommit" title="Link to this heading">¶</a></h2>
<section id="s-why-django-uses-autocommit">
<span id="s-autocommit-details"></span><span id="why-django-uses-autocommit"></span><span id="autocommit-details"></span><h3>なぜ Django は自動コミットを使うのか<a class="headerlink" href="#why-django-uses-autocommit" title="Link to this heading">¶</a></h3>
<p>標準SQLでは、SQLクエリはそれぞれトランザクションを開始します。そのようなトランザクションは、明示的にコミットするかロールバックしなければなりません。</p>
<p>これはアプリケーション開発者にとっては必ずしも便利ではありません。この問題を軽減するために、ほとんどのデータベースは自動コミットモードを提供しています。オートコミットが有効でトランザクションがアクティブでない場合、各 SQL クエリは独自のトランザクションに包まれます。言い換えると、それぞれのクエリがトランザクションを開始するだけでなく、クエリが成功したかどうかに応じて、トランザクションも自動的にコミットまたはロールバックされます。</p>
<p><span class="target" id="index-6"></span><a class="pep reference external" href="https://peps.python.org/pep-0249/"><strong>PEP 249</strong></a>, Python Database API Specification v2.0 では、オートコミッ トは初期状態ではオフになっている必要があります。Django はこのデフォルトを上書きし、自動コミットをオンにします。</p>
<p>これを避けるために、 <a class="reference internal" href="#deactivate-transaction-management"><span class="std std-ref">トランザクション管理</span></a> を無効にすることもできますが、推奨されません。</p>
</section>
<section id="s-deactivating-transaction-management">
<span id="s-deactivate-transaction-management"></span><span id="deactivating-transaction-management"></span><span id="deactivate-transaction-management"></span><h3>トランザクション管理を無効化する<a class="headerlink" href="#deactivating-transaction-management" title="Link to this heading">¶</a></h3>
<p>データベースの設定で <a class="reference internal" href="../../ref/settings.html#std-setting-DATABASE-AUTOCOMMIT"><code class="xref std std-setting docutils literal notranslate"><span class="pre">AUTOCOMMIT</span></code></a> を <code class="docutils literal notranslate"><span class="pre">False</span></code> にすると、Django のトランザクション管理を完全に無効にできます。こうすると、 Django は自動コミットを有効にせず、コミットも行いません。基礎となるデータベースライブラリの通常の動作になります。</p>
<p>この場合、Django やサードパーティのライブラリで開始されたトランザクションであっても、全てのトランザクションを明示的にコミットする必要があります。したがって、これは独自のトランザクション制御ミドルウェアを実行したい場合や、本当に変わったことをしたい場合に最適な方法です。</p>
</section>
</section>
<section id="s-performing-actions-after-commit">
<span id="s-id2"></span><span id="performing-actions-after-commit"></span><span id="id2"></span><h2>コミット後にアクションを実行する<a class="headerlink" href="#performing-actions-after-commit" title="Link to this heading">¶</a></h2>
<p>現在のデータベーストランザクションに関連するアクションを実行する必要があるが、トランザクションが正常にコミットされた場合にだけ実行したいことがあります。たとえば、バックグラウンドタスク、メール通知、キャッシュの無効化などが考えられます。</p>
<p><a class="reference internal" href="#django.db.transaction.on_commit" title="django.db.transaction.on_commit"><code class="xref py py-func docutils literal notranslate"><span class="pre">on_commit()</span></code></a> では、オープンしたトランザクションが正常にコミットされた後に実行されるコールバックを登録できます:</p>
<dl class="py function">
<dt class="sig sig-object py" id="django.db.transaction.on_commit">
<span class="sig-name descname"><span class="pre">on_commit</span></span>(<em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">using</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">robust</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>)<a class="reference external" href="https://github.com/django/django/blob/stable/5.1.x/django/db/transaction.py#L129"><span class="viewcode-link"><span class="pre">[ソース]</span></span></a><a class="headerlink" href="#django.db.transaction.on_commit" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<p><a class="reference internal" href="#django.db.transaction.on_commit" title="django.db.transaction.on_commit"><code class="xref py py-func docutils literal notranslate"><span class="pre">on_commit()</span></code></a>: に関数または callable (呼び出し可能オブジェクト) を渡します:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">django.db</span><span class="w"> </span><span class="kn">import</span> <span class="n">transaction</span>


<span class="k">def</span><span class="w"> </span><span class="nf">send_welcome_email</span><span class="p">():</span> <span class="o">...</span>


<span class="n">transaction</span><span class="o">.</span><span class="n">on_commit</span><span class="p">(</span><span class="n">send_welcome_email</span><span class="p">)</span>
</pre></div>
</div>
<p>コールバックには引数は渡されませんが、 <a class="reference external" href="https://docs.python.org/3/library/functools.html#functools.partial" title="(in Python v3.13)"><code class="xref py py-func docutils literal notranslate"><span class="pre">functools.partial()</span></code></a> で渡すことができます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">functools</span><span class="w"> </span><span class="kn">import</span> <span class="n">partial</span>

<span class="k">for</span> <span class="n">user</span> <span class="ow">in</span> <span class="n">users</span><span class="p">:</span>
    <span class="n">transaction</span><span class="o">.</span><span class="n">on_commit</span><span class="p">(</span><span class="n">partial</span><span class="p">(</span><span class="n">send_invite_email</span><span class="p">,</span> <span class="n">user</span><span class="o">=</span><span class="n">user</span><span class="p">))</span>
</pre></div>
</div>
<p>コールバックはオープンしたトランザクションが正常にコミットされた後に呼び出されます。トランザクションがロールバックされた場合（通常は <a class="reference internal" href="#django.db.transaction.atomic" title="django.db.transaction.atomic"><code class="xref py py-func docutils literal notranslate"><span class="pre">atomic()</span></code></a> ブロックで例外を発生させた場合）、コールバックは破棄され、呼び出されることはありません。</p>
<p>トランザクションがオープンされていない状態で <code class="docutils literal notranslate"><span class="pre">on_commit()</span></code> を呼び出すと、コールバックはすぐに実行されます。</p>
<p>失敗する可能性のあるコールバックを登録すると便利なことがあります。 <code class="docutils literal notranslate"><span class="pre">robust=True</span></code> を渡すと、現在のコールバックが例外をスローしても、次のコールバックを実行できます。Python の <code class="docutils literal notranslate"><span class="pre">Exception</span></code> クラスに由来するエラーはすべて捕捉され、 <code class="docutils literal notranslate"><span class="pre">django.db.backends.base</span></code> ロガーに記録されます。</p>
<p><a class="reference internal" href="#django.db.transaction.on_commit" title="django.db.transaction.on_commit"><code class="xref py py-func docutils literal notranslate"><span class="pre">on_commit()</span></code></a> で登録されたコールバックをテストするには <a class="reference internal" href="../testing/tools.html#django.test.TestCase.captureOnCommitCallbacks" title="django.test.TestCase.captureOnCommitCallbacks"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TestCase.captureOnCommitCallbacks()</span></code></a> を使用します。</p>
<section id="s-savepoints">
<span id="savepoints"></span><h3>セーブポイント<a class="headerlink" href="#savepoints" title="Link to this heading">¶</a></h3>
<p>セーブポイント（ネストされた <a class="reference internal" href="#django.db.transaction.atomic" title="django.db.transaction.atomic"><code class="xref py py-func docutils literal notranslate"><span class="pre">atomic()</span></code></a> ブロック）は正しく処理されます。つまり、(入れ子になった <a class="reference internal" href="#django.db.transaction.atomic" title="django.db.transaction.atomic"><code class="xref py py-func docutils literal notranslate"><span class="pre">atomic()</span></code></a> ブロック内の) セーブポイントの後に登録された <a class="reference internal" href="#django.db.transaction.on_commit" title="django.db.transaction.on_commit"><code class="xref py py-func docutils literal notranslate"><span class="pre">on_commit()</span></code></a> callable は、外側のトランザクションがコミットされた後に呼び出されます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">transaction</span><span class="o">.</span><span class="n">atomic</span><span class="p">():</span>  <span class="c1"># Outer atomic, start a new transaction</span>
    <span class="n">transaction</span><span class="o">.</span><span class="n">on_commit</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span>

    <span class="k">with</span> <span class="n">transaction</span><span class="o">.</span><span class="n">atomic</span><span class="p">():</span>  <span class="c1"># Inner atomic block, create a savepoint</span>
        <span class="n">transaction</span><span class="o">.</span><span class="n">on_commit</span><span class="p">(</span><span class="n">bar</span><span class="p">)</span>

<span class="c1"># foo() and then bar() will be called when leaving the outermost block</span>
</pre></div>
</div>
<p>一方、（例外が発生して）セーブポイントがロールバックされると、内部の callable は呼び出されません:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">transaction</span><span class="o">.</span><span class="n">atomic</span><span class="p">():</span>  <span class="c1"># Outer atomic, start a new transaction</span>
    <span class="n">transaction</span><span class="o">.</span><span class="n">on_commit</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="k">with</span> <span class="n">transaction</span><span class="o">.</span><span class="n">atomic</span><span class="p">():</span>  <span class="c1"># Inner atomic block, create a savepoint</span>
            <span class="n">transaction</span><span class="o">.</span><span class="n">on_commit</span><span class="p">(</span><span class="n">bar</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">SomeError</span><span class="p">()</span>  <span class="c1"># Raising an exception - abort the savepoint</span>
    <span class="k">except</span> <span class="n">SomeError</span><span class="p">:</span>
        <span class="k">pass</span>

<span class="c1"># foo() will be called, but not bar()</span>
</pre></div>
</div>
</section>
<section id="s-order-of-execution">
<span id="order-of-execution"></span><h3>実行順<a class="headerlink" href="#order-of-execution" title="Link to this heading">¶</a></h3>
<p>トランザクションの On-commit 関数は、登録された順に実行されます。</p>
</section>
<section id="s-exception-handling">
<span id="exception-handling"></span><h3>例外のハンドリング<a class="headerlink" href="#exception-handling" title="Link to this heading">¶</a></h3>
<p>あるトランザクション内で <code class="docutils literal notranslate"><span class="pre">robust=False</span></code> で登録された on-commit 関数が例外を発生させた場合、同じトランザクション内でそれ以降に登録された関数は実行されません。これは <a class="reference internal" href="#django.db.transaction.on_commit" title="django.db.transaction.on_commit"><code class="xref py py-func docutils literal notranslate"><span class="pre">on_commit()</span></code></a> なしで関数を順番に実行した場合と同じ動作です。</p>
</section>
<section id="s-timing-of-execution">
<span id="timing-of-execution"></span><h3>実行タイミング<a class="headerlink" href="#timing-of-execution" title="Link to this heading">¶</a></h3>
<p>コールバックはコミットが成功した <em>後に</em> 実行されるので、コールバックに失敗してもトランザクションがロールバックされることはありません。コールバックはトランザクションの成功時に条件付きで実行されますが、トランザクションの <em>一部</em> ではありません。想定される使用例（メール通知、バックグラウンドタスクなど）では、これで問題ないでしょう。もしそうでなければ（フォローアップアクションが非常にクリティカルで、その失敗がトランザクション自体の失敗を意味するのであれば）、 <a class="reference internal" href="#django.db.transaction.on_commit" title="django.db.transaction.on_commit"><code class="xref py py-func docutils literal notranslate"><span class="pre">on_commit()</span></code></a> フックを使うべきではありません。その代わりに、 <a class="reference external" href="https://www.psycopg.org/psycopg3/docs/basic/transactions.html#two-phase-commit" title="(in psycopg)"><span class="xref std std-ref">psycopg Two-Phase Commit protocol support</span></a> や <span class="target" id="index-7"></span><a class="pep reference external" href="https://peps.python.org/pep-0249/#optional-two-phase-commit-extensions"><strong>optional Two-Phase Commit Extensions in the Python DB-API specification</strong></a> のような <a class="reference external" href="https://en.wikipedia.org/wiki/Two-phase_commit_protocol">two-phase commit</a> が必要かもしれません。</p>
<p>コールバックは、コミット後のコネクションでオートコミットがリストアされるまで実行されません (そうしないと、コールバックで実行されたクエリが暗黙のトランザクションをオープンしてしまい、コネクションが自動コミットモードに戻るのを防いでしまうからです)。</p>
<p>自動コミットモードで <a class="reference internal" href="#django.db.transaction.atomic" title="django.db.transaction.atomic"><code class="xref py py-func docutils literal notranslate"><span class="pre">atomic()</span></code></a> ブロックの外にある場合、関数はコミット時ではなく即座に実行されます。</p>
<p>on-commit 関数は <a class="reference internal" href="#managing-autocommit"><span class="std std-ref">autocommit mode</span></a> と <a class="reference internal" href="#django.db.transaction.atomic" title="django.db.transaction.atomic"><code class="xref py py-func docutils literal notranslate"><span class="pre">atomic()</span></code></a> (または <a class="reference internal" href="../../ref/settings.html#std-setting-DATABASE-ATOMIC_REQUESTS"><code class="xref std std-setting docutils literal notranslate"><span class="pre">ATOMIC_REQUESTS</span></code></a>) トランザクション API でのみ動作します。オートコミットが無効でアトミックブロック内にいない時に <a class="reference internal" href="#django.db.transaction.on_commit" title="django.db.transaction.on_commit"><code class="xref py py-func docutils literal notranslate"><span class="pre">on_commit()</span></code></a> を呼び出すとエラーになります。</p>
</section>
<section id="s-use-in-tests">
<span id="use-in-tests"></span><h3>テストでの使用<a class="headerlink" href="#use-in-tests" title="Link to this heading">¶</a></h3>
<p>Django の <a class="reference internal" href="../testing/tools.html#django.test.TestCase" title="django.test.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> クラスは各テストをトランザクションでラップし、テストの分離を行うために、各テストの後にそのトランザクションをロールバックします。つまり、実際にトランザクションがコミットされることはなく、 <a class="reference internal" href="#django.db.transaction.on_commit" title="django.db.transaction.on_commit"><code class="xref py py-func docutils literal notranslate"><span class="pre">on_commit()</span></code></a> コールバックが実行されることはありません。</p>
<p>この制限を克服するには <a class="reference internal" href="../testing/tools.html#django.test.TestCase.captureOnCommitCallbacks" title="django.test.TestCase.captureOnCommitCallbacks"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TestCase.captureOnCommitCallbacks()</span></code></a> を使用します。これは <a class="reference internal" href="#django.db.transaction.on_commit" title="django.db.transaction.on_commit"><code class="xref py py-func docutils literal notranslate"><span class="pre">on_commit()</span></code></a> コールバックをリストにキャプチャし、それに対してアサーションを行ったり、それらを呼び出してトランザクションのコミットをエミュレートしたりすることができます。</p>
<p>この制限を克服するもう一つの方法は、 <a class="reference internal" href="../testing/tools.html#django.test.TestCase" title="django.test.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> の代わりに <a class="reference internal" href="../testing/tools.html#django.test.TransactionTestCase" title="django.test.TransactionTestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TransactionTestCase</span></code></a> を使うことです。これにより、トランザクションがコミットされ、コールバックが実行されます。しかし、 <a class="reference internal" href="../testing/tools.html#django.test.TransactionTestCase" title="django.test.TransactionTestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TransactionTestCase</span></code></a> はテストとテストの間にデータベースを flush するので、 分離されている <a class="reference internal" href="../testing/tools.html#django.test.TestCase" title="django.test.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> よりも大幅に遅くなります。</p>
</section>
<section id="s-why-no-rollback-hook">
<span id="why-no-rollback-hook"></span><h3>なぜロールバックフックがないのですか？<a class="headerlink" href="#why-no-rollback-hook" title="Link to this heading">¶</a></h3>
<p>ロールバックフックはコミットフックよりもロバストに実装するのが難しいです。</p>
<p>たとえば、プロセスが正常にシャットダウンする機会なく終了してデータベースコネクションが切断された場合、ロールバックフックは実行されないでしょう。</p>
<p>アトミックブロック（トランザクション）中に何かを行い、トランザクションが失敗した場合にそれを元に戻すのではなく、<a class="reference internal" href="#django.db.transaction.on_commit" title="django.db.transaction.on_commit"><code class="xref py py-func docutils literal notranslate"><span class="pre">on_commit()</span></code></a> を使ってトランザクションが成功するまで最初の処理を遅らせるのです。そもそもやっていないことを元に戻すのはとても簡単です！</p>
</section>
</section>
<section id="s-low-level-apis">
<span id="low-level-apis"></span><h2>低レベルAPI<a class="headerlink" href="#low-level-apis" title="Link to this heading">¶</a></h2>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>可能であれば、常に <a class="reference internal" href="#django.db.transaction.atomic" title="django.db.transaction.atomic"><code class="xref py py-func docutils literal notranslate"><span class="pre">atomic()</span></code></a> を選択してください。各データベースの特異性を考慮し、不正な操作を防ぐことができます。</p>
<p>低レベルのAPIは、独自のトランザクション管理を実装する場合にだけ有用です。</p>
</div>
<section id="s-managing-autocommit">
<span id="s-id3"></span><span id="managing-autocommit"></span><span id="id3"></span><h3>自動コミット<a class="headerlink" href="#managing-autocommit" title="Link to this heading">¶</a></h3>
<p>Django は <a class="reference internal" href="#module-django.db.transaction" title="django.db.transaction"><code class="xref py py-mod docutils literal notranslate"><span class="pre">django.db.transaction</span></code></a> モジュールで、各データベースコネクションの自動コミット状態を管理する API を提供しています。</p>
<dl class="py function">
<dt class="sig sig-object py" id="django.db.transaction.get_autocommit">
<span class="sig-name descname"><span class="pre">get_autocommit</span></span>(<em class="sig-param"><span class="n"><span class="pre">using</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>)<a class="reference external" href="https://github.com/django/django/blob/stable/5.1.x/django/db/transaction.py#L28"><span class="viewcode-link"><span class="pre">[ソース]</span></span></a><a class="headerlink" href="#django.db.transaction.get_autocommit" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="django.db.transaction.set_autocommit">
<span class="sig-name descname"><span class="pre">set_autocommit</span></span>(<em class="sig-param"><span class="n"><span class="pre">autocommit</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">using</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>)<a class="reference external" href="https://github.com/django/django/blob/stable/5.1.x/django/db/transaction.py#L33"><span class="viewcode-link"><span class="pre">[ソース]</span></span></a><a class="headerlink" href="#django.db.transaction.set_autocommit" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">atomic</span></code> は <code class="docutils literal notranslate"><span class="pre">using</span></code> 引数を取り、データベース名を指定します。この引数が与えられない場合、 Django は <code class="docutils literal notranslate"><span class="pre">&quot;default&quot;</span></code> データベースを使用します。</p>
<p>オートコミットは初期状態ではオンになっています。オフにした場合、元に戻すのはあなたの責任です。</p>
<p>自動コミットをオフにすると、データベースアダプタのデフォルトの動作になり、 Django は助けてくれません。この動作は <span class="target" id="index-8"></span><a class="pep reference external" href="https://peps.python.org/pep-0249/"><strong>PEP 249</strong></a> で指定されていますが、アダプタの実装は互いに一貫性があるとは限りません。使っているアダプタのドキュメントをよく読んでください。</p>
<p>自動コミットをオンに戻す前に、通常は <a class="reference internal" href="#django.db.transaction.commit" title="django.db.transaction.commit"><code class="xref py py-func docutils literal notranslate"><span class="pre">commit()</span></code></a> または <a class="reference internal" href="#django.db.transaction.rollback" title="django.db.transaction.rollback"><code class="xref py py-func docutils literal notranslate"><span class="pre">rollback()</span></code></a> を発行して、トランザクションがアクティブでないことを確認する必要があります。</p>
<p>Django は <a class="reference internal" href="#django.db.transaction.atomic" title="django.db.transaction.atomic"><code class="xref py py-func docutils literal notranslate"><span class="pre">atomic()</span></code></a> ブロックがアクティブなときに自動コミットをオフにすることを拒否します。</p>
</section>
<section id="s-transactions">
<span id="transactions"></span><h3>トランザクション<a class="headerlink" href="#transactions" title="Link to this heading">¶</a></h3>
<p>トランザクションはアトミックなデータベースクエリの集合です。たとえプログラムがクラッシュしても、データベースはすべての変更が適用されるか、あるいはまったく適用されないかを保証します。</p>
<p>Django はトランザクションを開始する API を提供していません。トランザクションを開始するために期待される方法は、 <a class="reference internal" href="#django.db.transaction.set_autocommit" title="django.db.transaction.set_autocommit"><code class="xref py py-func docutils literal notranslate"><span class="pre">set_autocommit()</span></code></a> で自動コミットを無効にすることです。</p>
<p>トランザクションに入ったら、 <a class="reference internal" href="#django.db.transaction.commit" title="django.db.transaction.commit"><code class="xref py py-func docutils literal notranslate"><span class="pre">commit()</span></code></a> でそれまでの変更を適用するか、 <a class="reference internal" href="#django.db.transaction.rollback" title="django.db.transaction.rollback"><code class="xref py py-func docutils literal notranslate"><span class="pre">rollback()</span></code></a> で取り消すかを選択できます。これらの関数は <a class="reference internal" href="#module-django.db.transaction" title="django.db.transaction"><code class="xref py py-mod docutils literal notranslate"><span class="pre">django.db.transaction</span></code></a> で定義されています。</p>
<dl class="py function">
<dt class="sig sig-object py" id="django.db.transaction.commit">
<span class="sig-name descname"><span class="pre">commit</span></span>(<em class="sig-param"><span class="n"><span class="pre">using</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>)<a class="reference external" href="https://github.com/django/django/blob/stable/5.1.x/django/db/transaction.py#L38"><span class="viewcode-link"><span class="pre">[ソース]</span></span></a><a class="headerlink" href="#django.db.transaction.commit" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="django.db.transaction.rollback">
<span class="sig-name descname"><span class="pre">rollback</span></span>(<em class="sig-param"><span class="n"><span class="pre">using</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>)<a class="reference external" href="https://github.com/django/django/blob/stable/5.1.x/django/db/transaction.py#L43"><span class="viewcode-link"><span class="pre">[ソース]</span></span></a><a class="headerlink" href="#django.db.transaction.rollback" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">atomic</span></code> は <code class="docutils literal notranslate"><span class="pre">using</span></code> 引数を取り、データベース名を指定します。この引数が与えられない場合、 Django は <code class="docutils literal notranslate"><span class="pre">&quot;default&quot;</span></code> データベースを使用します。</p>
<p>Django は <a class="reference internal" href="#django.db.transaction.atomic" title="django.db.transaction.atomic"><code class="xref py py-func docutils literal notranslate"><span class="pre">atomic()</span></code></a> ブロックがアクティブなとき、コミットやロールバックを拒否します。</p>
</section>
<section id="s-topics-db-transactions-savepoints">
<span id="s-id4"></span><span id="topics-db-transactions-savepoints"></span><span id="id4"></span><h3>セーブポイント<a class="headerlink" href="#topics-db-transactions-savepoints" title="Link to this heading">¶</a></h3>
<p>セーブポイントはトランザクション内のマーカーで、トランザクション全体ではなくトランザクションの一部をロールバックできます。セーブポイントはSQLite、PostgreSQL、Oracle、MySQL（InnoDBストレージエンジンを使用している場合）のバックエンドで使用できます。他のバックエンドはセーブポイント関数を提供しますが、空の操作です。</p>
<p>Django のデフォルトの動作である autocommit を使っている場合、セーブポイントは特に役に立ちません。しかし、いったん <a class="reference internal" href="#django.db.transaction.atomic" title="django.db.transaction.atomic"><code class="xref py py-func docutils literal notranslate"><span class="pre">atomic()</span></code></a> でトランザクションをオープンすると、コミットやロールバックを待つ一連のデータベース操作が構築されます。ロールバックを行うと、トランザクション全体がロールバックされます。セーブポイントは、 <code class="docutils literal notranslate"><span class="pre">transaction.rollback()</span></code> によって実行される完全なロールバックではなく、きめ細かいロールバックを実行する機能を提供します。</p>
<p><a class="reference internal" href="#django.db.transaction.atomic" title="django.db.transaction.atomic"><code class="xref py py-func docutils literal notranslate"><span class="pre">atomic()</span></code></a> デコレータがネストされている場合、部分的なコミットやロールバックを可能にするためにセーブポイントを作成します。以下に説明する関数よりも <a class="reference internal" href="#django.db.transaction.atomic" title="django.db.transaction.atomic"><code class="xref py py-func docutils literal notranslate"><span class="pre">atomic()</span></code></a> を使用することを強く推奨しますが、これらはまだパブリック API の一部であり、非推奨とする予定はありません。</p>
<p>これらの関数はそれぞれ <code class="docutils literal notranslate"><span class="pre">using</span></code> 引数を取り、その引数には動作が適用されるデータベースの名前を指定します。 引数に <code class="docutils literal notranslate"><span class="pre">using</span></code> が指定されていない場合は、 <code class="docutils literal notranslate"><span class="pre">&quot;default&quot;</span></code> データベースが使用されます。</p>
<p>セーブポイントは <a class="reference internal" href="#module-django.db.transaction" title="django.db.transaction"><code class="xref py py-mod docutils literal notranslate"><span class="pre">django.db.transaction</span></code></a> の3つの関数で制御されます:</p>
<dl class="py function">
<dt class="sig sig-object py" id="django.db.transaction.savepoint">
<span class="sig-name descname"><span class="pre">savepoint</span></span>(<em class="sig-param"><span class="n"><span class="pre">using</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>)<a class="reference external" href="https://github.com/django/django/blob/stable/5.1.x/django/db/transaction.py#L48"><span class="viewcode-link"><span class="pre">[ソース]</span></span></a><a class="headerlink" href="#django.db.transaction.savepoint" title="Link to this definition">¶</a></dt>
<dd><p>新しいセーブポイントを作成します。これはトランザクションの中で &quot;良い&quot; 状態であることが分かっている点をマークします。セーブポイントID (<code class="docutils literal notranslate"><span class="pre">sid</span></code>) を返します。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="django.db.transaction.savepoint_commit">
<span class="sig-name descname"><span class="pre">savepoint_commit</span></span>(<em class="sig-param"><span class="n"><span class="pre">sid</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">using</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>)<a class="reference external" href="https://github.com/django/django/blob/stable/5.1.x/django/db/transaction.py#L65"><span class="viewcode-link"><span class="pre">[ソース]</span></span></a><a class="headerlink" href="#django.db.transaction.savepoint_commit" title="Link to this definition">¶</a></dt>
<dd><p>セーブポイント <code class="docutils literal notranslate"><span class="pre">sid</span></code> を解放します。セーブポイントが作成されてから行われた変更は、トランザクションの一部となります。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="django.db.transaction.savepoint_rollback">
<span class="sig-name descname"><span class="pre">savepoint_rollback</span></span>(<em class="sig-param"><span class="n"><span class="pre">sid</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">using</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>)<a class="reference external" href="https://github.com/django/django/blob/stable/5.1.x/django/db/transaction.py#L57"><span class="viewcode-link"><span class="pre">[ソース]</span></span></a><a class="headerlink" href="#django.db.transaction.savepoint_rollback" title="Link to this definition">¶</a></dt>
<dd><p>トランザクションをセーブポイント <code class="docutils literal notranslate"><span class="pre">sid</span></code> にロールバックします。</p>
</dd></dl>

<p>これらの関数は、セーブポイントがサポートされていない場合やデータベースが自動コミットモードの場合は何もしません。</p>
<p>さらに、ユーティリティ関数があります:</p>
<dl class="py function">
<dt class="sig sig-object py" id="django.db.transaction.clean_savepoints">
<span class="sig-name descname"><span class="pre">clean_savepoints</span></span>(<em class="sig-param"><span class="n"><span class="pre">using</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>)<a class="reference external" href="https://github.com/django/django/blob/stable/5.1.x/django/db/transaction.py#L73"><span class="viewcode-link"><span class="pre">[ソース]</span></span></a><a class="headerlink" href="#django.db.transaction.clean_savepoints" title="Link to this definition">¶</a></dt>
<dd><p>一意のセーブポイントIDを生成するためのカウンタをリセットします。</p>
</dd></dl>

<p>以下に、セーブポイントの使い方の例を示します:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">django.db</span><span class="w"> </span><span class="kn">import</span> <span class="n">transaction</span>


<span class="c1"># open a transaction</span>
<span class="nd">@transaction</span><span class="o">.</span><span class="n">atomic</span>
<span class="k">def</span><span class="w"> </span><span class="nf">viewfunc</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="n">a</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
    <span class="c1"># transaction now contains a.save()</span>

    <span class="n">sid</span> <span class="o">=</span> <span class="n">transaction</span><span class="o">.</span><span class="n">savepoint</span><span class="p">()</span>

    <span class="n">b</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
    <span class="c1"># transaction now contains a.save() and b.save()</span>

    <span class="k">if</span> <span class="n">want_to_keep_b</span><span class="p">:</span>
        <span class="n">transaction</span><span class="o">.</span><span class="n">savepoint_commit</span><span class="p">(</span><span class="n">sid</span><span class="p">)</span>
        <span class="c1"># open transaction still contains a.save() and b.save()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">transaction</span><span class="o">.</span><span class="n">savepoint_rollback</span><span class="p">(</span><span class="n">sid</span><span class="p">)</span>
        <span class="c1"># open transaction now contains only a.save()</span>
</pre></div>
</div>
<p>セーブポイントは部分的なロールバックを行うことで、データベースエラーから回復するために使用できます。<a class="reference internal" href="#django.db.transaction.atomic" title="django.db.transaction.atomic"><code class="xref py py-func docutils literal notranslate"><span class="pre">atomic()</span></code></a> ブロックの中でこの処理を行っている場合、ブロック全体がロールバックされます！これを防ぐために、以下の関数でロールバックの動作を制御できます。</p>
<dl class="py function">
<dt class="sig sig-object py" id="django.db.transaction.get_rollback">
<span class="sig-name descname"><span class="pre">get_rollback</span></span>(<em class="sig-param"><span class="n"><span class="pre">using</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>)<a class="reference external" href="https://github.com/django/django/blob/stable/5.1.x/django/db/transaction.py#L80"><span class="viewcode-link"><span class="pre">[ソース]</span></span></a><a class="headerlink" href="#django.db.transaction.get_rollback" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="django.db.transaction.set_rollback">
<span class="sig-name descname"><span class="pre">set_rollback</span></span>(<em class="sig-param"><span class="n"><span class="pre">rollback</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">using</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>)<a class="reference external" href="https://github.com/django/django/blob/stable/5.1.x/django/db/transaction.py#L85"><span class="viewcode-link"><span class="pre">[ソース]</span></span></a><a class="headerlink" href="#django.db.transaction.set_rollback" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<p>ロールバックフラグを <code class="docutils literal notranslate"><span class="pre">True</span></code> に設定すると、最も内側のアトミックブロックを終了するときにロールバックします。これは例外を発生させずにロールバックを行うのに便利です。</p>
<p>これを <code class="docutils literal notranslate"><span class="pre">False</span></code> に設定すると、このようなロールバックを防ぐことができます。これを行う前に、トランザクションを現在のアトミックブロック内の既知のセーブポイントまでロールバックしたことを確認してください！そうしないと、アトミック性が壊れてしまい、データの破損が発生する可能性があります。</p>
</section>
</section>
<section id="s-database-specific-notes">
<span id="database-specific-notes"></span><h2>データベース固有の注意事項<a class="headerlink" href="#database-specific-notes" title="Link to this heading">¶</a></h2>
<section id="s-savepoints-in-sqlite">
<span id="s-id5"></span><span id="savepoints-in-sqlite"></span><span id="id5"></span><h3>SQLite におけるセーブポイント<a class="headerlink" href="#savepoints-in-sqlite" title="Link to this heading">¶</a></h3>
<p>SQLiteはセーブポイントをサポートしていますが、 <a class="reference external" href="https://docs.python.org/3/library/sqlite3.html#module-sqlite3" title="(in Python v3.13)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sqlite3</span></code></a> モジュールの設計に欠陥があるため、セーブポイントはほとんど使えません。</p>
<p>自動コミットが有効な場合、セーブポイントは意味を成しません。これが無効な場合、 <a class="reference external" href="https://docs.python.org/3/library/sqlite3.html#module-sqlite3" title="(in Python v3.13)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sqlite3</span></code></a> はセーブポイントステートメントの前に暗黙的にコミットします。(実際には <code class="docutils literal notranslate"><span class="pre">SELECT</span></code> 、 <code class="docutils literal notranslate"><span class="pre">INSERT</span></code> 、 <code class="docutils literal notranslate"><span class="pre">UPDATE</span></code> 、 <code class="docutils literal notranslate"><span class="pre">DELETE</span></code> 、 <code class="docutils literal notranslate"><span class="pre">REPLACE</span></code> 以外のステートメントの前にコミットします)。このバグには2つの影響があります:</p>
<ul class="simple">
<li><p>セーブポイントの低レベルのAPIはトランザクションの中、つまり <a class="reference internal" href="#django.db.transaction.atomic" title="django.db.transaction.atomic"><code class="xref py py-func docutils literal notranslate"><span class="pre">atomic()</span></code></a> ブロックの中でしか使えません。</p></li>
<li><p>自動コミットがオフになっている場合、<a class="reference internal" href="#django.db.transaction.atomic" title="django.db.transaction.atomic"><code class="xref py py-func docutils literal notranslate"><span class="pre">atomic()</span></code></a> を使用することはできません。</p></li>
</ul>
</section>
<section id="s-transactions-in-mysql">
<span id="transactions-in-mysql"></span><h3>MySQL におけるトランザクション<a class="headerlink" href="#transactions-in-mysql" title="Link to this heading">¶</a></h3>
<p>MySQL を使用している場合、テーブルがトランザクションをサポートしているかどうかは MySQL のバージョンと使用しているテーブルタイプに依存します。(「テーブルタイプ」とは、「InnoDB」や「MyISAM」のようなものを意味します。) MySQLのトランザクションに関する特殊性はこの記事の範囲外ですが、MySQLのサイトには <a class="reference external" href="https://dev.mysql.com/doc/refman/en/sql-transactional-statements.html">information on MySQL transactions</a> があります。</p>
<p>MySQL がトランザクションをサポートしていない場合、 Django は常に自動コミットモードで動作します。MySQL がトランザクションをサポートしている場合、 Django はこの文書で説明されているようにトランザクションを処理します。</p>
</section>
<section id="s-handling-exceptions-within-postgresql-transactions">
<span id="handling-exceptions-within-postgresql-transactions"></span><h3>PostgreSQLトランザクション内での例外ハンドリング<a class="headerlink" href="#handling-exceptions-within-postgresql-transactions" title="Link to this heading">¶</a></h3>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>このセクションは、独自のトランザクション管理を実装している場合にだけ関係があります。この問題は Django のデフォルトモードでは発生せず、 <a class="reference internal" href="#django.db.transaction.atomic" title="django.db.transaction.atomic"><code class="xref py py-func docutils literal notranslate"><span class="pre">atomic()</span></code></a> が自動的に処理します。</p>
</div>
<p>トランザクション内で、PostgreSQLカーソルの呼び出しが例外（通常は <code class="docutils literal notranslate"><span class="pre">IntegrityError</span></code> ）を発生させた場合、同じトランザクション内の後続のSQLはすべて &quot;current transaction is aborted, queries ignored until end of transaction block&quot; というエラーで失敗します。 <code class="docutils literal notranslate"><span class="pre">save()</span></code> の基本的な使用では例外を発生させる可能性は低いですが、一意なフィールドを持つオブジェクトの保存、 <code class="docutils literal notranslate"><span class="pre">force_insert</span></code>/<code class="docutils literal notranslate"><span class="pre">force_update</span></code> フラグを使用した保存、カスタムSQLの実行など、より高度な使用パターンでは例外が発生する可能性があります。</p>
<p>この種のエラーから回復する方法はいくつかあります。</p>
<section id="s-transaction-rollback">
<span id="transaction-rollback"></span><h4>トランザクションのロールバック<a class="headerlink" href="#transaction-rollback" title="Link to this heading">¶</a></h4>
<p>一つ目の選択肢は、トランザクション全体をロールバックすることです。たとえば:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">a</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>  <span class="c1"># Succeeds, but may be undone by transaction rollback</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">b</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>  <span class="c1"># Could throw exception</span>
<span class="k">except</span> <span class="n">IntegrityError</span><span class="p">:</span>
    <span class="n">transaction</span><span class="o">.</span><span class="n">rollback</span><span class="p">()</span>
<span class="n">c</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>  <span class="c1"># Succeeds, but a.save() may have been undone</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">transaction.rollback()</span></code> を呼び出すと、トランザクション全体がロールバックされます。コミットされていないデータベース操作はすべて失われます。この例では、<code class="docutils literal notranslate"><span class="pre">a.save()</span></code> による変更は、その操作自体がエラーを発生させなかったにもかかわらず、失われることになります。</p>
</section>
<section id="s-savepoint-rollback">
<span id="savepoint-rollback"></span><h4>セーブポイントのロールバック<a class="headerlink" href="#savepoint-rollback" title="Link to this heading">¶</a></h4>
<p><a class="reference internal" href="#topics-db-transactions-savepoints"><span class="std std-ref">セーブポイント</span></a> を使用すると、ロールバックの範囲を制御できます。失敗する可能性のあるデータベース操作を実行する前に、セーブポイントを設定または更新できます。こうすることで、操作に失敗した場合にトランザクション全体ではなく、問題のある操作だけをロールバックできます。たとえば、次のようにします:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">a</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>  <span class="c1"># Succeeds, and never undone by savepoint rollback</span>
<span class="n">sid</span> <span class="o">=</span> <span class="n">transaction</span><span class="o">.</span><span class="n">savepoint</span><span class="p">()</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">b</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>  <span class="c1"># Could throw exception</span>
    <span class="n">transaction</span><span class="o">.</span><span class="n">savepoint_commit</span><span class="p">(</span><span class="n">sid</span><span class="p">)</span>
<span class="k">except</span> <span class="n">IntegrityError</span><span class="p">:</span>
    <span class="n">transaction</span><span class="o">.</span><span class="n">savepoint_rollback</span><span class="p">(</span><span class="n">sid</span><span class="p">)</span>
<span class="n">c</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>  <span class="c1"># Succeeds, and a.save() is never undone</span>
</pre></div>
</div>
<p>この例では、 <code class="docutils literal notranslate"><span class="pre">b.save()</span></code> が例外を発生させても、 <code class="docutils literal notranslate"><span class="pre">a.save()</span></code> は元に戻りません。</p>
</section>
</section>
</section>
</section>


          </div>
        </div>
      </div>
      
        
          <div class="yui-b" id="sidebar">
            
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../../contents.html">目次</a></h3>
    <ul>
<li><a class="reference internal" href="#">データベースのトランザクション</a><ul>
<li><a class="reference internal" href="#managing-database-transactions">データベースのトランザクションを管理する</a><ul>
<li><a class="reference internal" href="#django-s-default-transaction-behavior">Django のデフォルトのトランザクションの動作</a></li>
<li><a class="reference internal" href="#tying-transactions-to-http-requests">HTTP リクエストにトランザクションを結びつける</a></li>
<li><a class="reference internal" href="#controlling-transactions-explicitly">明示的にトランザクションをコントロールする</a></li>
</ul>
</li>
<li><a class="reference internal" href="#autocommit">自動コミット</a><ul>
<li><a class="reference internal" href="#why-django-uses-autocommit">なぜ Django は自動コミットを使うのか</a></li>
<li><a class="reference internal" href="#deactivating-transaction-management">トランザクション管理を無効化する</a></li>
</ul>
</li>
<li><a class="reference internal" href="#performing-actions-after-commit">コミット後にアクションを実行する</a><ul>
<li><a class="reference internal" href="#savepoints">セーブポイント</a></li>
<li><a class="reference internal" href="#order-of-execution">実行順</a></li>
<li><a class="reference internal" href="#exception-handling">例外のハンドリング</a></li>
<li><a class="reference internal" href="#timing-of-execution">実行タイミング</a></li>
<li><a class="reference internal" href="#use-in-tests">テストでの使用</a></li>
<li><a class="reference internal" href="#why-no-rollback-hook">なぜロールバックフックがないのですか？</a></li>
</ul>
</li>
<li><a class="reference internal" href="#low-level-apis">低レベルAPI</a><ul>
<li><a class="reference internal" href="#managing-autocommit">自動コミット</a></li>
<li><a class="reference internal" href="#transactions">トランザクション</a></li>
<li><a class="reference internal" href="#topics-db-transactions-savepoints">セーブポイント</a></li>
</ul>
</li>
<li><a class="reference internal" href="#database-specific-notes">データベース固有の注意事項</a><ul>
<li><a class="reference internal" href="#savepoints-in-sqlite">SQLite におけるセーブポイント</a></li>
<li><a class="reference internal" href="#transactions-in-mysql">MySQL におけるトランザクション</a></li>
<li><a class="reference internal" href="#handling-exceptions-within-postgresql-transactions">PostgreSQLトランザクション内での例外ハンドリング</a><ul>
<li><a class="reference internal" href="#transaction-rollback">トランザクションのロールバック</a></li>
<li><a class="reference internal" href="#savepoint-rollback">セーブポイントのロールバック</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>前のトピックへ</h4>
    <p class="topless"><a href="sql.html"
                          title="前の章へ">素の SQL 文の実行</a></p>
  </div>
  <div>
    <h4>次のトピックへ</h4>
    <p class="topless"><a href="multi-db.html"
                          title="次の章へ">複数のデータベース</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>このページ</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/topics/db/transactions.txt"
            rel="nofollow">ソースコードを表示</a></li>
    </ul>
   </div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">クイック検索</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="検索" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
              <h3>Last update:</h3>
              <p class="topless">1月 22, 2025</p>
          </div>
        
      
    </div>

    <div id="ft">
      <div class="nav">
    &laquo; <a href="sql.html" title="素の SQL 文の実行">previous</a>
     |
    <a href="../index.html" title="Django を使う" accesskey="U">up</a>
   |
    <a href="multi-db.html" title="複数のデータベース">next</a> &raquo;</div>
    </div>
  </div>

      <div class="clearer"></div>
    </div>
  </body>
</html>