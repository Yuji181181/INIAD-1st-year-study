<!DOCTYPE html>

<html lang="ja" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>マイグレーション &#8212; Django 5.1.6.dev20250122212402 ドキュメント</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=34bb78ad" />
    <link rel="stylesheet" type="text/css" href="../_static/default.css?v=bf4d74af" />
    <script src="../_static/documentation_options.js?v=d2885b0a"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/translations.js?v=4755f45a"></script>
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="検索" href="../search.html" />
    <link rel="next" title="ファイルの管理" href="files.html" />
    <link rel="prev" title="クラスベースのビューでミックスイン (mixin) を使用する" href="class-based-views/mixins.html" />



 
<script src="../templatebuiltins.js"></script>
<script>
(function($) {
    if (!django_template_builtins) {
       // templatebuiltins.js missing, do nothing.
       return;
    }
    $(document).ready(function() {
        // Hyperlink Django template tags and filters
        var base = "../ref/templates/builtins.html";
        if (base == "#") {
            // Special case for builtins.html itself
            base = "";
        }
        // Tags are keywords, class '.k'
        $("div.highlight\\-html\\+django span.k").each(function(i, elem) {
             var tagname = $(elem).text();
             if ($.inArray(tagname, django_template_builtins.ttags) != -1) {
                 var fragment = tagname.replace(/_/, '-');
                 $(elem).html("<a href='" + base + "#" + fragment + "'>" + tagname + "</a>");
             }
        });
        // Filters are functions, class '.nf'
        $("div.highlight\\-html\\+django span.nf").each(function(i, elem) {
             var filtername = $(elem).text();
             if ($.inArray(filtername, django_template_builtins.tfilters) != -1) {
                 var fragment = filtername.replace(/_/, '-');
                 $(elem).html("<a href='" + base + "#" + fragment + "'>" + filtername + "</a>");
             }
        });
    });
})(jQuery);(function($) {
    $(document).ready(function() {
        $(".c-tab-unix").on("click", function() {
            $("section.c-content-unix").show();
            $("section.c-content-win").hide();
            $(".c-tab-unix").prop("checked", true);
        });
        $(".c-tab-win").on("click", function() {
            $("section.c-content-win").show();
            $("section.c-content-unix").hide();
            $(".c-tab-win").prop("checked", true);
        });
    });
})(jQuery);</script>
<link rel="stylesheet" href="../_static/console-tabs.css">
  </head><body>

    <div class="document">
  <div id="custom-doc" class="yui-t6">
    <div id="hd">
      <h1><a href="../index.html">Django 5.1.6.dev20250122212402 ドキュメント</a></h1>
      <div id="global-nav">
        <a title="Home page" href="../index.html">Home</a>  |
        <a title="Table of contents" href="../contents.html">Table of contents</a>  |
        <a title="Global index" href="../genindex.html">Index</a>  |
        <a title="Module index" href="../py-modindex.html">Modules</a>
      </div>
      <div class="nav">
    &laquo; <a href="class-based-views/mixins.html" title="クラスベースのビューでミックスイン (mixin) を使用する">previous</a>
     |
    <a href="index.html" title="Django を使う" accesskey="U">up</a>
   |
    <a href="files.html" title="ファイルの管理">next</a> &raquo;</div>
    </div>

    <div id="bd">
      <div id="yui-main">
        <div class="yui-b">
          <div class="yui-g" id="topics-migrations">
            
  <section id="s-module-django.db.migrations">
<span id="s-migrations"></span><span id="module-django.db.migrations"></span><span id="migrations"></span><h1>マイグレーション<a class="headerlink" href="#module-django.db.migrations" title="Link to this heading">¶</a></h1>
<p>マイグレーション (Migrations) は、Django でモデルに対して行った変更 (フィールドの追加やモデルの削除など) をデータベーススキーマに反映させる方法です。大抵のマイグレーションは自動で行われるものの、いつマイグレーションが作られ、いつ実行され、どんな問題がよく起こるのかは、知っておいた方がいいでしょう。</p>
<section id="s-the-commands">
<span id="the-commands"></span><h2>コマンド<a class="headerlink" href="#the-commands" title="Link to this heading">¶</a></h2>
<p>マイグレーションと Django のデータベーススキーマの操作に関わる時によく使うコマンドを、いくつか挙げておきましょう。</p>
<ul class="simple">
<li><p><a class="reference internal" href="../ref/django-admin.html#django-admin-migrate"><code class="xref std std-djadmin docutils literal notranslate"><span class="pre">migrate</span></code></a> は、マイグレーションを適用したり、適用をキャンセルするのに使います。</p></li>
<li><p><a class="reference internal" href="../ref/django-admin.html#django-admin-makemigrations"><code class="xref std std-djadmin docutils literal notranslate"><span class="pre">makemigrations</span></code></a> は、モデルに対して行った変更をもとに、新しいマイグレーションを作成します。</p></li>
<li><p><a class="reference internal" href="../ref/django-admin.html#django-admin-sqlmigrate"><code class="xref std std-djadmin docutils literal notranslate"><span class="pre">sqlmigrate</span></code></a> は、マイグレーションに対応する SQL 文を表示します。</p></li>
<li><p><a class="reference internal" href="../ref/django-admin.html#django-admin-showmigrations"><code class="xref std std-djadmin docutils literal notranslate"><span class="pre">showmigrations</span></code></a> は、プロジェクトのマイグレーションとそのステータスをリストします。</p></li>
</ul>
<p>マイグレーションというのは、データベーススキーマに対するバージョン管理システムのようなものです。<code class="docutils literal notranslate"><span class="pre">makemigrations</span></code> はモデルの変更点を1つのマイグレーションファイルにパッケージングし(コミットのようなものです)、<code class="docutils literal notranslate"><span class="pre">migrate</span></code> はその変更点をデータベースに適用する、というわけです。</p>
<p>各アプリのマイグレーションファイルはそのアプリの &quot;migrations&quot; ディレクトリの中に保管され、コードベースの一部としてコミットされ、配布されるようにデザインされています。いったん開発用マシンでマイグレーションファイルが作成されれば、その後、チームメンバーのマシンやステージング環境のマシン上で同一のマイグレーションが行われ、最終的にプロダクション環境でも同じマイグレーションが行われます。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>アプリのパッケージの名に migrations が含まれ、上書きされてしまう場合には、設定ファイルの <a class="reference internal" href="../ref/settings.html#std-setting-MIGRATION_MODULES"><code class="xref std std-setting docutils literal notranslate"><span class="pre">MIGRATION_MODULES</span></code></a> を修正してください。</p>
</div>
<p>マイグレーションが同じデータセットに同じ方法で実行され、一貫した結果を生み出すということは、開発環境やステージング環境下で目にする結果が、プロダクション環境下でも全く同じになるということです。</p>
<p>Django は、モデルやフィールドに変更があった場合、たとえデータベースに影響を与えないオプションであっても、マイグレーションを行います。フィールドを正しく再構築する唯一の方法は、すべての変更が履歴に残っていることであり、後々のデータマイグレーションで、これらのオプションが必要になるかもしれないからです (たとえば、カスタムバリデータを設定した場合など)。</p>
</section>
<section id="s-backend-support">
<span id="backend-support"></span><h2>対応するバックエンド<a class="headerlink" href="#backend-support" title="Link to this heading">¶</a></h2>
<p>マイグレーションは Django で標準で利用できるすべてのバックエンドに対応しています。サードパーティ製のバックエンドでも、プログラムからのスキーマの変更の操作(<a class="reference internal" href="../ref/schema-editor.html"><span class="doc">SchemaEditor</span></a> クラスで実行される)に対応していれば大丈夫です。</p>
<p>しかし、スキーマのマイグレーションは、データベースによってが得手・不得手があります。注意点を以下で説明します。</p>
<section id="s-postgresql">
<span id="postgresql"></span><h3>PostgreSQL<a class="headerlink" href="#postgresql" title="Link to this heading">¶</a></h3>
<p>PostgreSQLはスキーマのサポートという点で、ここにあるすべてのデータベースの中で最も有能です。</p>
</section>
<section id="s-mysql">
<span id="mysql"></span><h3>MySQL<a class="headerlink" href="#mysql" title="Link to this heading">¶</a></h3>
<p>MySQL はスキーマの変更操作周りのトランザクションをサポートしていません。つまり、マイグレーションの適用が失敗した場合には、手動で変更点を調べあげ、やり直さなければならないということです (過去の時点にロールバックすることは不可能ということです)。</p>
<p>MySQL 8.0 では <a class="reference external" href="https://dev.mysql.com/doc/refman/en/innodb-online-ddl-operations.html">DDL operations</a> のパフォーマンスが大幅に強化され、より効率的になり、テーブルの完全な再構築の必要性が減りました。しかし、ロックや中断が完全に発生しないことは保証されません。ロックが必要な場合、操作時間は対象の行数に比例して長くなります。</p>
<p>最後に、MySQL ではインデックスがカバーするすべてのカラムの合計サイズに比較的小さな制限があります。これは、他のバックエンドでは可能なインデックスが MySQL では作成できないことを意味します。</p>
</section>
<section id="s-sqlite">
<span id="sqlite"></span><h3>SQLite<a class="headerlink" href="#sqlite" title="Link to this heading">¶</a></h3>
<p>SQLite はビルトインのスキーマ変更操作をほとんどサポートしていません。そのため、Django は以下のようにしてスキーマの変更動作をエミュレートします。</p>
<ul class="simple">
<li><p>新しいスキーマで、新しいテーブルを作成する</p></li>
<li><p>テーブル間でデータをコピーする</p></li>
<li><p>古いテーブルを削除する</p></li>
<li><p>新しいテーブルを元のテーブル名に変更する</p></li>
</ul>
<p>この方法で大抵はうまくいきますが、遅かったりたまにテーブルが壊れてしまうことがあります。そのため、SQLite をプロダクション環境で使用するのは、このリスクと制限を十分理解している場合以外には、おすすめしません。Django がデフォルトで SQLite を使用しているのは、開発者が SQLite をローカルマシンでかんたんに実行できるようにすることで、本格的なデータベースがなくても Django のプロジェクトが開発できるようにして、複雑さを除くようにデザインされているからです。</p>
</section>
</section>
<section id="s-workflow">
<span id="workflow"></span><h2>ワークフロー<a class="headerlink" href="#workflow" title="Link to this heading">¶</a></h2>
<p>Django はあなたに代わってマイグレーションを作成します。たとえば、フィールドを追加してモデルを削除するなど、モデルに変更を加えてから、<a class="reference internal" href="../ref/django-admin.html#django-admin-makemigrations"><code class="xref std std-djadmin docutils literal notranslate"><span class="pre">makemigrations</span></code></a> を実行してください。</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>python<span class="w"> </span>manage.py<span class="w"> </span>makemigrations
Migrations<span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="s1">&#39;books&#39;</span>:
<span class="w">  </span>books/migrations/0003_auto.py:
<span class="w">    </span>~<span class="w"> </span>Alter<span class="w"> </span>field<span class="w"> </span>author<span class="w"> </span>on<span class="w"> </span>book
</pre></div>
</div>
<p>すると、あなたが書いたモデルがスキャンされ、現在のバージョンのマイグレーションファイルに記録されているモデルと比較されます。この時、<code class="docutils literal notranslate"><span class="pre">makemigrations</span></code> があなたが何を変更したと考えているのかを理解するために、出力をよく読んでください。不完全だったり、意図したよりも複雑な結果が表示されるかもしれません。</p>
<p>問題なく新しいマイグレーションファイルが生成されたら、期待通りに変更が行われるように、データベースに適用します:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>python<span class="w"> </span>manage.py<span class="w"> </span>migrate
Operations<span class="w"> </span>to<span class="w"> </span>perform:
<span class="w">  </span>Apply<span class="w"> </span>all<span class="w"> </span>migrations:<span class="w"> </span>books
Running<span class="w"> </span>migrations:
<span class="w">  </span>Rendering<span class="w"> </span>model<span class="w"> </span>states...<span class="w"> </span>DONE
<span class="w">  </span>Applying<span class="w"> </span>books.0003_auto...<span class="w"> </span>OK
</pre></div>
</div>
<p>マイグレーションを適用したら、マイグレーションとモデルの変更をバージョン管理システムに1つのコミットとしてコミットしましょう。こうすることで、他の開発者 (やプロダクションサーバー) がコードをチェックアウトした時に、モデルの変更とマイグレーションの適用を同時に実行できます。</p>
<p>マイグレーションに、自動生成された名前ではなく、意味のある名前を与えたければ、<a class="reference internal" href="../ref/django-admin.html#cmdoption-makemigrations-name"><code class="xref std std-option docutils literal notranslate"><span class="pre">makemigrations</span> <span class="pre">--name</span></code></a> オプションが使えます。</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>python<span class="w"> </span>manage.py<span class="w"> </span>makemigrations<span class="w"> </span>--name<span class="w"> </span>changed_my_model<span class="w"> </span>your_app_label
</pre></div>
</div>
<section id="s-version-control">
<span id="version-control"></span><h3>バージョン管理<a class="headerlink" href="#version-control" title="Link to this heading">¶</a></h3>
<p>マイグレーションはバージョン管理システムに保管されるため、あなたがマイグレーションをコミットしたのと同じアプリに、同じタイミングで、他の開発者もマイグレーションをコミットしてしまい、結果として同じ数字のマイグレーションが2つできてしまう、というシチュエーションに遭遇するかもしれません。</p>
<p>でも、大丈夫。マイグレーションの数字は開発者が参考にするために付けられているだけなのです。Django が気にするのは、マイグレーションの名前が異なっているかどうかだけです。マイグレーションはファイルの中で、自分が依存している他のマイグレーション (同じアプリの過去のマイグレーションを含む) を明記しています。そのため、同じアプリへの2つの順序関係がない新しいマイグレーションが存在していれば、それらをちゃんと検出できます。</p>
<p>このような状況が起きた場合、Django はいくつかの選択肢を提示します。それを読んで十分安全だと判断できれば、2つのマイグレーションを自動的に2つの連続するマイグレーションに変更してくれます。そうでなければ、マイグレーションファイルを自分で修正する必要があります。でも、難しくないので心配はいりません。詳しくは、下の <a class="reference internal" href="#migration-files"><span class="std std-ref">マイグレーションファイル</span></a> で説明しています。</p>
</section>
</section>
<section id="s-transactions">
<span id="transactions"></span><h2>トランザクション<a class="headerlink" href="#transactions" title="Link to this heading">¶</a></h2>
<p>DDL トランザクションをサポートしているデータベース (SQLite や PostgreSQL) では、すべてのマイグレーション操作はデフォルトで単一のトランザクション内で実行されます。一方、データベースが DDL トランザクションをサポートしていない場合 (MySQL や Oracle など)、すべての操作はトランザクションなしで実行されます。</p>
<p>マイグレーションをトランザクション内で実行しないようにするには、<code class="docutils literal notranslate"><span class="pre">atomic</span></code> 属性を <code class="docutils literal notranslate"><span class="pre">False</span></code> に設定します。たとえば次のようにします。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">django.db</span><span class="w"> </span><span class="kn">import</span> <span class="n">migrations</span>


<span class="k">class</span><span class="w"> </span><span class="nc">Migration</span><span class="p">(</span><span class="n">migrations</span><span class="o">.</span><span class="n">Migration</span><span class="p">):</span>
    <span class="n">atomic</span> <span class="o">=</span> <span class="kc">False</span>
</pre></div>
</div>
<p><a class="reference internal" href="db/transactions.html#django.db.transaction.atomic" title="django.db.transaction.atomic"><code class="xref py py-func docutils literal notranslate"><span class="pre">atomic()</span></code></a> を使うか、 <a class="reference internal" href="../ref/migration-operations.html#django.db.migrations.operations.RunPython" title="django.db.migrations.operations.RunPython"><code class="xref py py-class docutils literal notranslate"><span class="pre">RunPython</span></code></a> に <code class="docutils literal notranslate"><span class="pre">atomic=True</span></code> を渡すことで、マイグレーションの一部をトランザクション内で実行することもできます。詳しくは <a class="reference internal" href="../howto/writing-migrations.html#non-atomic-migrations"><span class="std std-ref">非アトミックのマイグレーション</span></a> を参照してください。</p>
</section>
<section id="s-dependencies">
<span id="dependencies"></span><h2>依存関係<a class="headerlink" href="#dependencies" title="Link to this heading">¶</a></h2>
<p>マイグレーションはアプリごとに作られますが、モデルが表しているテーブルやリレーションシップは、一度に一つのアプリに対して作るには複雑すぎます。他のマイグレーションの実行を要求するマイグレーション、たとえば <code class="docutils literal notranslate"><span class="pre">books</span></code> アプリ内の <code class="docutils literal notranslate"><span class="pre">ForeignKey</span></code> を <code class="docutils literal notranslate"><span class="pre">authors</span></code> アプリに加えるような場合、結果として作られるマイグレーションには、<code class="docutils literal notranslate"><span class="pre">authors</span></code> のマイグレーションへの依存関係が生じます。</p>
<p>つまり、マイグレーションを実行すると、最初に <code class="docutils literal notranslate"><span class="pre">authors</span></code> のマイグレーションが実行されて <code class="docutils literal notranslate"><span class="pre">ForeignKey</span></code> リファレンスが参照するテーブルが作成され、その後で <code class="docutils literal notranslate"><span class="pre">ForeignKey</span></code> カラムを作るマイグレーションが実行された後、制約が作られます。もしそうでなかったら、<code class="docutils literal notranslate"><span class="pre">books</span></code> のマイグレーションが存在しないテーブルを参照する <code class="docutils literal notranslate"><span class="pre">ForeignKey</span></code> カラムを作ろうとして、結果、データベースはエラーを出してしまうでしょう。</p>
<p>この依存関係の動作は、1つのアプリに制限するマイグレーション操作のほとんどに影響します。(<code class="docutils literal notranslate"><span class="pre">makemigrations</span></code> または <code class="docutils literal notranslate"><span class="pre">migrate</span></code> で)1つのアプリに制限することは最善の努力であり、保証ではありません。</p>
<p>マイグレーションをしていないアプリは、マイグレーションをしているアプリとリレーション (<code class="docutils literal notranslate"><span class="pre">ForeignKey</span></code>、<code class="docutils literal notranslate"><span class="pre">ManyToManyField</span></code> など) を持ってはいけません。うまくいくこともありますが、サポートはされていません。</p>
<section id="s-swappable-dependencies">
<span id="swappable-dependencies"></span><h3>スワップ (交換) 可能な依存関係<a class="headerlink" href="#swappable-dependencies" title="Link to this heading">¶</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="django.db.migrations.django.db.migrations.swappable_dependency">
<span class="sig-prename descclassname"><span class="pre">django.db.migrations.</span></span><span class="sig-name descname"><span class="pre">swappable_dependency</span></span>(<em class="sig-param"><span class="n"><span class="pre">value</span></span></em>)<a class="headerlink" href="#django.db.migrations.django.db.migrations.swappable_dependency" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">swappable_dependency()</span></code> 関数はマイグレーションで使用され、スワップインモデルのアプリでマイグレーションに対する「スワップ可能な」依存関係を宣言します。結果として、スワップインモデルは最初のマイグレーションで作成される必要があります。引数 <code class="docutils literal notranslate"><span class="pre">value</span></code> には、アプリのラベルとモデル名を表す文字列 <code class="docutils literal notranslate"><span class="pre">&quot;&lt;app</span> <span class="pre">label&gt;.&lt;model&gt;&quot;</span></code> を指定します。たとえば <code class="docutils literal notranslate"><span class="pre">&quot;myapp.MyModel&quot;</span></code> のように指定します。</p>
<p><code class="docutils literal notranslate"><span class="pre">swappable_dependency()</span></code> を使用することで、マイグレーションがスワップ可能なモデルを設定する別のマイグレーションに依存していることをマイグレーションフレームワークに通知し、将来的にモデルを別の実装で置き換えることができるようにします。これは通常、Django の認証システムのカスタムユーザモデル (<code class="docutils literal notranslate"><span class="pre">settings.AUTH_USER_MODEL</span></code>、デフォルトは <code class="docutils literal notranslate"><span class="pre">&quot;auth.User&quot;</span></code>) のような、カスタマイズや置き換えの対象となるモデルを参照するために使われます。</p>
</section>
</section>
<section id="s-migration-files">
<span id="s-id1"></span><span id="migration-files"></span><span id="id1"></span><h2>マイグレーションファイル<a class="headerlink" href="#migration-files" title="Link to this heading">¶</a></h2>
<p>マイグレーションはディスク上のファイルとして保存されます。ここではそれを「マイグレーションファイル」と呼びます。このファイルは実際には、決まった仕方でオブジェクトを配置した、宣言型のスタイルで書かれたふつうの Python ファイルです。</p>
<p>基本的なマイグレーションファイルは、次のような形式です。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">django.db</span><span class="w"> </span><span class="kn">import</span> <span class="n">migrations</span><span class="p">,</span> <span class="n">models</span>


<span class="k">class</span><span class="w"> </span><span class="nc">Migration</span><span class="p">(</span><span class="n">migrations</span><span class="o">.</span><span class="n">Migration</span><span class="p">):</span>
    <span class="n">dependencies</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;migrations&quot;</span><span class="p">,</span> <span class="s2">&quot;0001_initial&quot;</span><span class="p">)]</span>

    <span class="n">operations</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">migrations</span><span class="o">.</span><span class="n">DeleteModel</span><span class="p">(</span><span class="s2">&quot;Tribble&quot;</span><span class="p">),</span>
        <span class="n">migrations</span><span class="o">.</span><span class="n">AddField</span><span class="p">(</span><span class="s2">&quot;Author&quot;</span><span class="p">,</span> <span class="s2">&quot;rating&quot;</span><span class="p">,</span> <span class="n">models</span><span class="o">.</span><span class="n">IntegerField</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span>
    <span class="p">]</span>
</pre></div>
</div>
<p>Django が (Python モジュールとして) マイグレーションファイルを読み込んだ時に最初に探すのは、<code class="docutils literal notranslate"><span class="pre">Migration</span></code> という名前の <code class="docutils literal notranslate"><span class="pre">django.db.migrations.Migration</span></code> のサブクラスです。そして、このサブクラスの4つの属性を調べますが、ほとんど場合に使われるのは、次の2つの属性です。</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">dependencies</span></code> は、このマイグレーションが依存する他のマイグレーションのリストです。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">operations</span></code> は、このマイグレーションが行う操作を定義している <code class="docutils literal notranslate"><span class="pre">Operation</span></code> クラスのリストです。</p></li>
</ul>
<p>operations がポイントです。これは、宣言的な命令の集まりで、Django にどんなスキーマの変更が必要かを教えます。Django はそれらをスキャンして、全アプリへのスキーマの変更を完全に表現するデータ構造をメモリ上に作り上げ、これを利用して、Django スキーマを実際に変化させる SQL 文を生成します。</p>
<p>この時に作られるメモリ上のデータ構造は、新しいモデルと現在のマイグレーションの状態の差分を計算するのにも使われます。Django は、メモリ上のモデルの集まりのすべての変更点を順番にたどって行き、最後に <code class="docutils literal notranslate"><span class="pre">makemigrations</span></code> した時のモデルの状態を理解します。そして、そのモデルと <code class="docutils literal notranslate"><span class="pre">models.py</span></code> ファイルにあるモデルとを比較し、行った変更に対して作業を行うのです。</p>
<p>ごく稀にマイグレーションファイルを手で修正しなければならないことがありますが、必要があればすべて手で書くことも特に難しい作業ではありません。複雑なデータベース操作の中には自動的には検出できないものもあり、その場合にはマイグレーションを手で書くことが必須になることがあります。でも必要な場合には、自分の手で書くのを怖がらないでください。</p>
<section id="s-custom-fields">
<span id="custom-fields"></span><h3>カスタムフィールド<a class="headerlink" href="#custom-fields" title="Link to this heading">¶</a></h3>
<p>すでにマイグレートしたカスタムのフィールドの位置引数の数を変更しようとすると、<code class="docutils literal notranslate"><span class="pre">TypeError</span></code> が発生してしまします。古いマイグレーションは、修正した <code class="docutils literal notranslate"><span class="pre">__init__</span></code> メソッドを古い引数で呼んでしまいます。そこで、新しい引数が必要な場合は、キーワード引数を作り、コンストラクタ内に <code class="docutils literal notranslate"><span class="pre">assert</span> <span class="pre">'argument_name'</span> <span class="pre">in</span> <span class="pre">kwargs</span></code> のような一文を追加してください。</p>
</section>
<section id="s-model-managers">
<span id="s-using-managers-in-migrations"></span><span id="model-managers"></span><span id="using-managers-in-migrations"></span><h3>モデルマネージャ<a class="headerlink" href="#model-managers" title="Link to this heading">¶</a></h3>
<p>オプションとして、マネージャをマイグレーションにシリアライズして、<a class="reference internal" href="../ref/migration-operations.html#django.db.migrations.operations.RunPython" title="django.db.migrations.operations.RunPython"><code class="xref py py-class docutils literal notranslate"><span class="pre">RunPython</span></code></a> の中で使えるようにすることができます。それには次のように、マネージャクラスの中で <code class="docutils literal notranslate"><span class="pre">use_in_migrations</span></code> 属性を定義します。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">MyManager</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Manager</span><span class="p">):</span>
    <span class="n">use_in_migrations</span> <span class="o">=</span> <span class="kc">True</span>


<span class="k">class</span><span class="w"> </span><span class="nc">MyModel</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">objects</span> <span class="o">=</span> <span class="n">MyManager</span><span class="p">()</span>
</pre></div>
</div>
<p>もし <a class="reference internal" href="db/managers.html#django.db.models.from_queryset" title="django.db.models.from_queryset"><code class="xref py py-meth docutils literal notranslate"><span class="pre">from_queryset()</span></code></a> 関数で動的に生成されたマネージャクラスを使うなら、インポートできるように生成されたクラスを継承する必要があります。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">MyManager</span><span class="p">(</span><span class="n">MyBaseManager</span><span class="o">.</span><span class="n">from_queryset</span><span class="p">(</span><span class="n">CustomQuerySet</span><span class="p">)):</span>
    <span class="n">use_in_migrations</span> <span class="o">=</span> <span class="kc">True</span>


<span class="k">class</span><span class="w"> </span><span class="nc">MyModel</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">objects</span> <span class="o">=</span> <span class="n">MyManager</span><span class="p">()</span>
</pre></div>
</div>
<p>それに伴う影響については、マイグレーションにおける <a class="reference internal" href="#historical-models"><span class="std std-ref">履歴上のモデル</span></a> のメモも参考にしてください。</p>
</section>
<section id="s-initial-migrations">
<span id="initial-migrations"></span><h3>初期マイグレーション<a class="headerlink" href="#initial-migrations" title="Link to this heading">¶</a></h3>
<dl class="py attribute">
<dt class="sig sig-object py" id="django.db.migrations.Migration.initial">
<span class="sig-prename descclassname"><span class="pre">Migration.</span></span><span class="sig-name descname"><span class="pre">initial</span></span><a class="headerlink" href="#django.db.migrations.Migration.initial" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<p>アプリの「初期マイグレーション」とは、そのアプリのテーブルの最初のバージョンを作成するマイグレーションです。通常、アプリの初期マイグレーションは1つですが、モデルの相互依存関係が複雑な場合は2つ以上になることもあります。</p>
<p>初期マイグレーションはマイグレーションクラスの <code class="docutils literal notranslate"><span class="pre">initial</span> <span class="pre">=</span> <span class="pre">True</span></code> クラス属性でマークされます。もし <code class="docutils literal notranslate"><span class="pre">initial</span></code> クラス属性が見つからない場合、マイグレーションはアプリ内で最初のマイグレーションであれば（つまり、同じアプリ内の他のマイグレーションに依存していなければ）、&quot;初期 &quot;とみなされます。</p>
<p><a class="reference internal" href="../ref/django-admin.html#cmdoption-migrate-fake-initial"><code class="xref std std-option docutils literal notranslate"><span class="pre">migrate</span> <span class="pre">--fake-initial</span></code></a> オプションを使うと、これらの初期マイグレーションは特別に扱われます。1 つ以上のテーブルを作成するマイグレーション (<code class="docutils literal notranslate"><span class="pre">CreateModel</span></code> オペレーション) では、 Django はそれらのテーブルが既にデータベースに存在するかどうかをチェックし、存在する場合にはマイグレーションをフェイク適用します。同様に、1つ以上のフィールドを追加する最初のマイグレーション (<code class="docutils literal notranslate"><span class="pre">AddField</span></code> オペレーション) では、 Django はそれぞれのカラムが既にデータベースに存在するかどうかをチェックし、存在すればマイグレーションをフェイク適用します。 <code class="docutils literal notranslate"><span class="pre">--fake-initial</span></code> がなければ、初期マイグレーションは他のマイグレーションと同じように扱われます。</p>
</section>
<section id="s-history-consistency">
<span id="s-migration-history-consistency"></span><span id="history-consistency"></span><span id="migration-history-consistency"></span><h3>履歴の一貫性<a class="headerlink" href="#history-consistency" title="Link to this heading">¶</a></h3>
<p>前に説明したように、2つの開発ブランチを結合するときに、マイグレーションを手動で線形化する必要があるかもしれません。マイグレーションの依存関係を編集しているときに、マイグレーションは適用されたのに、 その依存関係のいくつかは適用されていないというような、一貫性のない履歴状態をうっかり作ってしまうことがあります。これは依存関係が正しくないことを強く示しているので、 Django はそれが修正されるまでマイグレーションを実行したり、新しいマイグレーショ ンを作成したりすることを拒否します。複数のデータベースを使う場合、 <a class="reference internal" href="db/multi-db.html#topics-db-multi-db-routing"><span class="std std-ref">データベースルーター</span></a> の <a class="reference internal" href="db/multi-db.html#allow_migrate" title="allow_migrate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">allow_migrate()</span></code></a> メソッドを使うことで、 <a class="reference internal" href="../ref/django-admin.html#django-admin-makemigrations"><code class="xref std std-djadmin docutils literal notranslate"><span class="pre">makemigrations</span></code></a> がどのデータベースをチェックし、履歴が一貫しているかを制御できます。</p>
</section>
</section>
<section id="s-adding-migrations-to-apps">
<span id="adding-migrations-to-apps"></span><h2>アプリにマイグレーションを追加する<a class="headerlink" href="#adding-migrations-to-apps" title="Link to this heading">¶</a></h2>
<p>新しいアプリはマイグレーションを受け入れるようにあらかじめ設定されているので、ある程度変更したら <a class="reference internal" href="../ref/django-admin.html#django-admin-makemigrations"><code class="xref std std-djadmin docutils literal notranslate"><span class="pre">makemigrations</span></code></a> を実行してマイグレーションを追加できます。</p>
<p>もしあなたのアプリがすでにモデルとデータベーステーブルを持っていて、マイグレーションをまだ持っていない場合（たとえば、以前の Django バージョンに対して作成した場合）、下記のコマンドを実行することでマイグレーションを使うように変換する必要があります:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>python<span class="w"> </span>manage.py<span class="w"> </span>makemigrations<span class="w"> </span>your_app_label
</pre></div>
</div>
<p>これにより、アプリの新しい初期マイグレーションが作成されます。次に、<code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">manage.py</span> <span class="pre">migrate</span> <span class="pre">--fake-initial</span></code> を実行すると、Djangoは初期マイグレーションがあり、<em>かつ</em> 作成しようとするテーブルが既に存在することを検出し、マイグレーションを既に適用済みとしてマークします。 (<a class="reference internal" href="../ref/django-admin.html#cmdoption-migrate-fake-initial"><code class="xref std std-option docutils literal notranslate"><span class="pre">migrate</span> <span class="pre">--fake-initial</span></code></a> フラグがない場合、コマンドは作成しようとするテーブルが既に存在するためエラーになります。)</p>
<p>ただし、これは以下の2つの条件を満たした場合にのみ有効です:</p>
<ul class="simple">
<li><p>テーブルを作ってからモデルを変更していません。マイグレーションを動作させるためには、初期マイグレーションを <em>最初に</em> 行い、それから変更を加える必要があります。Django は変更をデータベースではなくマイグレーションファイルと比較するからです。</p></li>
<li><p>データベースを手動で編集していないので、 Django はデータベースがモデルにマッチしていないことを検知できません。マイグレーションがこれらのテーブルを変更しようとするとエラーが出るだけです。</p></li>
</ul>
</section>
<section id="s-reversing-migrations">
<span id="s-id2"></span><span id="reversing-migrations"></span><span id="id2"></span><h2>マイグレーションを元に戻す<a class="headerlink" href="#reversing-migrations" title="Link to this heading">¶</a></h2>
<p>マイグレーションを元に戻すには、  <a class="reference internal" href="../ref/django-admin.html#django-admin-migrate"><code class="xref std std-djadmin docutils literal notranslate"><span class="pre">migrate</span></code></a> で前のマイグレーションの番号を渡します。たとえば、マイグレーション <code class="docutils literal notranslate"><span class="pre">books.0003</span></code> を元に戻すには、次のようにします:</p>
<div class="console-block" id="console-block-0">
<input class="c-tab-unix" id="c-tab-0-unix" type="radio" name="console-0" checked>
<label for="c-tab-0-unix" title="Linux/macOS">&#xf17c/&#xf179</label>
<input class="c-tab-win" id="c-tab-0-win" type="radio" name="console-0">
<label for="c-tab-0-win" title="Windows">&#xf17a</label>
<section class="c-content-unix" id="c-content-0-unix">
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>python<span class="w"> </span>manage.py<span class="w"> </span>migrate<span class="w"> </span>books<span class="w"> </span><span class="m">0002</span>
<span class="go">Operations to perform:</span>
<span class="go">  Target specific migration: 0002_auto, from books</span>
<span class="go">Running migrations:</span>
<span class="go">  Rendering model states... DONE</span>
<span class="go">  Unapplying books.0003_auto... OK</span>
</pre></div>
</div>
</section>
<section class="c-content-win" id="c-content-0-win">
<div class="highlight"><pre><span></span><span class="gp">...\&gt;</span> py manage.py migrate books 0002
<span class="go">Operations to perform:</span>
<span class="go">  Target specific migration: 0002_auto, from books</span>
<span class="go">Running migrations:</span>
<span class="go">  Rendering model states... DONE</span>
<span class="go">  Unapplying books.0003_auto... OK</span>
</pre></div>
</section>
</div>
<p>アプリに適用されたマイグレーションをすべて元に戻したい場合は、<code class="docutils literal notranslate"><span class="pre">zero</span></code> という名前を使います：</p>
<div class="console-block" id="console-block-1">
<input class="c-tab-unix" id="c-tab-1-unix" type="radio" name="console-1" checked>
<label for="c-tab-1-unix" title="Linux/macOS">&#xf17c/&#xf179</label>
<input class="c-tab-win" id="c-tab-1-win" type="radio" name="console-1">
<label for="c-tab-1-win" title="Windows">&#xf17a</label>
<section class="c-content-unix" id="c-content-1-unix">
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>python<span class="w"> </span>manage.py<span class="w"> </span>migrate<span class="w"> </span>books<span class="w"> </span>zero
<span class="go">Operations to perform:</span>
<span class="go">  Unapply all migrations: books</span>
<span class="go">Running migrations:</span>
<span class="go">  Rendering model states... DONE</span>
<span class="go">  Unapplying books.0002_auto... OK</span>
<span class="go">  Unapplying books.0001_initial... OK</span>
</pre></div>
</div>
</section>
<section class="c-content-win" id="c-content-1-win">
<div class="highlight"><pre><span></span><span class="gp">...\&gt;</span> py manage.py migrate books zero
<span class="go">Operations to perform:</span>
<span class="go">  Unapply all migrations: books</span>
<span class="go">Running migrations:</span>
<span class="go">  Rendering model states... DONE</span>
<span class="go">  Unapplying books.0002_auto... OK</span>
<span class="go">  Unapplying books.0001_initial... OK</span>
</pre></div>
</section>
</div>
<p>マイグレーションに不可逆な操作が含まれている場合、そのマイグレーションは不可逆です。このようなマイグレーションを元に戻そうとすると <code class="docutils literal notranslate"><span class="pre">IrreversibleError</span></code> が発生します:</p>
<div class="console-block" id="console-block-2">
<input class="c-tab-unix" id="c-tab-2-unix" type="radio" name="console-2" checked>
<label for="c-tab-2-unix" title="Linux/macOS">&#xf17c/&#xf179</label>
<input class="c-tab-win" id="c-tab-2-win" type="radio" name="console-2">
<label for="c-tab-2-win" title="Windows">&#xf17a</label>
<section class="c-content-unix" id="c-content-2-unix">
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>python<span class="w"> </span>manage.py<span class="w"> </span>migrate<span class="w"> </span>books<span class="w"> </span><span class="m">0002</span>
<span class="go">Operations to perform:</span>
<span class="go">  Target specific migration: 0002_auto, from books</span>
<span class="go">Running migrations:</span>
<span class="go">  Rendering model states... DONE</span>
<span class="go">  Unapplying books.0003_auto...Traceback (most recent call last):</span>
<span class="go">django.db.migrations.exceptions.IrreversibleError: Operation &lt;RunSQL  sql=&#39;DROP TABLE demo_books&#39;&gt; in books.0003_auto is not reversible</span>
</pre></div>
</div>
</section>
<section class="c-content-win" id="c-content-2-win">
<div class="highlight"><pre><span></span><span class="gp">...\&gt;</span> py manage.py migrate books 0002
<span class="go">Operations to perform:</span>
<span class="go">  Target specific migration: 0002_auto, from books</span>
<span class="go">Running migrations:</span>
<span class="go">  Rendering model states... DONE</span>
<span class="go">  Unapplying books.0003_auto...Traceback (most recent call last):</span>
<span class="gp">django.db.migrations.exceptions.IrreversibleError: Operation &lt;RunSQL  sql=&#39;DROP TABLE demo_books&#39;&gt;</span> in books.0003_auto is not reversible
</pre></div>
</section>
</div>
</section>
<section id="s-historical-models">
<span id="s-id3"></span><span id="historical-models"></span><span id="id3"></span><h2>履歴上のモデル<a class="headerlink" href="#historical-models" title="Link to this heading">¶</a></h2>
<p>マイグレーションを実行するとき、 Django はマイグレーションファイルに保存されたモデルの過去のバージョンから作業しています。 <a class="reference internal" href="../ref/migration-operations.html#django.db.migrations.operations.RunPython" title="django.db.migrations.operations.RunPython"><code class="xref py py-class docutils literal notranslate"><span class="pre">RunPython</span></code></a> オペレーションを使って Python コードを書いたり、データベースルーターに <code class="docutils literal notranslate"><span class="pre">allow_migrate</span></code> メソッドがある場合、 直接インポートするのではなく、 これらの履歴上のモデルバージョンを <strong>使う必要があります</strong> 。</p>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>履歴上のモデルを使用するのではなく、モデルを直接インポートした場合、マイグレーションは初期にはうまくいくかもしれませんが、将来、古いマイグレーションを再実行しようとしたときに（通常は新しいインストールをセットアップし、データベースをセットアップするためにすべてのマイグレーションを実行したときに）失敗します。</p>
<p>つまり、履歴上のモデルの問題はすぐには明らかにならない可能性があります。このような不具合が発生した場合は、直接インポートするのではなく、履歴上のモデルを使用するようにマイグレーションを編集し、その変更をコミットすれば問題ありません。</p>
</div>
<p>任意のPythonコードをシリアライズすることは不可能なので、これらの履歴上のモデルはあなたが定義したカスタムメソッドを持ちません。しかし、同じフィールド、リレーションシップ、マネージャ(<code class="docutils literal notranslate"><span class="pre">use_in_migrations</span> <span class="pre">=</span> <span class="pre">True</span></code> を持つものに限られます)、<code class="docutils literal notranslate"><span class="pre">Meta</span></code> オプション(バージョン管理されているので、現在のものとは異なるかもしれません)を持つことになります。</p>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>つまり、マイグレーションでオブジェクトにアクセスするときに、カスタムメソッド <code class="docutils literal notranslate"><span class="pre">save()</span></code> が呼び出されることはありませんし、カスタムコンストラクタやカスタムインスタンスメソッドもありません。適切な計画を立ててください！</p>
</div>
<p><code class="docutils literal notranslate"><span class="pre">upload_to</span></code> や <code class="docutils literal notranslate"><span class="pre">limit_choices_to</span></code> のようなフィールドオプションの関数への参照や、 <code class="docutils literal notranslate"><span class="pre">use_in_migrations</span> <span class="pre">=</span> <span class="pre">True</span></code> を持つマネージャのモデルマネージャ宣言はマイグレーションでシリアライズされます。 <a class="reference internal" href="../howto/custom-model-fields.html"><span class="doc">カスタムのモデルフィールド</span></a> もマイグレーションで直接インポートされるので、残しておく必要があります。</p>
<p>加えて、モデルの具体的な基底クラスはポインタとして保存されるので、それらへの参照を含むマイグレーションが存在する限り、常に基底クラスを保持しておく必要があります。 プラス面として、これらの基底クラスからのメソッドとマネージャは普通に継承されるので、どうしてもこれらにアクセスする必要がある場合は、スーパークラスに移動させることを選択できます。</p>
<p>古い参照を削除するには、<a class="reference internal" href="#migration-squashing"><span class="std std-ref">マイグレーションをスカッシュ（squash）</span></a> するか、参照数が少ない場合はマイグレーションファイルにコピーします。</p>
</section>
<section id="s-considerations-when-removing-model-fields">
<span id="s-migrations-removing-model-fields"></span><span id="considerations-when-removing-model-fields"></span><span id="migrations-removing-model-fields"></span><h2>モデルのフィールドを削除するときに考えるべきこと<a class="headerlink" href="#considerations-when-removing-model-fields" title="Link to this heading">¶</a></h2>
<p>前のセクションで説明した「履歴上の機能への参照」の注意事項と同様に、プロジェクトやサードパーティアプリからカスタムモデルフィールドを削除すると、それらが古いマイグレーションで参照されている場合に問題が発生します。</p>
<p>このような状況を解決するために、 Django は <a class="reference internal" href="checks.html"><span class="doc">システムチェックフレームワーク</span></a> を使ってモデルフィールドの非推奨化を支援するモデルフィールド属性をいくつか提供しています。</p>
<p>以下のように、<code class="docutils literal notranslate"><span class="pre">system_check_deprecated_details</span></code> 属性をモデルフィールドに追加します:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">IPAddressField</span><span class="p">(</span><span class="n">Field</span><span class="p">):</span>
    <span class="n">system_check_deprecated_details</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;msg&quot;</span><span class="p">:</span> <span class="p">(</span>
            <span class="s2">&quot;IPAddressField has been deprecated. Support for it (except &quot;</span>
            <span class="s2">&quot;in historical migrations) will be removed in Django 1.9.&quot;</span>
        <span class="p">),</span>
        <span class="s2">&quot;hint&quot;</span><span class="p">:</span> <span class="s2">&quot;Use GenericIPAddressField instead.&quot;</span><span class="p">,</span>  <span class="c1"># optional</span>
        <span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="s2">&quot;fields.W900&quot;</span><span class="p">,</span>  <span class="c1"># pick a unique ID for your field.</span>
    <span class="p">}</span>
</pre></div>
</div>
<p>あなたが選んだ非推奨期間 (Django 自体のフィールドでは 2、3 回の機能リリース) が経過したら、 <code class="docutils literal notranslate"><span class="pre">system_check_deprecated_details</span></code> 属性を <code class="docutils literal notranslate"><span class="pre">system_check_removed_details</span></code> に変更し、次のように辞書を更新してください:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">IPAddressField</span><span class="p">(</span><span class="n">Field</span><span class="p">):</span>
    <span class="n">system_check_removed_details</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;msg&quot;</span><span class="p">:</span> <span class="p">(</span>
            <span class="s2">&quot;IPAddressField has been removed except for support in &quot;</span>
            <span class="s2">&quot;historical migrations.&quot;</span>
        <span class="p">),</span>
        <span class="s2">&quot;hint&quot;</span><span class="p">:</span> <span class="s2">&quot;Use GenericIPAddressField instead.&quot;</span><span class="p">,</span>
        <span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="s2">&quot;fields.E900&quot;</span><span class="p">,</span>  <span class="c1"># pick a unique ID for your field.</span>
    <span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">__init__()</span></code>、<code class="docutils literal notranslate"><span class="pre">deconstruct()</span></code>、<code class="docutils literal notranslate"><span class="pre">get_internal_type()</span></code> などのデータベースマイグレーションで動作するために必要なフィールドのメソッドは残しておく必要があります。フィールドを参照するマイグレーションが存在する限り、このスタブフィールドを保持します。たとえば、マイグレーションを潰して（squashして）古いマイグレーションを削除したら、フィールドを完全に削除できるはずです。</p>
</section>
<section id="s-data-migrations">
<span id="s-id4"></span><span id="data-migrations"></span><span id="id4"></span><h2>データのマイグレーション<a class="headerlink" href="#data-migrations" title="Link to this heading">¶</a></h2>
<p>データベースのスキーマを変更するだけでなく、必要であれば、マイグレーションを使用して、スキーマと連動してデータベース自体のデータを変更することもできます。</p>
<p>データを変更するマイグレーションは通常「データマイグレーション」と呼びます。スキーママイグレーションと並行して、別のマイグレーションとして記述するのが最適です。</p>
<p>Django はスキーママイグレーションのようにデータマイグレーションを自動生成することはできませんが、書くのはそれほど難しくありません。Django のマイグレーションファイルは <a class="reference internal" href="../ref/migration-operations.html"><span class="doc">オペレーション</span></a> で構成され、データマイグレーションに使う主なオペレーションは <a class="reference internal" href="../ref/migration-operations.html#django.db.migrations.operations.RunPython" title="django.db.migrations.operations.RunPython"><code class="xref py py-class docutils literal notranslate"><span class="pre">RunPython</span></code></a> です。</p>
<p>手始めに、作業可能な空のマイグレーションファイルを作成してください (Django がファイルを適切な場所に置き、名前を提案し、依存関係を追加してくれます):</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>python<span class="w"> </span>manage.py<span class="w"> </span>makemigrations<span class="w"> </span>--empty<span class="w"> </span>yourappname
</pre></div>
</div>
<p>そして、そのファイルを開いてください。次のようなファイルになっているはずです:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Generated by Django A.B on YYYY-MM-DD HH:MM</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">django.db</span><span class="w"> </span><span class="kn">import</span> <span class="n">migrations</span>


<span class="k">class</span><span class="w"> </span><span class="nc">Migration</span><span class="p">(</span><span class="n">migrations</span><span class="o">.</span><span class="n">Migration</span><span class="p">):</span>
    <span class="n">dependencies</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">(</span><span class="s2">&quot;yourappname&quot;</span><span class="p">,</span> <span class="s2">&quot;0001_initial&quot;</span><span class="p">),</span>
    <span class="p">]</span>

    <span class="n">operations</span> <span class="o">=</span> <span class="p">[]</span>
</pre></div>
</div>
<p>あとは新しい関数を作って <a class="reference internal" href="../ref/migration-operations.html#django.db.migrations.operations.RunPython" title="django.db.migrations.operations.RunPython"><code class="xref py py-class docutils literal notranslate"><span class="pre">RunPython</span></code></a> に使ってもらうだけです。 <a class="reference internal" href="../ref/migration-operations.html#django.db.migrations.operations.RunPython" title="django.db.migrations.operations.RunPython"><code class="xref py py-class docutils literal notranslate"><span class="pre">RunPython</span></code></a> は、引数として2つの引数を取る呼び出し可能オブジェクトを期待します。1つ目は <a class="reference internal" href="../ref/applications.html"><span class="doc">アプリ レジストリ</span></a> で、マイグレーションが履歴のどこに位置するかに合わせて、履歴上のモデルのバージョンを読み込んだものです。そしてもう1つは <a class="reference internal" href="../ref/schema-editor.html"><span class="doc">スキーマエディタ</span></a> で、手動でデータベースのスキーマを変更するのに使用できます (ただし、これをやるとマイグレーション自動検出器が混乱してしまうので注意してください！)。</p>
<p>新しい <code class="docutils literal notranslate"><span class="pre">name</span></code> フィールドに <code class="docutils literal notranslate"><span class="pre">first_name</span></code> と <code class="docutils literal notranslate"><span class="pre">last_name</span></code> を組み合わせた値を入力するマイグレーションを書いてみましょう (すべての人が姓と名を持つわけではないことに気がつきました)。あとは履歴上のモデルを使用して行をイテレートするだけです:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">django.db</span><span class="w"> </span><span class="kn">import</span> <span class="n">migrations</span>


<span class="k">def</span><span class="w"> </span><span class="nf">combine_names</span><span class="p">(</span><span class="n">apps</span><span class="p">,</span> <span class="n">schema_editor</span><span class="p">):</span>
    <span class="c1"># We can&#39;t import the Person model directly as it may be a newer</span>
    <span class="c1"># version than this migration expects. We use the historical version.</span>
    <span class="n">Person</span> <span class="o">=</span> <span class="n">apps</span><span class="o">.</span><span class="n">get_model</span><span class="p">(</span><span class="s2">&quot;yourappname&quot;</span><span class="p">,</span> <span class="s2">&quot;Person&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">person</span> <span class="ow">in</span> <span class="n">Person</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
        <span class="n">person</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">person</span><span class="o">.</span><span class="n">first_name</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">person</span><span class="o">.</span><span class="n">last_name</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="n">person</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>


<span class="k">class</span><span class="w"> </span><span class="nc">Migration</span><span class="p">(</span><span class="n">migrations</span><span class="o">.</span><span class="n">Migration</span><span class="p">):</span>
    <span class="n">dependencies</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">(</span><span class="s2">&quot;yourappname&quot;</span><span class="p">,</span> <span class="s2">&quot;0001_initial&quot;</span><span class="p">),</span>
    <span class="p">]</span>

    <span class="n">operations</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">migrations</span><span class="o">.</span><span class="n">RunPython</span><span class="p">(</span><span class="n">combine_names</span><span class="p">),</span>
    <span class="p">]</span>
</pre></div>
</div>
<p>これが完了したら、通常通り <code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">manage.py</span> <span class="pre">migrate</span></code> を実行し、他のマイグレーションと並行してデータマイグレーションを実行します。</p>
<p>2 番目の呼び出し可能オブジェクトを <a class="reference internal" href="../ref/migration-operations.html#django.db.migrations.operations.RunPython" title="django.db.migrations.operations.RunPython"><code class="xref py py-class docutils literal notranslate"><span class="pre">RunPython</span></code></a> に渡すことで、逆方向へのマイグレーションの際に実行したいロジックを実行できます。この呼び出し可能オブジェクトが省略された場合、逆方向にマイグレーションすると例外が発生します。</p>
<section id="s-accessing-models-from-other-apps">
<span id="accessing-models-from-other-apps"></span><h3>他のアプリからモデルにアクセスする<a class="headerlink" href="#accessing-models-from-other-apps" title="Link to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">RunPython</span></code> 関数で、マイグレーションが配置されているアプリ以外のアプリのモデルを使用する場合、マイグレーションの <code class="docutils literal notranslate"><span class="pre">dependencies</span></code> 属性には、関係する各アプリの最新のマイグレーションが含まれている必要があります。含まれていない場合、 <code class="docutils literal notranslate"><span class="pre">RunPython</span></code> 関数内で <code class="docutils literal notranslate"><span class="pre">apps.get_model()</span></code> を使用してモデルを取得しようとすると、 <code class="docutils literal notranslate"><span class="pre">LookupError:</span> <span class="pre">No</span> <span class="pre">installed</span> <span class="pre">app</span> <span class="pre">with</span> <span class="pre">label</span> <span class="pre">'myappname'</span></code> のようなエラーが発生する可能性があります。</p>
<p>次の例では、<code class="docutils literal notranslate"><span class="pre">app1</span></code> のマイグレーションで、<code class="docutils literal notranslate"><span class="pre">app2</span></code> のモデルを使用する必要があります。私たちは <code class="docutils literal notranslate"><span class="pre">move_m1</span></code> が両方のアプリのモデルにアクセスする必要があるという事実以外、その詳細には関心がありません。そのため、<code class="docutils literal notranslate"><span class="pre">app2</span></code> の最後のマイグレーションを指定する依存関係を追加しました:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Migration</span><span class="p">(</span><span class="n">migrations</span><span class="o">.</span><span class="n">Migration</span><span class="p">):</span>
    <span class="n">dependencies</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">(</span><span class="s2">&quot;app1&quot;</span><span class="p">,</span> <span class="s2">&quot;0001_initial&quot;</span><span class="p">),</span>
        <span class="c1"># added dependency to enable using models from app2 in move_m1</span>
        <span class="p">(</span><span class="s2">&quot;app2&quot;</span><span class="p">,</span> <span class="s2">&quot;0004_foobar&quot;</span><span class="p">),</span>
    <span class="p">]</span>

    <span class="n">operations</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">migrations</span><span class="o">.</span><span class="n">RunPython</span><span class="p">(</span><span class="n">move_m1</span><span class="p">),</span>
    <span class="p">]</span>
</pre></div>
</div>
</section>
<section id="s-more-advanced-migrations">
<span id="more-advanced-migrations"></span><h3>より高度なマイグレーション<a class="headerlink" href="#more-advanced-migrations" title="Link to this heading">¶</a></h3>
<p>より高度なマイグレーション操作に興味があったり、自分でマイグレーションを書けるようになりたければ、 <a class="reference internal" href="../ref/migration-operations.html"><span class="doc">マイグレーション操作のリファレンス</span></a> と <a class="reference internal" href="../howto/writing-migrations.html"><span class="doc">マイグレーションを書く</span></a> の &quot;how-to&quot; を参照してください。</p>
</section>
</section>
<section id="s-squashing-migrations">
<span id="s-migration-squashing"></span><span id="squashing-migrations"></span><span id="migration-squashing"></span><h2>マイグレーションのスカッシュ (Squash)<a class="headerlink" href="#squashing-migrations" title="Link to this heading">¶</a></h2>
<p>マイグレーションは自由に作成し、その数について心配する必要はありません。マイグレーションコードは、一度に数百ものマイグレーションを効率的に扱えるよう最適化されています。しかし、最終的には数百ものマイグレーションを数個にまとめたいと思う時が来ます。その時には、マイグレーションの圧縮 (squash) が役立ちます。</p>
<p>スカッシュ (squash: 潰す) とは、既存の多数のマイグレーションから、同じ変更を表すマイグレーションを1つ (場合によっては数個) に減らすことです。</p>
<p>Django は、既存のマイグレーションをすべて取り出し、その <code class="docutils literal notranslate"><span class="pre">Operation</span></code> を抽出して順番に並べ、オプティマイザを実行してリストの長さを短くしようとします。 例えば、 <a class="reference internal" href="../ref/migration-operations.html#django.db.migrations.operations.CreateModel" title="django.db.migrations.operations.CreateModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">CreateModel</span></code></a> と <a class="reference internal" href="../ref/migration-operations.html#django.db.migrations.operations.DeleteModel" title="django.db.migrations.operations.DeleteModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">DeleteModel</span></code></a> が互いに打ち消し合うことも、 <a class="reference internal" href="../ref/migration-operations.html#django.db.migrations.operations.AddField" title="django.db.migrations.operations.AddField"><code class="xref py py-class docutils literal notranslate"><span class="pre">AddField</span></code></a> が <a class="reference internal" href="../ref/migration-operations.html#django.db.migrations.operations.CreateModel" title="django.db.migrations.operations.CreateModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">CreateModel</span></code></a> にロールインできることも知っています。</p>
<p>操作シーケンスを可能な限り減らしたら (どれだけ減らせるかは、モデルがどれだけ密接に絡み合っているか、また <code class="docutils literal notranslate"><span class="pre">elidable</span></code> とマークされていない限り最適化できない <a class="reference internal" href="../ref/migration-operations.html#django.db.migrations.operations.RunSQL" title="django.db.migrations.operations.RunSQL"><code class="xref py py-class docutils literal notranslate"><span class="pre">RunSQL</span></code></a> や <a class="reference internal" href="../ref/migration-operations.html#django.db.migrations.operations.RunPython" title="django.db.migrations.operations.RunPython"><code class="xref py py-class docutils literal notranslate"><span class="pre">RunPython</span></code></a> 操作があるかどうかによって決まります)、Django はそれを新しいマイグレーションファイル群に書き戻します。</p>
<p>これらのファイルは、以前にスカッシュされたマイグレーションを置き換えるものとしてマークされているため、古いマイグレーションファイルと共存でき、Djangoは履歴のどこにいるかに応じて賢く切り替えます。スカッシュしたマイグレーションセットの途中であれば、それらを使用し続け、最後に達した後でスカッシュされた履歴に切り替えます。一方、新しいインストールでは新しいスカッシュマイグレーションが使用され、古いものはすべてスキップされます。</p>
<p>これにより、まだ完全に最新の状態ではない本番システムを混乱させずにマイグレーションを圧縮できます。推奨されるプロセスは、古いファイルを保持しながらスカッシュし、コミットしてリリースし、すべてのシステムが新しいリリースでアップグレードされるのを待つことです (または、サードパーティのプロジェクトであれば、ユーザーがリリースを順番にアップグレードするようにします)。その後、古いファイルを削除し、コミットして2回目のリリースを行います。</p>
<p>このプロセスを支えるコマンドは <a class="reference internal" href="../ref/django-admin.html#django-admin-squashmigrations"><code class="xref std std-djadmin docutils literal notranslate"><span class="pre">squashmigrations</span></code></a> です。スカッシュしたいアプリのラベルとマイグレーション名を指定して実行すると、作業が始まります。</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>./manage.py<span class="w"> </span>squashmigrations<span class="w"> </span>myapp<span class="w"> </span><span class="m">0004</span>
Will<span class="w"> </span>squash<span class="w"> </span>the<span class="w"> </span>following<span class="w"> </span>migrations:
<span class="w"> </span>-<span class="w"> </span>0001_initial
<span class="w"> </span>-<span class="w"> </span>0002_some_change
<span class="w"> </span>-<span class="w"> </span>0003_another_change
<span class="w"> </span>-<span class="w"> </span>0004_undo_something
Do<span class="w"> </span>you<span class="w"> </span>wish<span class="w"> </span>to<span class="w"> </span>proceed?<span class="w"> </span><span class="o">[</span>y/N<span class="o">]</span><span class="w"> </span>y
Optimizing...
<span class="w">  </span>Optimized<span class="w"> </span>from<span class="w"> </span><span class="m">12</span><span class="w"> </span>operations<span class="w"> </span>to<span class="w"> </span><span class="m">7</span><span class="w"> </span>operations.
Created<span class="w"> </span>new<span class="w"> </span>squashed<span class="w"> </span>migration<span class="w"> </span>/home/andrew/Programs/DjangoTest/test/migrations/0001_squashed_0004_undo_something.py
<span class="w">  </span>You<span class="w"> </span>should<span class="w"> </span>commit<span class="w"> </span>this<span class="w"> </span>migration<span class="w"> </span>but<span class="w"> </span>leave<span class="w"> </span>the<span class="w"> </span>old<span class="w"> </span>ones<span class="w"> </span><span class="k">in</span><span class="w"> </span>place<span class="p">;</span>
<span class="w">  </span>the<span class="w"> </span>new<span class="w"> </span>migration<span class="w"> </span>will<span class="w"> </span>be<span class="w"> </span>used<span class="w"> </span><span class="k">for</span><span class="w"> </span>new<span class="w"> </span>installs.<span class="w"> </span>Once<span class="w"> </span>you<span class="w"> </span>are<span class="w"> </span>sure
<span class="w">  </span>all<span class="w"> </span>instances<span class="w"> </span>of<span class="w"> </span>the<span class="w"> </span>codebase<span class="w"> </span>have<span class="w"> </span>applied<span class="w"> </span>the<span class="w"> </span>migrations<span class="w"> </span>you<span class="w"> </span>squashed,
<span class="w">  </span>you<span class="w"> </span>can<span class="w"> </span>delete<span class="w"> </span>them.
</pre></div>
</div>
<p><a class="reference internal" href="../ref/django-admin.html#cmdoption-squashmigrations-squashed-name"><code class="xref std std-option docutils literal notranslate"><span class="pre">squashmigrations</span> <span class="pre">--squashed-name</span></code></a> オプションを使用すると、自動生成された名前を使用する代わりに、スカッシュされたマイグレーションの名前を指定できます。</p>
<p>Djangoのモデル間の依存関係は非常に複雑になる可能性があり、マイグレーションのスカッシュによっては正常に実行されないマイグレーションが発生することがあります。これには、最適化されていない場合 (この場合は <code class="docutils literal notranslate"><span class="pre">--no-optimize</span></code> オプションを試すか、問題を報告してください) や、<code class="docutils literal notranslate"><span class="pre">CircularDependencyError</span></code> が発生した場合が含まれます。後者の場合は、手動で解決する必要があります。</p>
<p><code class="docutils literal notranslate"><span class="pre">CircularDependencyError</span></code> を手動で解決するには、循環依存ループ内の外部キーの1つを別のマイグレーションに分割し、その他のアプリへの依存をそれと一緒に移動します。不明な場合は、モデルから新しいマイグレーションを作成するように依頼されたときに <a class="reference internal" href="../ref/django-admin.html#django-admin-makemigrations"><code class="xref std std-djadmin docutils literal notranslate"><span class="pre">makemigrations</span></code></a> が問題をどのように扱うかを確認してください。将来のDjangoリリースでは、 <a class="reference internal" href="../ref/django-admin.html#django-admin-squashmigrations"><code class="xref std std-djadmin docutils literal notranslate"><span class="pre">squashmigrations</span></code></a> がこれらのエラーを自動的に解決しようとする機能が追加される予定です。</p>
<p>マイグレーションをスカッシュしたら、それを置き換えるマイグレーションと共にコミットし、アプリケーションを実行しているすべてのインスタンスにこの変更を配布し、データベースに変更を記録するために <code class="docutils literal notranslate"><span class="pre">migrate</span></code> を確実に実行してください。</p>
<p>その後、スカッシュしたマイグレーションを通常のマイグレーションに移行するには、次の手順を実行する必要があります:</p>
<ul class="simple">
<li><p>マイグレーションが置き換えるすべてのマイグレーションファイルを削除します。</p></li>
<li><p>削除されたマイグレーションに依存しているすべてのマイグレーションを、 代わりにスカッシュしたマイグレーションに依存するように更新します。</p></li>
<li><p>スカッシュしたマイグレーションの <code class="docutils literal notranslate"><span class="pre">Migration</span></code> クラスの <code class="docutils literal notranslate"><span class="pre">replaces</span></code> 属性を削除します (これで Django はそれがスカッシュしたマイグレーションだとわかります)。</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>一度マイグレーションをスカッシュしたら、通常のマイグレーションに完全に移行するまで、そのスカッシュしたマイグレーションを再度スカッシュすべきではありません。</p>
</div>
<div class="admonition-pruning-references-to-deleted-migrations admonition">
<p class="admonition-title">削除されたマイグレーションへの参照の整理</p>
<p>削除したマイグレーションの名前を将来再利用する可能性がある場合は、 <a class="reference internal" href="../ref/django-admin.html#cmdoption-migrate-prune"><code class="xref std std-option docutils literal notranslate"><span class="pre">migrate</span> <span class="pre">--prune</span></code></a> オプションを使って Django の migrations テーブルからそのマイグレーションへの参照を削除してください。</p>
</div>
</section>
<section id="s-serializing-values">
<span id="s-migration-serializing"></span><span id="serializing-values"></span><span id="migration-serializing"></span><h2>値のシリアライズ<a class="headerlink" href="#serializing-values" title="Link to this heading">¶</a></h2>
<p>マイグレーションは、モデルの古い定義が書かれた Python ファイルです。よって、マイグレーションを書くには、Django はモデルの現在の状態を取得して、その状態をシリアライズしてファイルに出力できなければなりません。</p>
<p>Django はほとんどのオブジェクトをシリアライズできますが、有効な Python 表現へと単純にはシリアライズできないオブジェクトもあります。しかし、任意の値を Python のコードにデコードするような Python の標準は存在しません(<code class="docutils literal notranslate"><span class="pre">repr()</span></code> は基本的な値にしか機能しませんし、import path は指定できません)。</p>
<p>Django がシリアライズできるのは、以下のオブジェクトです。</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">int</span></code>、<code class="docutils literal notranslate"><span class="pre">float</span></code>、<code class="docutils literal notranslate"><span class="pre">bool</span></code>、<code class="docutils literal notranslate"><span class="pre">str</span></code>、<code class="docutils literal notranslate"><span class="pre">bytes</span></code>、<code class="docutils literal notranslate"><span class="pre">None</span></code>、<code class="docutils literal notranslate"><span class="pre">NoneType</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">list</span></code>、<code class="docutils literal notranslate"><span class="pre">set</span></code>、<code class="docutils literal notranslate"><span class="pre">tuple</span></code>、<code class="docutils literal notranslate"><span class="pre">dict</span></code>、<code class="docutils literal notranslate"><span class="pre">range</span></code>。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">datetime.date</span></code>、<code class="docutils literal notranslate"><span class="pre">datetime.time</span></code>、<code class="docutils literal notranslate"><span class="pre">datetime.datetime</span></code> インスタンス (timezone-aware なものも含む)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">decimal.Decimal</span></code> インスタンス</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">enum.Enum</span></code>  または <code class="docutils literal notranslate"><span class="pre">enum.Flag</span></code> インスタンス</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">uuid.UUID</span></code> インスタンス</p></li>
<li><p>シリアライズできる <code class="docutils literal notranslate"><span class="pre">func</span></code>、<code class="docutils literal notranslate"><span class="pre">args</span></code>、<code class="docutils literal notranslate"><span class="pre">keywords</span></code> の値を持つ <a class="reference external" href="https://docs.python.org/3/library/functools.html#functools.partial" title="(in Python v3.13)"><code class="xref py py-func docutils literal notranslate"><span class="pre">functools.partial()</span></code></a> または <a class="reference external" href="https://docs.python.org/3/library/functools.html#functools.partialmethod" title="(in Python v3.13)"><code class="xref py py-class docutils literal notranslate"><span class="pre">functools.partialmethod</span></code></a> インスタンス</p></li>
<li><p><a class="reference external" href="https://docs.python.org/3/library/pathlib.html#module-pathlib" title="(in Python v3.13)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pathlib</span></code></a> から取得した純粋パスオブジェクトと具象パスオブジェクト。たとえば、<a class="reference external" href="https://docs.python.org/3/library/pathlib.html#pathlib.PosixPath" title="(in Python v3.13)"><code class="xref py py-class docutils literal notranslate"><span class="pre">pathlib.PosixPath</span></code></a> は <a class="reference external" href="https://docs.python.org/3/library/pathlib.html#pathlib.PurePosixPath" title="(in Python v3.13)"><code class="xref py py-class docutils literal notranslate"><span class="pre">pathlib.PurePosixPath</span></code></a> に変換されます。</p></li>
<li><p><a class="reference external" href="https://docs.python.org/3/library/os.html#os.PathLike" title="(in Python v3.13)"><code class="xref py py-class docutils literal notranslate"><span class="pre">os.PathLike</span></code></a> インスタンス、たとえば <a class="reference external" href="https://docs.python.org/3/library/os.html#os.DirEntry" title="(in Python v3.13)"><code class="xref py py-class docutils literal notranslate"><span class="pre">os.DirEntry</span></code></a> は、<a class="reference external" href="https://docs.python.org/3/library/os.html#os.fspath" title="(in Python v3.13)"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.fspath()</span></code></a> を使用して <code class="docutils literal notranslate"><span class="pre">str</span></code> または <code class="docutils literal notranslate"><span class="pre">bytes</span></code> に変換されます。</p></li>
<li><p>シリアライズできる値をラッピングした <code class="docutils literal notranslate"><span class="pre">LazyObject</span></code> インスタンス</p></li>
<li><p>列挙型 (<code class="docutils literal notranslate"><span class="pre">TextChoices</span></code> や <code class="docutils literal notranslate"><span class="pre">IntegerChoices</span></code> など) のインスタンス。</p></li>
<li><p>任意の Django フィールド</p></li>
<li><p>任意の関数またはメソッドへのリファレンス (例: <code class="docutils literal notranslate"><span class="pre">datetime.datetime.today</span></code>) (ただし、モジュールのトップレベルのスコープにいなければならない)</p>
<ul>
<li><p>関数は適切にラップされていればデコレートできます、つまり <a class="reference external" href="https://docs.python.org/3/library/functools.html#functools.wraps" title="(in Python v3.13)"><code class="xref py py-func docutils literal notranslate"><span class="pre">functools.wraps()</span></code></a> を使います。</p></li>
<li><p><a class="reference external" href="https://docs.python.org/3/library/functools.html#functools.cache" title="(in Python v3.13)"><code class="xref py py-func docutils literal notranslate"><span class="pre">functools.cache()</span></code></a> デコレータと <a class="reference external" href="https://docs.python.org/3/library/functools.html#functools.lru_cache" title="(in Python v3.13)"><code class="xref py py-func docutils literal notranslate"><span class="pre">functools.lru_cache()</span></code></a> デコレータは明示的にサポートされています。</p></li>
</ul>
</li>
<li><p>クラスの本体から使用されている束縛されていないメソッド</p></li>
<li><p>任意のクラスへのリファレンス (ただし、モジュールのトップレベルのスコープにいなければならない)</p></li>
<li><p>カスタムの <code class="docutils literal notranslate"><span class="pre">deconstruct()</span></code> メソッドを持つすべてのオブジェクト (<a class="reference internal" href="#custom-deconstruct-method"><span class="std std-ref">以下を参照</span></a>)</p></li>
</ul>
<div class="versionchanged">
<span class="title">Changed in Django 5.0:</span> <p><a class="reference external" href="https://docs.python.org/3/library/functools.html#functools.cache" title="(in Python v3.13)"><code class="xref py py-func docutils literal notranslate"><span class="pre">functools.cache()</span></code></a> または <a class="reference external" href="https://docs.python.org/3/library/functools.html#functools.lru_cache" title="(in Python v3.13)"><code class="xref py py-func docutils literal notranslate"><span class="pre">functools.lru_cache()</span></code></a> で装飾された関数のシリアライズのサポートが追加されました。</p>
</div>
<p>Django は以下のオブジェクトをシリアライズできません。</p>
<ul class="simple">
<li><p>ネストしたクラス</p></li>
<li><p>任意のクラスのインスタンス (例: <code class="docutils literal notranslate"><span class="pre">MyClass(4.3,</span> <span class="pre">5.7)</span></code>)</p></li>
<li><p>ラムダ式</p></li>
</ul>
<section id="s-custom-serializers">
<span id="s-custom-migration-serializers"></span><span id="custom-serializers"></span><span id="custom-migration-serializers"></span><h3>カスタムシリアライザ<a class="headerlink" href="#custom-serializers" title="Link to this heading">¶</a></h3>
<p>カスタムシリアライザを書けば、他の型もシリアライズできます。たとえば、 Django がデフォルトで <a class="reference external" href="https://docs.python.org/3/library/decimal.html#decimal.Decimal" title="(in Python v3.13)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> をシリアライズしていない場合、次のようにできます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">decimal</span><span class="w"> </span><span class="kn">import</span> <span class="n">Decimal</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">django.db.migrations.serializer</span><span class="w"> </span><span class="kn">import</span> <span class="n">BaseSerializer</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">django.db.migrations.writer</span><span class="w"> </span><span class="kn">import</span> <span class="n">MigrationWriter</span>


<span class="k">class</span><span class="w"> </span><span class="nc">DecimalSerializer</span><span class="p">(</span><span class="n">BaseSerializer</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">serialize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">),</span> <span class="p">{</span><span class="s2">&quot;from decimal import Decimal&quot;</span><span class="p">}</span>


<span class="n">MigrationWriter</span><span class="o">.</span><span class="n">register_serializer</span><span class="p">(</span><span class="n">Decimal</span><span class="p">,</span> <span class="n">DecimalSerializer</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">MigrationWriter.register_serializer()</span></code> の第一引数には、シリアライザを使用する型または型のイテラブルを指定します。</p>
<p>シリアライザの <code class="docutils literal notranslate"><span class="pre">serialize()</span></code> メソッドは、値がマイグレーションでどのように表示されるかを示す文字列と、マイグレーションで必要なインポートのセットを返す必要があります。</p>
</section>
<section id="s-adding-a-deconstruct-method">
<span id="s-custom-deconstruct-method"></span><span id="adding-a-deconstruct-method"></span><span id="custom-deconstruct-method"></span><h3><code class="docutils literal notranslate"><span class="pre">deconstruct()</span></code> メソッドを追加する<a class="headerlink" href="#adding-a-deconstruct-method" title="Link to this heading">¶</a></h3>
<p>自作のカスタムクラスに <code class="docutils literal notranslate"><span class="pre">deconstruct()</span></code> メソッドを実装することで、インスタンスを Django にシリアライズさせることができます。このメソッドは引数を取らず、 <code class="docutils literal notranslate"><span class="pre">(path,</span> <span class="pre">args,</span> <span class="pre">kwargs)</span></code> からなる3タプルを返す必要があります。</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">path</span></code> はクラス名を最後に含むクラスへの Python パスでなければなりません (たとえば、<code class="docutils literal notranslate"><span class="pre">myapp.custom_things.MyClass</span></code>)。自作のクラスがモジュールのトップレベルで使用できない場合は、シリアライズすることはできません。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">args</span></code> はクラスの <code class="docutils literal notranslate"><span class="pre">__init__</span></code> メソッドに渡される位置引数のリストでなければなりません。このリストに含まれる要素は、それ自体でシリアライズ可能である必要があります。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">kwargs</span></code> はクラスの <code class="docutils literal notranslate"><span class="pre">__init__</span></code> メソッドに渡されるキーワード引数の dict でなければなりません。すべての値はそれ自体でシリアライズ可能である必要があります。</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>この戻り値は <a class="reference internal" href="../howto/custom-model-fields.html#custom-field-deconstruct-method"><span class="std std-ref">カスタムフィールドのための</span></a> <code class="docutils literal notranslate"><span class="pre">deconstruct()</span></code> メソッド とは異なり、4つの項目のタプルを返します。</p>
</div>
<p>Django は、Django のフィールドへの参照を書き出すのと同じように、与えられた引数を持つクラスのインスタンス化として値を書き出します。</p>
<p><a class="reference internal" href="../ref/django-admin.html#django-admin-makemigrations"><code class="xref std std-djadmin docutils literal notranslate"><span class="pre">makemigrations</span></code></a> が実行されるたびに新しいマイグレーションが作成されるのを防ぐために、クラスに追加情報を与える <code class="docutils literal notranslate"><span class="pre">__eq__()</span></code> メソッドも追加した方がいいでしょう。この関数は、Django のマイグレーションフレームワークが状態の変更を検出するために呼び出します。</p>
<p>クラスのコンストラクタのすべての引数がそれ自体でシリアライズ可能である場合には、次のように <code class="docutils literal notranslate"><span class="pre">django.utils.deconstruct</span></code> の <code class="docutils literal notranslate"><span class="pre">&#64;deconstructible</span></code> クラスデコレータを使うことで <code class="docutils literal notranslate"><span class="pre">deconstruct()</span></code> メソッドを追加できます。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">django.utils.deconstruct</span><span class="w"> </span><span class="kn">import</span> <span class="n">deconstructible</span>


<span class="nd">@deconstructible</span>
<span class="k">class</span><span class="w"> </span><span class="nc">MyCustomClass</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">foo</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">foo</span> <span class="o">=</span> <span class="n">foo</span>
        <span class="o">...</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">foo</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">foo</span>
</pre></div>
</div>
<p>デコレータは、コンストラクタに与えられる引数を独自の方法でキャプチャし保存しておきます。そして、<code class="docutils literal notranslate"><span class="pre">deconstruct()</span></code> が呼ばれるタイミングで、保存しておいた引数を返すようにしてくれます。</p>
</section>
</section>
<section id="s-supporting-multiple-django-versions">
<span id="supporting-multiple-django-versions"></span><h2>Django の複数のバージョンをサポートする<a class="headerlink" href="#supporting-multiple-django-versions" title="Link to this heading">¶</a></h2>
<p>もしあなたが、モデルを持つサードパーティのアプリのメンテナならば、Django の複数のバージョンをサポートするマイグレーションを入れておきたいでしょう。その場合、必ず <strong>あなたがサポートしたい Django の下限のバージョンで</strong> <a class="reference internal" href="../ref/django-admin.html#django-admin-makemigrations"><code class="xref std std-djadmin docutils literal notranslate"><span class="pre">makemigrations</span></code></a> を実行するようにしてください。</p>
<p>マイグレーションのシステムは、Django の他のポリシーと同じく、後方互換性を持ちます。そのため、Django X.Y で生成されたマイグレーションファイルは、変更なしに Django X.Y+1 で動作します。しかし、マイグレーションのシステムは前方互換性は保証しません。新しい機能が追加され、新しいバージョンの Django でマイグレーションファイルが生成されれば、そのマイグレーションは古いバージョンでは動きません。</p>
<div class="admonition seealso">
<p class="admonition-title">参考</p>
<dl class="simple">
<dt><a class="reference internal" href="../ref/migration-operations.html"><span class="doc">マイグレーション操作リファレンス</span></a></dt><dd><p>スキーマ操作の API、特別な操作、自作の操作の書き方などについて書いてあります。</p>
</dd>
<dt><a class="reference internal" href="../howto/writing-migrations.html"><span class="doc">マイグレーション (Migrations) を書くための ”how-to”</span></a></dt><dd><p>遭遇するかもしれない異なるシチュエーション下での、データベースのマイグレーションの構造化方法と書き方を説明しています。</p>
</dd>
</dl>
</div>
</section>
</section>


          </div>
        </div>
      </div>
      
        
          <div class="yui-b" id="sidebar">
            
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../contents.html">目次</a></h3>
    <ul>
<li><a class="reference internal" href="#">マイグレーション</a><ul>
<li><a class="reference internal" href="#the-commands">コマンド</a></li>
<li><a class="reference internal" href="#backend-support">対応するバックエンド</a><ul>
<li><a class="reference internal" href="#postgresql">PostgreSQL</a></li>
<li><a class="reference internal" href="#mysql">MySQL</a></li>
<li><a class="reference internal" href="#sqlite">SQLite</a></li>
</ul>
</li>
<li><a class="reference internal" href="#workflow">ワークフロー</a><ul>
<li><a class="reference internal" href="#version-control">バージョン管理</a></li>
</ul>
</li>
<li><a class="reference internal" href="#transactions">トランザクション</a></li>
<li><a class="reference internal" href="#dependencies">依存関係</a><ul>
<li><a class="reference internal" href="#swappable-dependencies">スワップ (交換) 可能な依存関係</a></li>
</ul>
</li>
<li><a class="reference internal" href="#migration-files">マイグレーションファイル</a><ul>
<li><a class="reference internal" href="#custom-fields">カスタムフィールド</a></li>
<li><a class="reference internal" href="#model-managers">モデルマネージャ</a></li>
<li><a class="reference internal" href="#initial-migrations">初期マイグレーション</a></li>
<li><a class="reference internal" href="#history-consistency">履歴の一貫性</a></li>
</ul>
</li>
<li><a class="reference internal" href="#adding-migrations-to-apps">アプリにマイグレーションを追加する</a></li>
<li><a class="reference internal" href="#reversing-migrations">マイグレーションを元に戻す</a></li>
<li><a class="reference internal" href="#historical-models">履歴上のモデル</a></li>
<li><a class="reference internal" href="#considerations-when-removing-model-fields">モデルのフィールドを削除するときに考えるべきこと</a></li>
<li><a class="reference internal" href="#data-migrations">データのマイグレーション</a><ul>
<li><a class="reference internal" href="#accessing-models-from-other-apps">他のアプリからモデルにアクセスする</a></li>
<li><a class="reference internal" href="#more-advanced-migrations">より高度なマイグレーション</a></li>
</ul>
</li>
<li><a class="reference internal" href="#squashing-migrations">マイグレーションのスカッシュ (Squash)</a></li>
<li><a class="reference internal" href="#serializing-values">値のシリアライズ</a><ul>
<li><a class="reference internal" href="#custom-serializers">カスタムシリアライザ</a></li>
<li><a class="reference internal" href="#adding-a-deconstruct-method"><code class="docutils literal notranslate"><span class="pre">deconstruct()</span></code> メソッドを追加する</a></li>
</ul>
</li>
<li><a class="reference internal" href="#supporting-multiple-django-versions">Django の複数のバージョンをサポートする</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>前のトピックへ</h4>
    <p class="topless"><a href="class-based-views/mixins.html"
                          title="前の章へ">クラスベースのビューでミックスイン (mixin) を使用する</a></p>
  </div>
  <div>
    <h4>次のトピックへ</h4>
    <p class="topless"><a href="files.html"
                          title="次の章へ">ファイルの管理</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>このページ</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/topics/migrations.txt"
            rel="nofollow">ソースコードを表示</a></li>
    </ul>
   </div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">クイック検索</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="検索" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
              <h3>Last update:</h3>
              <p class="topless">1月 22, 2025</p>
          </div>
        
      
    </div>

    <div id="ft">
      <div class="nav">
    &laquo; <a href="class-based-views/mixins.html" title="クラスベースのビューでミックスイン (mixin) を使用する">previous</a>
     |
    <a href="index.html" title="Django を使う" accesskey="U">up</a>
   |
    <a href="files.html" title="ファイルの管理">next</a> &raquo;</div>
    </div>
  </div>

      <div class="clearer"></div>
    </div>
  </body>
</html>