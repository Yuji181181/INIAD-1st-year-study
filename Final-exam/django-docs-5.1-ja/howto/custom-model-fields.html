<!DOCTYPE html>

<html lang="ja" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>カスタムのモデルフィールドを作成する &#8212; Django 5.1.6.dev20250122212402 ドキュメント</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=34bb78ad" />
    <link rel="stylesheet" type="text/css" href="../_static/default.css?v=bf4d74af" />
    <script src="../_static/documentation_options.js?v=d2885b0a"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/translations.js?v=4755f45a"></script>
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="検索" href="../search.html" />
    <link rel="next" title="データベースのマイグレーションの作成方法" href="writing-migrations.html" />
    <link rel="prev" title="レガシーなデータベースと Django の統合" href="legacy-databases.html" />



 
<script src="../templatebuiltins.js"></script>
<script>
(function($) {
    if (!django_template_builtins) {
       // templatebuiltins.js missing, do nothing.
       return;
    }
    $(document).ready(function() {
        // Hyperlink Django template tags and filters
        var base = "../ref/templates/builtins.html";
        if (base == "#") {
            // Special case for builtins.html itself
            base = "";
        }
        // Tags are keywords, class '.k'
        $("div.highlight\\-html\\+django span.k").each(function(i, elem) {
             var tagname = $(elem).text();
             if ($.inArray(tagname, django_template_builtins.ttags) != -1) {
                 var fragment = tagname.replace(/_/, '-');
                 $(elem).html("<a href='" + base + "#" + fragment + "'>" + tagname + "</a>");
             }
        });
        // Filters are functions, class '.nf'
        $("div.highlight\\-html\\+django span.nf").each(function(i, elem) {
             var filtername = $(elem).text();
             if ($.inArray(filtername, django_template_builtins.tfilters) != -1) {
                 var fragment = filtername.replace(/_/, '-');
                 $(elem).html("<a href='" + base + "#" + fragment + "'>" + filtername + "</a>");
             }
        });
    });
})(jQuery);</script>

  </head><body>

    <div class="document">
  <div id="custom-doc" class="yui-t6">
    <div id="hd">
      <h1><a href="../index.html">Django 5.1.6.dev20250122212402 ドキュメント</a></h1>
      <div id="global-nav">
        <a title="Home page" href="../index.html">Home</a>  |
        <a title="Table of contents" href="../contents.html">Table of contents</a>  |
        <a title="Global index" href="../genindex.html">Index</a>  |
        <a title="Module index" href="../py-modindex.html">Modules</a>
      </div>
      <div class="nav">
    &laquo; <a href="legacy-databases.html" title="レガシーなデータベースと Django の統合">previous</a>
     |
    <a href="index.html" title="How-to ガイド" accesskey="U">up</a>
   |
    <a href="writing-migrations.html" title="データベースのマイグレーションの作成方法">next</a> &raquo;</div>
    </div>

    <div id="bd">
      <div id="yui-main">
        <div class="yui-b">
          <div class="yui-g" id="howto-custom-model-fields">
            
  <section id="s-how-to-create-custom-model-fields">
<span id="how-to-create-custom-model-fields"></span><h1>カスタムのモデルフィールドを作成する<a class="headerlink" href="#how-to-create-custom-model-fields" title="Link to this heading">¶</a></h1>
<section id="s-introduction">
<span id="introduction"></span><h2>はじめに<a class="headerlink" href="#introduction" title="Link to this heading">¶</a></h2>
<p><a class="reference internal" href="../topics/db/models.html"><span class="doc">モデルリファレンス</span></a> ドキュメントでは、Djangoの標準フィールドクラスである、 <a class="reference internal" href="../ref/models/fields.html#django.db.models.CharField" title="django.db.models.CharField"><code class="xref py py-class docutils literal notranslate"><span class="pre">CharField</span></code></a> や、 <a class="reference internal" href="../ref/models/fields.html#django.db.models.DateField" title="django.db.models.DateField"><code class="xref py py-class docutils literal notranslate"><span class="pre">DateField</span></code></a> などの使い方を説明しています。多くの場合、これらのクラスがあれば十分です。ただし、Djangoのバージョンが正確な要件を満たしていない場合や、Djangoに同梱されているものとはまったく異なるフィールドを使用したい場合があります。</p>
<p>Django の組み込みフィールド型は、データベースで利用可能な全てのカラム型をカバーしているわけではなく、 <code class="docutils literal notranslate"><span class="pre">VARCHAR</span></code> や <code class="docutils literal notranslate"><span class="pre">INTEGER</span></code> のような一般的な型のみに対応しています。地理的な多角形や <a class="reference external" href="https://www.postgresql.org/docs/current/sql-createtype.html">PostgreSQL カスタム型</a> のようなユーザが作成した型など、より曖昧なカラム型については、独自の Django <code class="docutils literal notranslate"><span class="pre">Field</span></code> サブクラスを定義することができます。</p>
<p>あるいは、複雑な Python オブジェクトを、標準的なデータベースのカラム型に合うようにシリアライズすることもできます。これもまた、<code class="docutils literal notranslate"><span class="pre">Field</span></code> サブクラスがオブジェクトをモデルで使用するのに役立つケースです。</p>
<section id="s-our-example-object">
<span id="our-example-object"></span><h3>私たちのサンプルオブジェクト<a class="headerlink" href="#our-example-object" title="Link to this heading">¶</a></h3>
<p>カスタムフィールドを作成するには、細部に少し注意する必要があります。わかりやすくなるように、このドキュメントでは「ブリッジ <a class="reference external" href="https://en.wikipedia.org/wiki/Contract_bridge">Bridge</a> の手札のやり取りを表すPythonオブジェクトの実装」を一貫した例として説明することにします。なお、この実装例を理解するために、ブリッジのプレイルールを理解する必要はありません。52枚のカードが、伝統的に <em>北</em> 、 <em>東</em> 、 <em>南</em> および <em>西</em> と呼ばれる4人のプレイヤーに均等に配られることだけを覚えておいてください。クラスは以下のように実装します:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Hand</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A hand of cards (bridge style)&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">north</span><span class="p">,</span> <span class="n">east</span><span class="p">,</span> <span class="n">south</span><span class="p">,</span> <span class="n">west</span><span class="p">):</span>
        <span class="c1"># Input parameters are lists of cards (&#39;Ah&#39;, &#39;9s&#39;, etc.)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">north</span> <span class="o">=</span> <span class="n">north</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">east</span> <span class="o">=</span> <span class="n">east</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">south</span> <span class="o">=</span> <span class="n">south</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">west</span> <span class="o">=</span> <span class="n">west</span>

    <span class="c1"># ... (other possibly useful methods omitted) ...</span>
</pre></div>
</div>
<p>これはDjangoの仕様を使っていない、普通のPythonクラスです。モデルでこれと同じようなことを実行できるようにしたいと思います（モデルの中の <code class="docutils literal notranslate"><span class="pre">hand</span></code> 属性は <code class="docutils literal notranslate"><span class="pre">Hand</span></code> インスタンスだと想定しています）</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">example</span> <span class="o">=</span> <span class="n">MyModel</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">pk</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">example</span><span class="o">.</span><span class="n">hand</span><span class="o">.</span><span class="n">north</span><span class="p">)</span>

<span class="n">new_hand</span> <span class="o">=</span> <span class="n">Hand</span><span class="p">(</span><span class="n">north</span><span class="p">,</span> <span class="n">east</span><span class="p">,</span> <span class="n">south</span><span class="p">,</span> <span class="n">west</span><span class="p">)</span>
<span class="n">example</span><span class="o">.</span><span class="n">hand</span> <span class="o">=</span> <span class="n">new_hand</span>
<span class="n">example</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
</pre></div>
</div>
<p>他のPythonクラスと同様に、モデルの <code class="docutils literal notranslate"><span class="pre">hand</span></code> 属性に割り当てたり、そこから取得したりします。コツは、そのようなオブジェクトの保存と読み込みの処理方法をDjangoに伝えることです。</p>
<p>モデルで <code class="docutils literal notranslate"><span class="pre">Hand</span></code> クラスを使用するために、<strong>このクラスを変更する必要はありません</strong>。 これは、ソースコードを変更できない既存のクラスのモデルサポートを簡単に記述できるため、理想的です。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>例えば文字列や浮動小数点数のような、Pythonの標準的な型としてカスタムデータベースのカラム型を扱い、データを利用したいこともあります。このケースは <code class="docutils literal notranslate"><span class="pre">Hand</span></code> の例と似ているので、違いを後で説明することにします。</p>
</div>
</section>
</section>
<section id="s-background-theory">
<span id="background-theory"></span><h2>背景理論<a class="headerlink" href="#background-theory" title="Link to this heading">¶</a></h2>
<section id="s-database-storage">
<span id="database-storage"></span><h3>データベースストレージ<a class="headerlink" href="#database-storage" title="Link to this heading">¶</a></h3>
<p>モデルフィールドから始めましょう。分解すると、モデルフィールドは通常のPythonオブジェクト（文字列、ブール値、 <code class="docutils literal notranslate"><span class="pre">datetime</span></code> 、あるいは <code class="docutils literal notranslate"><span class="pre">Hand</span></code> のような複雑なもの）を、データベースを扱うときに便利な形式に変換する方法を提供します。(このような形式はシリアライズの際にも便利ですが、後で説明するように、データベース側を制御できるようになれば、その方が簡単です)。</p>
<p>モデルのフィールドは、既存のデータベースのカラムの型に適合するように何らかの方法で変換されなければなりません。データベースによって有効なカラム型のセットは異なりますが、利用できる型が決まっているという決まりは同じです。データベースに保存したいものはすべて、これらの型のいずれかに適合しなければなりません。</p>
<p>通常、特定のデータベースの列タイプに一致するようにDjangoフィールドを作成するか、データを文字列などに変換する方法が必要になります。</p>
<p><code class="docutils literal notranslate"><span class="pre">Hand</span></code> の例では、すべてのカードをあらかじめ決められた順序で連結することで、カードデータを104文字の文字列に変換できます。たとえば、すべての <em>北</em> カード、次に <em>東</em> 、 <em>南</em> および <em>西</em> カードです。 したがって、<code class="docutils literal notranslate"><span class="pre">Hand</span></code> オブジェクトをデータベースのテキストまたは文字列に保存できます。</p>
</section>
<section id="s-what-does-a-field-class-do">
<span id="what-does-a-field-class-do"></span><h3>フィールドクラスが行うこと<a class="headerlink" href="#what-does-a-field-class-do" title="Link to this heading">¶</a></h3>
<p>Djangoのすべてのフィールド（およびこのドキュメントで <em>フィールド (Field)</em> と言うときは、常に <a class="reference internal" href="../ref/forms/fields.html"><span class="doc">フォームフィールド</span></a> ではなくモデルフィールドを意味します）は <a class="reference internal" href="../ref/models/fields.html#django.db.models.Field" title="django.db.models.Field"><code class="xref py py-class docutils literal notranslate"><span class="pre">django.db.models.Field</span></code></a> のサブクラスです。 Django がフィールドについて記録する情報のほとんどは、名前、ヘルプテキスト、一意性など、すべてのフィールドに共通です。すべての情報の保存は <code class="docutils literal notranslate"><span class="pre">Field</span></code> によって処理されます。<code class="docutils literal notranslate"><span class="pre">Field</span></code> ができることの詳細については、後で詳しく説明します。とりあえず、すべてが <code class="docutils literal notranslate"><span class="pre">Field</span></code> から派生し、クラスの動作の重要な部分をカスタマイズすると言うだけで十分です。</p>
<p>Djangoフィールドクラスは、モデル属性に格納されているものではないことを理解することが重要です。 モデル属性には通常のPythonオブジェクトが含まれます。 モデルで定義するフィールドクラスは、モデルクラスが作成されるときに実際に <code class="docutils literal notranslate"><span class="pre">Meta</span></code> クラスに保存されます（これを行う方法の正確な詳細はここでは重要ではありません）。 これは、属性を作成および変更するだけの場合、フィールドクラスは必要ないためです。 代わりに、属性値とデータベースに保存されているもの、または <a class="reference internal" href="../topics/serialization.html"><span class="doc">シリアライザ</span></a> に送信されるものとの間で変換するための機構を提供します。</p>
<p>独自のカスタムフィールドを作成する場合は、このことに留意してください。 作成するDjangoの <code class="docutils literal notranslate"><span class="pre">Field</span></code> サブクラスは、Pythonインスタンスとデータベース/シリアライザーの値をさまざまな方法で変換するための機構を提供します（たとえば、値の保存とルックアップでの値の使用には違いがあります）。 これが少しトリッキーに聞こえる場合でも、心配しないでください。以下の例で明らかになります。 カスタムフィールドが必要な場合、しばしば2つのクラスを作成することになります:</p>
<ul class="simple">
<li><p>最初のクラスは、ユーザーが操作するPythonオブジェクトです。彼らはそれをモデル属性に割り当て、そのようなものを表示するためにそれから読み込みます。これは、この例の <code class="docutils literal notranslate"><span class="pre">Hand</span></code> クラスです。</p></li>
<li><p>2番目のクラスは <code class="docutils literal notranslate"><span class="pre">Field</span></code> サブクラスです。これは、最初のクラスを永続ストレージ形式とPython形式の間で変換する方法を知っているクラスです。</p></li>
</ul>
</section>
</section>
<section id="s-writing-a-field-subclass">
<span id="writing-a-field-subclass"></span><h2>フィールドサブクラスを書く<a class="headerlink" href="#writing-a-field-subclass" title="Link to this heading">¶</a></h2>
<p><a class="reference internal" href="../ref/models/fields.html#django.db.models.Field" title="django.db.models.Field"><code class="xref py py-class docutils literal notranslate"><span class="pre">Field</span></code></a> のサブクラス化を考える前に、まず、新しいフィールドが、既存のどの <a class="reference internal" href="../ref/models/fields.html#django.db.models.Field" title="django.db.models.Field"><code class="xref py py-class docutils literal notranslate"><span class="pre">Field</span></code></a> クラスに最も似ているかを考えてください。既存の Django フィールドをサブクラス化して、手間を省くことはできませんか？そうでなければ、すべてのフィールドの基底となる、 <a class="reference internal" href="../ref/models/fields.html#django.db.models.Field" title="django.db.models.Field"><code class="xref py py-class docutils literal notranslate"><span class="pre">Field</span></code></a> クラスをサブクラス化すべきです。</p>
<p>新しいフィールドの初期化は、ケース固有の引数を共通の引数から分離し、後者を <a class="reference internal" href="../ref/models/fields.html#django.db.models.Field" title="django.db.models.Field"><code class="xref py py-class docutils literal notranslate"><span class="pre">Field</span></code></a> の <code class="docutils literal notranslate"><span class="pre">__init__()</span></code> メソッドに渡すことです。 （または親クラスに対して）。</p>
<p>この例では、フィールドを <code class="docutils literal notranslate"><span class="pre">HandField</span></code> と呼ぶことにします。（ <a class="reference internal" href="../ref/models/fields.html#django.db.models.Field" title="django.db.models.Field"><code class="xref py py-class docutils literal notranslate"><span class="pre">Field</span></code></a> サブクラス <code class="docutils literal notranslate"><span class="pre">&lt;Something&gt;Field</span></code> と名付けることをオススメします。 <a class="reference internal" href="../ref/models/fields.html#django.db.models.Field" title="django.db.models.Field"><code class="xref py py-class docutils literal notranslate"><span class="pre">Field</span></code></a> サブクラスであることが簡単にわかるためです）
既存のフィールドのようには動作しないため、この例では <a class="reference internal" href="../ref/models/fields.html#django.db.models.Field" title="django.db.models.Field"><code class="xref py py-class docutils literal notranslate"><span class="pre">Field</span></code></a> から直接サブクラス化しています。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">django.db</span><span class="w"> </span><span class="kn">import</span> <span class="n">models</span>


<span class="k">class</span><span class="w"> </span><span class="nc">HandField</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Field</span><span class="p">):</span>
    <span class="n">description</span> <span class="o">=</span> <span class="s2">&quot;A hand of cards (bridge style)&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;max_length&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">104</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>
</div>
<p>私たちの <code class="docutils literal notranslate"><span class="pre">HandField</span></code> は、ほとんどの標準フィールドオプションを受け入れます（以下のリストを参照してください）。しかし、52枚のカードの値とそれらのスート（マーク）を保持するだけで十分なため、固定長を持つようにします。合計で104文字です。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>多くのDjangoのモデルフィールドは、受け取ってもなにも起こらないオプションを受け取ります。例えば、 <a class="reference internal" href="../ref/models/fields.html#django.db.models.Field.editable" title="django.db.models.Field.editable"><code class="xref py py-attr docutils literal notranslate"><span class="pre">editable</span></code></a> と <a class="reference internal" href="../ref/models/fields.html#django.db.models.DateField.auto_now" title="django.db.models.DateField.auto_now"><code class="xref py py-attr docutils literal notranslate"><span class="pre">auto_now</span></code></a> は <a class="reference internal" href="../ref/models/fields.html#django.db.models.DateField" title="django.db.models.DateField"><code class="xref py py-class docutils literal notranslate"><span class="pre">django.db.models.DateField</span></code></a> に渡すことができますが、 <a class="reference internal" href="../ref/models/fields.html#django.db.models.Field.editable" title="django.db.models.Field.editable"><code class="xref py py-attr docutils literal notranslate"><span class="pre">editable</span></code></a> のパラメーターを無視します。（ <a class="reference internal" href="../ref/models/fields.html#django.db.models.DateField.auto_now" title="django.db.models.DateField.auto_now"><code class="xref py py-attr docutils literal notranslate"><span class="pre">auto_now</span></code></a> には <code class="docutils literal notranslate"><span class="pre">editable=False</span></code> がセットされています）この場合、エラーは発生しません。</p>
<p>この振る舞いはフィールドクラスをシンプルにします。なぜなら、必要のないオプションをチェックする必要がないからです。すべてのオプションを親クラスに渡し、オプションを使用しないのです。フィールドにより厳密にオプションを扱ってほしいのか、より柔軟なカレントフィールドの動作を使うのかは、使う人次第です。</p>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Field.__init__()</span></code> メソッドは以下のパラメーターを取ります:</p>
<ul class="simple">
<li><p><a class="reference internal" href="../ref/models/fields.html#django.db.models.Field.verbose_name" title="django.db.models.Field.verbose_name"><code class="xref py py-attr docutils literal notranslate"><span class="pre">verbose_name</span></code></a></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">name</span></code></p></li>
<li><p><a class="reference internal" href="../ref/models/fields.html#django.db.models.Field.primary_key" title="django.db.models.Field.primary_key"><code class="xref py py-attr docutils literal notranslate"><span class="pre">primary_key</span></code></a></p></li>
<li><p><a class="reference internal" href="../ref/models/fields.html#django.db.models.CharField.max_length" title="django.db.models.CharField.max_length"><code class="xref py py-attr docutils literal notranslate"><span class="pre">max_length</span></code></a></p></li>
<li><p><a class="reference internal" href="../ref/models/fields.html#django.db.models.Field.unique" title="django.db.models.Field.unique"><code class="xref py py-attr docutils literal notranslate"><span class="pre">unique</span></code></a></p></li>
<li><p><a class="reference internal" href="../ref/models/fields.html#django.db.models.Field.blank" title="django.db.models.Field.blank"><code class="xref py py-attr docutils literal notranslate"><span class="pre">blank</span></code></a></p></li>
<li><p><a class="reference internal" href="../ref/models/fields.html#django.db.models.Field.null" title="django.db.models.Field.null"><code class="xref py py-attr docutils literal notranslate"><span class="pre">null</span></code></a></p></li>
<li><p><a class="reference internal" href="../ref/models/fields.html#django.db.models.Field.db_index" title="django.db.models.Field.db_index"><code class="xref py py-attr docutils literal notranslate"><span class="pre">db_index</span></code></a></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">rel</span></code>: 関連フィールドに使用される (<a class="reference internal" href="../ref/models/fields.html#django.db.models.ForeignKey" title="django.db.models.ForeignKey"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForeignKey</span></code></a> など)。上級者向けです。</p></li>
<li><p><a class="reference internal" href="../ref/models/fields.html#django.db.models.Field.default" title="django.db.models.Field.default"><code class="xref py py-attr docutils literal notranslate"><span class="pre">default</span></code></a></p></li>
<li><p><a class="reference internal" href="../ref/models/fields.html#django.db.models.Field.editable" title="django.db.models.Field.editable"><code class="xref py py-attr docutils literal notranslate"><span class="pre">editable</span></code></a></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">serialize</span></code>: <code class="docutils literal notranslate"><span class="pre">False</span></code> の場合、Django の <a class="reference internal" href="../topics/serialization.html"><span class="doc">シリアライザ</span></a> にモデルが渡されたときに、フィールドをシリアライズしません。デフォルトの値は <code class="docutils literal notranslate"><span class="pre">True</span></code> です。</p></li>
<li><p><a class="reference internal" href="../ref/models/fields.html#django.db.models.Field.unique_for_date" title="django.db.models.Field.unique_for_date"><code class="xref py py-attr docutils literal notranslate"><span class="pre">unique_for_date</span></code></a></p></li>
<li><p><a class="reference internal" href="../ref/models/fields.html#django.db.models.Field.unique_for_month" title="django.db.models.Field.unique_for_month"><code class="xref py py-attr docutils literal notranslate"><span class="pre">unique_for_month</span></code></a></p></li>
<li><p><a class="reference internal" href="../ref/models/fields.html#django.db.models.Field.unique_for_year" title="django.db.models.Field.unique_for_year"><code class="xref py py-attr docutils literal notranslate"><span class="pre">unique_for_year</span></code></a></p></li>
<li><p><a class="reference internal" href="../ref/models/fields.html#django.db.models.Field.choices" title="django.db.models.Field.choices"><code class="xref py py-attr docutils literal notranslate"><span class="pre">choices</span></code></a></p></li>
<li><p><a class="reference internal" href="../ref/models/fields.html#django.db.models.Field.help_text" title="django.db.models.Field.help_text"><code class="xref py py-attr docutils literal notranslate"><span class="pre">help_text</span></code></a></p></li>
<li><p><a class="reference internal" href="../ref/models/fields.html#django.db.models.Field.db_column" title="django.db.models.Field.db_column"><code class="xref py py-attr docutils literal notranslate"><span class="pre">db_column</span></code></a></p></li>
<li><p>もしバックエンドが <a class="reference internal" href="../topics/db/tablespaces.html"><span class="doc">テーブル空間 (tablespace)</span></a> をサポートする場合、<a class="reference internal" href="../ref/models/fields.html#django.db.models.Field.db_tablespace" title="django.db.models.Field.db_tablespace"><code class="xref py py-attr docutils literal notranslate"><span class="pre">db_tablespace</span></code></a>: はインデックスの作成のみ行います。通常、このオプションは無視できます。</p></li>
<li><p>モデル継承で使用される <a class="reference internal" href="../ref/models/fields.html#django.db.models.OneToOneField" title="django.db.models.OneToOneField"><code class="xref py py-class docutils literal notranslate"><span class="pre">OneToOneField</span></code></a> のように、フィールドが自動的に作成された場合は、<a class="reference internal" href="../ref/models/fields.html#django.db.models.Field.auto_created" title="django.db.models.Field.auto_created"><code class="xref py py-attr docutils literal notranslate"><span class="pre">auto_created</span></code></a> は <code class="docutils literal notranslate"><span class="pre">True</span></code> です。 高度な使用向けです。</p></li>
</ul>
<p>上記のリストに説明のないオプションはすべて、通常のDjangoフィールドと同じ意味を持ちます。例と詳細については、 <a class="reference internal" href="../ref/models/fields.html"><span class="doc">フィールドのドキュメント</span></a> を参照してください。</p>
<section id="s-field-deconstruction">
<span id="s-custom-field-deconstruct-method"></span><span id="field-deconstruction"></span><span id="custom-field-deconstruct-method"></span><h3>フィールドの解体<a class="headerlink" href="#field-deconstruction" title="Link to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">__init__()</span></code> メソッドとは対照的なものとして、 <a class="reference internal" href="../ref/models/fields.html#django.db.models.Field.deconstruct" title="django.db.models.Field.deconstruct"><code class="xref py py-meth docutils literal notranslate"><span class="pre">deconstruct()</span></code></a> メソッドがあります。これは <a class="reference internal" href="../topics/migrations.html"><span class="doc">モデルのマイグレーション</span></a> 中に使用されるもので、新しいフィールドのインスタンスを取得する方法、インスタンスをどのようにシリアライズして減らすかの方法をDjangoに指示します。特に、インスタンスを再生成するためにどの引数を <code class="docutils literal notranslate"><span class="pre">__init__()</span></code> に渡すかを指示します。</p>
<p>継承元のフィールドの上に追加のオプションを追加していない場合、新しい <code class="docutils literal notranslate"><span class="pre">deconstruct()</span></code> メソッドを記述する必要はありません。 ただし、<code class="docutils literal notranslate"><span class="pre">__init__()</span></code> で渡される引数を変更する場合（<code class="docutils literal notranslate"><span class="pre">HandField</span></code> のように）、渡される値を補足する必要があります。</p>
<p><code class="docutils literal notranslate"><span class="pre">deconstruct()</span></code> 関数は4要素のタプルを返します。それは、フィールドの属性、インポートするフィールドクラスのフルパス、位置引数（リスト型）、キーワード引数（辞書型）です。この関数は <code class="docutils literal notranslate"><span class="pre">deconstruct()</span></code> メソッドとは異なることに注意してください。 <code class="docutils literal notranslate"><span class="pre">deconstruct()</span></code> メソッドは <a class="reference internal" href="../topics/migrations.html#custom-deconstruct-method"><span class="std std-ref">カスタムクラスのためのもの</span></a> で、3要素のタプルを返します。</p>
<p>カスタムフィールドの作成者は、最初の2つの値を気にする必要はありません。 ベース <code class="docutils literal notranslate"><span class="pre">Field</span></code> クラスには、フィールドの属性名とインポートパスを計算するためのすべてのコードがあります。 ただし、位置引数とキーワード引数は、変更する可能性が高いため、注意する必要があります。</p>
<p>たとえば、 <code class="docutils literal notranslate"><span class="pre">HandField</span></code> クラスでは、常に <code class="docutils literal notranslate"><span class="pre">__init__()</span></code> でmax_lengthを強制的に設定しています。 <code class="docutils literal notranslate"><span class="pre">Field</span></code> ベースクラスの <code class="docutils literal notranslate"><span class="pre">deconstruct()</span></code> メソッドはこれを見て、キーワード引数でそれを返そうとします。 したがって、読みやすくするためにキーワード引数から削除できます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">django.db</span><span class="w"> </span><span class="kn">import</span> <span class="n">models</span>


<span class="k">class</span><span class="w"> </span><span class="nc">HandField</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Field</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;max_length&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">104</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">deconstruct</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">name</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">deconstruct</span><span class="p">()</span>
        <span class="k">del</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;max_length&quot;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">name</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span>
</pre></div>
</div>
<p>新しいキーワード引数を追加する場合、自分で <code class="docutils literal notranslate"><span class="pre">kwargs</span></code> に値を設定する <code class="docutils literal notranslate"><span class="pre">deconstruct()</span></code> でコードを記述する必要があります。 また、デフォルト値が使用されている場合など、フィールドの状態を再構築する必要がない場合は、<code class="docutils literal notranslate"><span class="pre">kwargs</span></code> から値を省略してください:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">django.db</span><span class="w"> </span><span class="kn">import</span> <span class="n">models</span>


<span class="k">class</span><span class="w"> </span><span class="nc">CommaSepField</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Field</span><span class="p">):</span>
    <span class="s2">&quot;Implements comma-separated storage of lists&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">separator</span><span class="o">=</span><span class="s2">&quot;,&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">separator</span> <span class="o">=</span> <span class="n">separator</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">deconstruct</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">name</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">deconstruct</span><span class="p">()</span>
        <span class="c1"># Only include kwarg if it&#39;s not the default</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">separator</span> <span class="o">!=</span> <span class="s2">&quot;,&quot;</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;separator&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">separator</span>
        <span class="k">return</span> <span class="n">name</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span>
</pre></div>
</div>
<p>より複雑な例はこのドキュメントの範囲外ですが、これだけは覚えておいてください - <code class="docutils literal notranslate"><span class="pre">deconstruct()</span></code> は、フィールドインスタンスのどのような設定に対しても、その状態を再構築するために <code class="docutils literal notranslate"><span class="pre">__init__</span></code> に渡す引数を返さなければなりません。</p>
<p><code class="docutils literal notranslate"><span class="pre">Field</span></code> スーパークラス内の引数に新しいデフォルト値を設定する場合には、特に注意してください。古いデフォルト値を使うと消えるようにするのではなく、デフォルト値が常に含まれるようにしてください。</p>
<p>また、値を位置引数として返さないようにしてください。 可能な限り、将来の互換性を最大限にするために、キーワード引数として値を返してください。コンストラクタの引数リストにおける位置よりも、頻繁に引数の名前を変更する場合、位置引数で指定しがちになるかもしれません。しかし、利用者はかなり長期間（おそらく何年も）にわたって、シリアライズされたバージョンからフィールドを再構築することに注意してください。これはバージョンのライフサイクルの長さにも依存します。</p>
<p>フィールドを含む移行を調べることで分解の結果を確認できます。フィールドを分解して再構築することで、単体テストで分解をテストできます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">name</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="n">my_field_instance</span><span class="o">.</span><span class="n">deconstruct</span><span class="p">()</span>
<span class="n">new_instance</span> <span class="o">=</span> <span class="n">MyField</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
<span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">my_field_instance</span><span class="o">.</span><span class="n">some_attribute</span><span class="p">,</span> <span class="n">new_instance</span><span class="o">.</span><span class="n">some_attribute</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="s-field-attributes-not-affecting-database-column-definition">
<span id="s-custom-field-non-db-attrs"></span><span id="field-attributes-not-affecting-database-column-definition"></span><span id="custom-field-non-db-attrs"></span><h3>データベースのカラム定義に影響しないフィールド属性<a class="headerlink" href="#field-attributes-not-affecting-database-column-definition" title="Link to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">Field.non_db_attrs</span></code> をオーバーライドすることで、カラム定義に影響しないフィールドの属性をカスタマイズできます。これはモデルのマイグレーションの間に使われ、no-opの <code class="docutils literal notranslate"><span class="pre">AlterField</span></code> 操作を検出します。</p>
<p>例えば:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">CommaSepField</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Field</span><span class="p">):</span>
    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">non_db_attrs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">non_db_attrs</span> <span class="o">+</span> <span class="p">(</span><span class="s2">&quot;separator&quot;</span><span class="p">,)</span>
</pre></div>
</div>
</section>
<section id="s-changing-a-custom-field-s-base-class">
<span id="changing-a-custom-field-s-base-class"></span><h3>カスタムフィールドのベースクラスを変更する<a class="headerlink" href="#changing-a-custom-field-s-base-class" title="Link to this heading">¶</a></h3>
<p>カスタムフィールドの基底クラスを変更することはできません。なぜなら、 Django はその変更を検知できず、マイグレーションも行わないからです。例えば次のように書き始めたとして、:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">CustomCharField</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">):</span> <span class="o">...</span>
</pre></div>
</div>
<p>そして、代わりに <code class="docutils literal notranslate"><span class="pre">TextField</span></code> を使用することに決めた場合、サブクラスを次のように変更することはできません:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">CustomCharField</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">TextField</span><span class="p">):</span> <span class="o">...</span>
</pre></div>
</div>
<p>代わりに、新しいカスタムフィールドクラスを作成し、モデルを更新してそれを参照する必要があります:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">CustomCharField</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">):</span> <span class="o">...</span>


<span class="k">class</span><span class="w"> </span><span class="nc">CustomTextField</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">TextField</span><span class="p">):</span> <span class="o">...</span>
</pre></div>
</div>
<p><a class="reference internal" href="../topics/migrations.html#migrations-removing-model-fields"><span class="std std-ref">フィールドを削除する</span></a> で説明したように、それを参照するマイグレーションがある限り、元の <code class="docutils literal notranslate"><span class="pre">CustomCharField</span></code> クラスを保持する必要があります。</p>
</section>
<section id="s-documenting-your-custom-field">
<span id="documenting-your-custom-field"></span><h3>カスタムフィールドのドキュメントを書く<a class="headerlink" href="#documenting-your-custom-field" title="Link to this heading">¶</a></h3>
<p>いつものように、フィールドタイプのドキュメントを作成し、それがどんなものかをユーザがわかるようにしましょう。開発者にとって便利な docstring を提供するだけでなく、 <a class="reference internal" href="../ref/contrib/admin/admindocs.html"><span class="doc">django.contrib.admindocs</span></a> アプリケーションを通して、管理者アプリのユーザにフィールドタイプの短い説明を表示することもできます。これを行うには、カスタムフィールドの <a class="reference internal" href="../ref/models/fields.html#django.db.models.Field.description" title="django.db.models.Field.description"><code class="xref py py-attr docutils literal notranslate"><span class="pre">description</span></code></a> クラス属性に説明文を記述します。上記の例では、 <code class="docutils literal notranslate"><span class="pre">admindocs</span></code> アプリケーションが表示する <code class="docutils literal notranslate"><span class="pre">HandField</span></code> の説明は 'A hand of cards (bridge style)' （日本語で「手札(ブリッジスタイル)」の意）となります。</p>
<p><a class="reference internal" href="../ref/contrib/admin/admindocs.html#module-django.contrib.admindocs" title="django.contrib.admindocs: Django's admin documentation generator."><code class="xref py py-mod docutils literal notranslate"><span class="pre">django.contrib.admindocs</span></code></a> の表示では、フィールドの説明は <code class="docutils literal notranslate"><span class="pre">field.__dict__</span></code> によって補完され、説明文にフィールドの引数を組み込むことができます。例えば、 <a class="reference internal" href="../ref/models/fields.html#django.db.models.CharField" title="django.db.models.CharField"><code class="xref py py-class docutils literal notranslate"><span class="pre">CharField</span></code></a> の説明は次のようになります:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">description</span> <span class="o">=</span> <span class="n">_</span><span class="p">(</span><span class="s2">&quot;String (up to </span><span class="si">%(max_length)s</span><span class="s2">)&quot;</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="s-useful-methods">
<span id="useful-methods"></span><h3>便利なメソッド<a class="headerlink" href="#useful-methods" title="Link to this heading">¶</a></h3>
<p><a class="reference internal" href="../ref/models/fields.html#django.db.models.Field" title="django.db.models.Field"><code class="xref py py-class docutils literal notranslate"><span class="pre">Field</span></code></a> サブクラスを作成したら、フィールドの動作に応じて、いくつかの標準メソッドをオーバーライドすることを検討できます。以下のメソッドのリストは、おおよそ重要度の高いものから順に並んでいるので、上から始めてください。</p>
<section id="s-custom-database-types">
<span id="s-id1"></span><span id="custom-database-types"></span><span id="id1"></span><h4>カスタムデータベースタイプ<a class="headerlink" href="#custom-database-types" title="Link to this heading">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">mytype</span></code> というPostgreSQLのカスタム型を作成したとします。このとき、 <code class="docutils literal notranslate"><span class="pre">Field</span></code> をサブクラス化し、 <a class="reference internal" href="../ref/models/fields.html#django.db.models.Field.db_type" title="django.db.models.Field.db_type"><code class="xref py py-meth docutils literal notranslate"><span class="pre">db_type()</span></code></a> 関数を以下のように実装できます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">django.db</span><span class="w"> </span><span class="kn">import</span> <span class="n">models</span>


<span class="k">class</span><span class="w"> </span><span class="nc">MytypeField</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Field</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">db_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">connection</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;mytype&quot;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">MytypeField</span></code> を取得したら、他の <code class="docutils literal notranslate"><span class="pre">Field</span></code> タイプと同様に、どのモデルでも使用できます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Person</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">80</span><span class="p">)</span>
    <span class="n">something_else</span> <span class="o">=</span> <span class="n">MytypeField</span><span class="p">()</span>
</pre></div>
</div>
<p>データベースに依存しないアプリケーションを構築することを目指している場合、データベースカラムの型の違いを考慮する必要があります。たとえば、PostgreSQL の日付や時刻のカラムの型は <code class="docutils literal notranslate"><span class="pre">timestamp</span></code> と呼ばれますが、同じカラムが MySQL では <code class="docutils literal notranslate"><span class="pre">datetime</span></code> と呼ばれます。この違いは <a class="reference internal" href="../ref/models/fields.html#django.db.models.Field.db_type" title="django.db.models.Field.db_type"><code class="xref py py-meth docutils literal notranslate"><span class="pre">db_type()</span></code></a> メソッド内で <code class="docutils literal notranslate"><span class="pre">connection.vendor</span></code> 属性をチェックすることでハンドリングできます。現在のビルトインされているベンダー名は、<code class="docutils literal notranslate"><span class="pre">sqlite</span></code>、<code class="docutils literal notranslate"><span class="pre">postgresql</span></code>、<code class="docutils literal notranslate"><span class="pre">mysql</span></code>、<code class="docutils literal notranslate"><span class="pre">oracle</span></code> です。</p>
<p>例えば:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">MyDateField</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Field</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">db_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">connection</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">connection</span><span class="o">.</span><span class="n">vendor</span> <span class="o">==</span> <span class="s2">&quot;mysql&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;datetime&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;timestamp&quot;</span>
</pre></div>
</div>
<p>Django は、アプリケーションのために <code class="docutils literal notranslate"><span class="pre">CREATE</span> <span class="pre">TABLE</span></code> ステートメントを構築するとき、つまり最初にテーブルを作成するときに <a class="reference internal" href="../ref/models/fields.html#django.db.models.Field.db_type" title="django.db.models.Field.db_type"><code class="xref py py-meth docutils literal notranslate"><span class="pre">db_type()</span></code></a> と <a class="reference internal" href="../ref/models/fields.html#django.db.models.Field.rel_db_type" title="django.db.models.Field.rel_db_type"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rel_db_type()</span></code></a> メソッドを呼びます。このメソッドは、モデルのフィールドを含む <code class="docutils literal notranslate"><span class="pre">WHERE</span></code> 句を構築するとき、つまり QuerySet の <code class="docutils literal notranslate"><span class="pre">get()</span></code>、<code class="docutils literal notranslate"><span class="pre">filter()</span></code>、<code class="docutils literal notranslate"><span class="pre">exclude()</span></code> などのメソッドを使用してデータを取得するときにも呼ばれます。</p>
<p>一部のデータベースカラムの型は <code class="docutils literal notranslate"><span class="pre">CHAR(25)</span></code> などのパラメータを受け付けます。ここで、パラメータ <code class="docutils literal notranslate"><span class="pre">25</span></code> はカラムの最大長を表します。このような場合、パラメータを <code class="docutils literal notranslate"><span class="pre">db_type()</span></code> メソッド内でハードコードするよりも、モデル内で指定したほうがより柔軟になります。たとえば、ここで示すように、<code class="docutils literal notranslate"><span class="pre">CharMaxlength25Field</span></code> のようなフィールドを持つ意味はあまりありません。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># This is a silly example of hard-coded parameters.</span>
<span class="k">class</span><span class="w"> </span><span class="nc">CharMaxlength25Field</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Field</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">db_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">connection</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;char(25)&quot;</span>


<span class="c1"># In the model:</span>
<span class="k">class</span><span class="w"> </span><span class="nc">MyModel</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="c1"># ...</span>
    <span class="n">my_field</span> <span class="o">=</span> <span class="n">CharMaxlength25Field</span><span class="p">()</span>
</pre></div>
</div>
<p>これを行うためのよりよい方法は、実行時に、つまりクラスがインスタンス化されるときにパラメータを指定できるようにする方法です。そのためには、次のように <code class="docutils literal notranslate"><span class="pre">Field.__init__()</span></code> を実装します。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># This is a much more flexible example.</span>
<span class="k">class</span><span class="w"> </span><span class="nc">BetterCharField</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Field</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_length</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_length</span> <span class="o">=</span> <span class="n">max_length</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">db_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">connection</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;char(</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_length</span>


<span class="c1"># In the model:</span>
<span class="k">class</span><span class="w"> </span><span class="nc">MyModel</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="c1"># ...</span>
    <span class="n">my_field</span> <span class="o">=</span> <span class="n">BetterCharField</span><span class="p">(</span><span class="mi">25</span><span class="p">)</span>
</pre></div>
</div>
<p>最後に、カラムが本当に複雑な SQL のセットアップを必要とする場合、<a class="reference internal" href="../ref/models/fields.html#django.db.models.Field.db_type" title="django.db.models.Field.db_type"><code class="xref py py-meth docutils literal notranslate"><span class="pre">db_type()</span></code></a> から <code class="docutils literal notranslate"><span class="pre">None</span></code> を返してください。こうすると、Django の SQL 生成コードがこのフィールドをスキップするようになります。その後、別の方法で正しいテーブルにカラムを作成すする必要がありますが、Django に邪魔をしないように伝えることができます。</p>
<p><a class="reference internal" href="../ref/models/fields.html#django.db.models.Field.rel_db_type" title="django.db.models.Field.rel_db_type"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rel_db_type()</span></code></a> メソッドは、他のフィールドを指す <code class="docutils literal notranslate"><span class="pre">ForeignKey</span></code> や <code class="docutils literal notranslate"><span class="pre">OneToOneField</span></code> などのフィールドによって、データベースのカラムのデータ型を特定するために呼ばれます。たとえば、<code class="docutils literal notranslate"><span class="pre">UnsignedAutoField</span></code> がある場合、同じデータ型を使うためにそのフィールドを指す外部キーも必要になります。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># MySQL unsigned integer (range 0 to 4294967295).</span>
<span class="k">class</span><span class="w"> </span><span class="nc">UnsignedAutoField</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">AutoField</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">db_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">connection</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;integer UNSIGNED AUTO_INCREMENT&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">rel_db_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">connection</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;integer UNSIGNED&quot;</span>
</pre></div>
</div>
</section>
<section id="s-converting-values-to-python-objects">
<span id="s-id2"></span><span id="converting-values-to-python-objects"></span><span id="id2"></span><h4>変数を Python オブジェクトに変換する<a class="headerlink" href="#converting-values-to-python-objects" title="Link to this heading">¶</a></h4>
<p>もしカスタムの <a class="reference internal" href="../ref/models/fields.html#django.db.models.Field" title="django.db.models.Field"><code class="xref py py-class docutils literal notranslate"><span class="pre">Field</span></code></a> クラスが文字列、日付、整数、または浮動小数点数よりも複雑なデータ構造を扱う場合は、 <a class="reference internal" href="../ref/models/fields.html#django.db.models.Field.from_db_value" title="django.db.models.Field.from_db_value"><code class="xref py py-meth docutils literal notranslate"><span class="pre">from_db_value()</span></code></a> と <a class="reference internal" href="../ref/models/fields.html#django.db.models.Field.to_python" title="django.db.models.Field.to_python"><code class="xref py py-meth docutils literal notranslate"><span class="pre">to_python()</span></code></a> をオーバーライドする必要があるかもしれません。</p>
<p>フィールドのサブクラスに存在する場合、データがデータベースから読み込まれるすべての状況で、 <code class="docutils literal notranslate"><span class="pre">from_db_value()</span></code> が呼び出されます。これには集計や <a class="reference internal" href="../ref/models/querysets.html#django.db.models.query.QuerySet.values" title="django.db.models.query.QuerySet.values"><code class="xref py py-meth docutils literal notranslate"><span class="pre">values()</span></code></a> の呼び出しも含まれます。</p>
<p><code class="docutils literal notranslate"><span class="pre">to_python()</span></code> は、デシリアライズ時やフォームから使用される <a class="reference internal" href="../ref/models/instances.html#django.db.models.Model.clean" title="django.db.models.Model.clean"><code class="xref py py-meth docutils literal notranslate"><span class="pre">clean()</span></code></a> メソッドの中で呼び出されます。</p>
<p>一般的なルールとして、 <code class="docutils literal notranslate"><span class="pre">to_python()</span></code> は以下の引数を適切に処理するべきです。</p>
<ul class="simple">
<li><p>正しいタイプのインスタンス（例：このページの例でいう <code class="docutils literal notranslate"><span class="pre">Hand</span></code> ）。</p></li>
<li><p>文字列</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">None</span></code> (フィールドが <code class="docutils literal notranslate"><span class="pre">null=True</span></code> を許す場合)</p></li>
</ul>
<p>私たちの <code class="docutils literal notranslate"><span class="pre">HandField</span></code> クラスでは、データをデータベースの <code class="docutils literal notranslate"><span class="pre">VARCHAR</span></code> フィールドとして保存しているため、 <code class="docutils literal notranslate"><span class="pre">from_db_value()</span></code> で文字列と <code class="docutils literal notranslate"><span class="pre">None</span></code> を処理できる必要があります。 <code class="docutils literal notranslate"><span class="pre">to_python()</span></code> では、 <code class="docutils literal notranslate"><span class="pre">Hand</span></code> のインスタンスも処理する必要があります。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">re</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">django.core.exceptions</span><span class="w"> </span><span class="kn">import</span> <span class="n">ValidationError</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">django.db</span><span class="w"> </span><span class="kn">import</span> <span class="n">models</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">django.utils.translation</span><span class="w"> </span><span class="kn">import</span> <span class="n">gettext_lazy</span> <span class="k">as</span> <span class="n">_</span>


<span class="k">def</span><span class="w"> </span><span class="nf">parse_hand</span><span class="p">(</span><span class="n">hand_string</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Takes a string of cards and splits into a full hand.&quot;&quot;&quot;</span>
    <span class="n">p1</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s2">&quot;.</span><span class="si">{26}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">p2</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s2">&quot;..&quot;</span><span class="p">)</span>
    <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="n">p2</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">p1</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="n">hand_string</span><span class="p">)]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ValidationError</span><span class="p">(</span><span class="n">_</span><span class="p">(</span><span class="s2">&quot;Invalid input for a Hand instance&quot;</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">Hand</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>


<span class="k">class</span><span class="w"> </span><span class="nc">HandField</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Field</span><span class="p">):</span>
    <span class="c1"># ...</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">from_db_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">expression</span><span class="p">,</span> <span class="n">connection</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">value</span>
        <span class="k">return</span> <span class="n">parse_hand</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">to_python</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Hand</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">value</span>

        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">value</span>

        <span class="k">return</span> <span class="n">parse_hand</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
</pre></div>
</div>
<p>これらのメソッドからは常に <code class="docutils literal notranslate"><span class="pre">Hand</span></code> インスタンスが返されることに注意してください。これは、モデルの属性に保存したいPythonオブジェクトの型です。</p>
<p><code class="docutils literal notranslate"><span class="pre">to_python()</span></code> において、値の変換中に何か問題が発生した場合は、 <a class="reference internal" href="../ref/exceptions.html#django.core.exceptions.ValidationError" title="django.core.exceptions.ValidationError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValidationError</span></code></a> 例外を発生させる必要があります。</p>
</section>
<section id="s-converting-python-objects-to-query-values">
<span id="s-id3"></span><span id="converting-python-objects-to-query-values"></span><span id="id3"></span><h4>Python オブジェクトをクエリ変数に変換する<a class="headerlink" href="#converting-python-objects-to-query-values" title="Link to this heading">¶</a></h4>
<p>データベースを使用するには両方の変換が必要なので、 <a class="reference internal" href="../ref/models/fields.html#django.db.models.Field.from_db_value" title="django.db.models.Field.from_db_value"><code class="xref py py-meth docutils literal notranslate"><span class="pre">from_db_value()</span></code></a> をオーバーライドする場合は、 <a class="reference internal" href="../ref/models/fields.html#django.db.models.Field.get_prep_value" title="django.db.models.Field.get_prep_value"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_prep_value()</span></code></a> もオーバーライドして Python オブジェクトをクエリの値に戻す必要があります。</p>
<p>例えば:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">HandField</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Field</span><span class="p">):</span>
    <span class="c1"># ...</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_prep_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="p">[</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">north</span><span class="p">,</span> <span class="n">value</span><span class="o">.</span><span class="n">east</span><span class="p">,</span> <span class="n">value</span><span class="o">.</span><span class="n">south</span><span class="p">,</span> <span class="n">value</span><span class="o">.</span><span class="n">west</span><span class="p">)]</span>
        <span class="p">)</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>カスタムフィールドでMySQLの <code class="docutils literal notranslate"><span class="pre">CHAR</span></code> 、<code class="docutils literal notranslate"><span class="pre">VARCHAR</span></code> 、<code class="docutils literal notranslate"><span class="pre">TEXT</span></code> 型を使用する場合は、 <a class="reference internal" href="../ref/models/fields.html#django.db.models.Field.get_prep_value" title="django.db.models.Field.get_prep_value"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_prep_value()</span></code></a> が常に文字列型を返すようにする必要があります。MySQL はこれらの型に対して整数を指定してクエリを実行したとき、柔軟で想定困難なマッチングを行うため、クエリの結果に予想外のオブジェクトが含まれてしまうことがあります。この問題は <a class="reference internal" href="../ref/models/fields.html#django.db.models.Field.get_prep_value" title="django.db.models.Field.get_prep_value"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_prep_value()</span></code></a> から常に文字列型を返せば発生しません。</p>
</div>
</section>
<section id="s-converting-query-values-to-database-values">
<span id="s-id4"></span><span id="converting-query-values-to-database-values"></span><span id="id4"></span><h4>クエリの変数をデータベースの変数に変換する<a class="headerlink" href="#converting-query-values-to-database-values" title="Link to this heading">¶</a></h4>
<p>いくつかのデータ型(例えば、日付)はデータベースのバックエンドで使用する前に特定の形式にする必要があります。 <a class="reference internal" href="../ref/models/fields.html#django.db.models.Field.get_db_prep_value" title="django.db.models.Field.get_db_prep_value"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_db_prep_value()</span></code></a> はこれらの変換を行うメソッドです。クエリに使用される特定の接続は <code class="docutils literal notranslate"><span class="pre">connection</span></code> パラメータとして渡されます。これにより、必要に応じてバックエンド固有の変換ロジックを使用できます。</p>
<p>例えば、Django は <a class="reference internal" href="../ref/models/fields.html#django.db.models.BinaryField" title="django.db.models.BinaryField"><code class="xref py py-class docutils literal notranslate"><span class="pre">BinaryField</span></code></a> で以下のメソッドを使います:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">get_db_prep_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">connection</span><span class="p">,</span> <span class="n">prepared</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="n">value</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_db_prep_value</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">connection</span><span class="p">,</span> <span class="n">prepared</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">connection</span><span class="o">.</span><span class="n">Database</span><span class="o">.</span><span class="n">Binary</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">value</span>
</pre></div>
</div>
<p>カスタムフィールドを保存する際に、通常のクエリパラメータで使われる変換とは別の特別な変換が必要な場合、 <a class="reference internal" href="../ref/models/fields.html#django.db.models.Field.get_db_prep_save" title="django.db.models.Field.get_db_prep_save"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_db_prep_save()</span></code></a> をオーバーライドできます。</p>
</section>
<section id="s-preprocessing-values-before-saving">
<span id="s-id5"></span><span id="preprocessing-values-before-saving"></span><span id="id5"></span><h4>保存する前に値を前処理する場合<a class="headerlink" href="#preprocessing-values-before-saving" title="Link to this heading">¶</a></h4>
<p>保存する直前に値を前処理したい場合は <a class="reference internal" href="../ref/models/fields.html#django.db.models.Field.pre_save" title="django.db.models.Field.pre_save"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pre_save()</span></code></a> を使います。例えば、 Django の <a class="reference internal" href="../ref/models/fields.html#django.db.models.DateTimeField" title="django.db.models.DateTimeField"><code class="xref py py-class docutils literal notranslate"><span class="pre">DateTimeField</span></code></a> はこのメソッドを使って、 <a class="reference internal" href="../ref/models/fields.html#django.db.models.DateField.auto_now" title="django.db.models.DateField.auto_now"><code class="xref py py-attr docutils literal notranslate"><span class="pre">auto_now</span></code></a> や <a class="reference internal" href="../ref/models/fields.html#django.db.models.DateField.auto_now_add" title="django.db.models.DateField.auto_now_add"><code class="xref py py-attr docutils literal notranslate"><span class="pre">auto_now_add</span></code></a> に正しく属性を設定します。</p>
<p>もしこのメソッドをオーバーライドするならば、最後にその属性の値を返す必要があります。さらに、もしその値になんらかの変更を加えたならば、そのモデルへの参照を含んでいるコードが常に正しい値を指すように、モデルの属性を更新しなくてはなりません。</p>
</section>
<section id="s-specifying-the-form-field-for-a-model-field">
<span id="s-specifying-form-field-for-model-field"></span><span id="specifying-the-form-field-for-a-model-field"></span><span id="specifying-form-field-for-model-field"></span><h4>モデルフィールドのフォームフィールドの指定<a class="headerlink" href="#specifying-the-form-field-for-a-model-field" title="Link to this heading">¶</a></h4>
<p><a class="reference internal" href="../topics/forms/modelforms.html#django.forms.ModelForm" title="django.forms.ModelForm"><code class="xref py py-class docutils literal notranslate"><span class="pre">ModelForm</span></code></a> で使用するフォームフィールドをカスタマイズするには、 <a class="reference internal" href="../ref/models/fields.html#django.db.models.Field.formfield" title="django.db.models.Field.formfield"><code class="xref py py-meth docutils literal notranslate"><span class="pre">formfield()</span></code></a> をオーバーライドします。</p>
<p>フォームフィールドのクラスは <code class="docutils literal notranslate"><span class="pre">form_class</span></code> と <code class="docutils literal notranslate"><span class="pre">choices_form_class</span></code> 引数で指定できます。これらの引数を指定しなければ、 <a class="reference internal" href="../ref/forms/fields.html#django.forms.CharField" title="django.forms.CharField"><code class="xref py py-class docutils literal notranslate"><span class="pre">CharField</span></code></a> または <a class="reference internal" href="../ref/forms/fields.html#django.forms.TypedChoiceField" title="django.forms.TypedChoiceField"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypedChoiceField</span></code></a> が使用されます。</p>
<p>すべての <code class="docutils literal notranslate"><span class="pre">kwargs</span></code> 辞書は、フォームフィールドの <code class="docutils literal notranslate"><span class="pre">__init__()</span></code> メソッドに直接渡されます。通常、 <code class="docutils literal notranslate"><span class="pre">form_class</span></code> ( または <code class="docutils literal notranslate"><span class="pre">choices_form_class</span></code> ) 引数に適切なデフォルト値を設定し、それ以降の処理を親クラスに委譲するだけです。そのためには、カスタムフォームフィールド (そしてフォームウィジェット) を書く必要があるかもしれません。これについては <a class="reference internal" href="../topics/forms/index.html"><span class="doc">フォームのドキュメント</span></a> を参照してください。</p>
<p>上の例に続き、 <a class="reference internal" href="../ref/models/fields.html#django.db.models.Field.formfield" title="django.db.models.Field.formfield"><code class="xref py py-meth docutils literal notranslate"><span class="pre">formfield()</span></code></a> メソッドは次のように書けます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">HandField</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Field</span><span class="p">):</span>
    <span class="c1"># ...</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">formfield</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># This is a fairly standard way to set up some defaults</span>
        <span class="c1"># while letting the caller override them.</span>
        <span class="n">defaults</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;form_class&quot;</span><span class="p">:</span> <span class="n">MyFormField</span><span class="p">}</span>
        <span class="n">defaults</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">formfield</span><span class="p">(</span><span class="o">**</span><span class="n">defaults</span><span class="p">)</span>
</pre></div>
</div>
<p>これは <code class="docutils literal notranslate"><span class="pre">MyFormField</span></code> フィールドクラス (デフォルトのウィジェットを持ちます) のインポートを想定しています。このドキュメントでは、カスタムフォームフィールドの書き方の詳細は説明しません。</p>
</section>
<section id="s-emulating-built-in-field-types">
<span id="s-id6"></span><span id="emulating-built-in-field-types"></span><span id="id6"></span><h4>組み込みフィールド・タイプのエミュレート<a class="headerlink" href="#emulating-built-in-field-types" title="Link to this heading">¶</a></h4>
<p>もし <a class="reference internal" href="../ref/models/fields.html#django.db.models.Field.db_type" title="django.db.models.Field.db_type"><code class="xref py py-meth docutils literal notranslate"><span class="pre">db_type()</span></code></a> メソッドを作成したのなら、 <a class="reference internal" href="../ref/models/fields.html#django.db.models.Field.get_internal_type" title="django.db.models.Field.get_internal_type"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_internal_type()</span></code></a> はあまり使わないので気にしなくても大丈夫です。しかし、データベースストレージの型は他のフィールドと似ていることがあるので、正しいカラムを作成するために他のフィールドのロジックを使うこともできます。</p>
<p>例えば:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">HandField</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Field</span><span class="p">):</span>
    <span class="c1"># ...</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_internal_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;CharField&quot;</span>
</pre></div>
</div>
<p>どのデータベースのバックエンドを使用していても、<a class="reference internal" href="../ref/django-admin.html#django-admin-migrate"><code class="xref std std-djadmin docutils literal notranslate"><span class="pre">migrate</span></code></a> やその他のSQLコマンドは文字列を格納するための正しいカラムタイプを作成します。</p>
<p>もし <a class="reference internal" href="../ref/models/fields.html#django.db.models.Field.get_internal_type" title="django.db.models.Field.get_internal_type"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_internal_type()</span></code></a> が、使用しているデータベースのバックエンドで Django が知らない文字列 (つまり、<code class="docutils literal notranslate"><span class="pre">django.db.backends.&lt;db_name&gt;.base.DatabaseWrapper.data_types</span></code> にない文字列) を返した場合、シリアライザはその文字列を使用しますが、デフォルトの <a class="reference internal" href="../ref/models/fields.html#django.db.models.Field.db_type" title="django.db.models.Field.db_type"><code class="xref py py-meth docutils literal notranslate"><span class="pre">db_type()</span></code></a> メソッドは <code class="docutils literal notranslate"><span class="pre">None</span></code> を返します。これが便利な理由は <a class="reference internal" href="../ref/models/fields.html#django.db.models.Field.db_type" title="django.db.models.Field.db_type"><code class="xref py py-meth docutils literal notranslate"><span class="pre">db_type()</span></code></a> のドキュメントを参照してください。シリアライザのフィールドの型として説明的な文字列を入れるのは、シリアライザの出力を Django 以外の他の場所で使う場合に便利なアイデアです。</p>
</section>
<section id="s-converting-field-data-for-serialization">
<span id="s-converting-model-field-to-serialization"></span><span id="converting-field-data-for-serialization"></span><span id="converting-model-field-to-serialization"></span><h4>シリアライズするためにフィールドデータを変換する場合<a class="headerlink" href="#converting-field-data-for-serialization" title="Link to this heading">¶</a></h4>
<p>シリアライザによる値のシリアライズ方法をカスタマイズするには、 <a class="reference internal" href="../ref/models/fields.html#django.db.models.Field.value_to_string" title="django.db.models.Field.value_to_string"><code class="xref py py-meth docutils literal notranslate"><span class="pre">value_to_string()</span></code></a> をオーバーライドします。 <a class="reference internal" href="../ref/models/fields.html#django.db.models.Field.value_from_object" title="django.db.models.Field.value_from_object"><code class="xref py py-meth docutils literal notranslate"><span class="pre">value_from_object()</span></code></a> を使うのは、シリアライズの前にフィールドの値を取得する最も良い方法です。例えば、 <code class="docutils literal notranslate"><span class="pre">HandField</span></code> はデータの保存に文字列を使うので、既存の変換コードを再利用できます:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">HandField</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Field</span><span class="p">):</span>
    <span class="c1"># ...</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">value_to_string</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">value_from_object</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_prep_value</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
</pre></div>
</div>
</section>
</section>
<section id="s-some-general-advice">
<span id="some-general-advice"></span><h3>一般的なアドバイス<a class="headerlink" href="#some-general-advice" title="Link to this heading">¶</a></h3>
<p>カスタムフィールドの作成は、特に Python の型とデータベースやシリアライズのフォーマットとの間で複雑な変換を行う場合、厄介なプロセスになることがあります。ここでは、スムーズに進めるためのヒントをいくつか紹介します:</p>
<ol class="arabic simple">
<li><p>既存の Django フィールド ( <a class="extlink-source reference external" href="https://github.com/django/django/blob/main/django/db/models/fields/__init__.py">django/db/models/fields/__init__.py</a> にあります) を見て、着想を得てください。ゼロから全く新しいフィールドを作るのではなく、あなたの欲しいものに似たフィールドを見つけ、それを少し拡張してみてください。</p></li>
<li><p>フィールドとしてラップしているクラスに <code class="docutils literal notranslate"><span class="pre">__str__()</span></code> メソッドを追加します。フィールドのコードのデフォルトの動作として、値に対して <code class="docutils literal notranslate"><span class="pre">str()</span></code> を呼び出す箇所が多くあります。(このドキュメントの例では、 <code class="docutils literal notranslate"><span class="pre">value</span></code> は <code class="docutils literal notranslate"><span class="pre">HandField</span></code> ではなく <code class="docutils literal notranslate"><span class="pre">Hand</span></code> インスタンスになります）。そのため、 <code class="docutils literal notranslate"><span class="pre">__str__()</span></code> メソッドが自動的に Python オブジェクトの文字列形式に変換してくれれば、多くの手間を省けます。</p></li>
</ol>
</section>
</section>
<section id="s-writing-a-filefield-subclass">
<span id="writing-a-filefield-subclass"></span><h2><code class="docutils literal notranslate"><span class="pre">FileField</span></code> サブクラスを書く<a class="headerlink" href="#writing-a-filefield-subclass" title="Link to this heading">¶</a></h2>
<p>上記のメソッドに加えて、ファイルを扱うフィールドには考慮すべき特別な要件がいくつかあります。 <code class="docutils literal notranslate"><span class="pre">FileField</span></code> によって提供される仕組みの大部分、例えばデータベースの保存と取得の制御などは、変更することなく、サブクラスに特定のタイプのファイルをサポートさせることができます。</p>
<p>Django は <code class="docutils literal notranslate"><span class="pre">File</span></code> クラスを提供し、ファイルの内容や操作のプロキシとして使われます。これをサブクラス化することで、ファイルへのアクセス方法や利用可能なメソッドをカスタマイズできます。このクラスは <code class="docutils literal notranslate"><span class="pre">django.db.models.fields.files</span></code> にあり、デフォルトの動作は <a class="reference internal" href="../ref/files/file.html"><span class="doc">ファイルのドキュメント</span></a> で解説しています。</p>
<p>一度 <code class="docutils literal notranslate"><span class="pre">File</span></code> のサブクラスが作成されると、新しい <code class="docutils literal notranslate"><span class="pre">FileField</span></code> サブクラスにはそれを使用するように指示する必要があります。そのためには、新しい <code class="docutils literal notranslate"><span class="pre">File</span></code> サブクラスを <code class="docutils literal notranslate"><span class="pre">FileField</span></code> サブクラスの特別な <code class="docutils literal notranslate"><span class="pre">attr_class</span></code> 属性に割り当てます。</p>
<section id="s-a-few-suggestions">
<span id="a-few-suggestions"></span><h3>いくつかの提案<a class="headerlink" href="#a-few-suggestions" title="Link to this heading">¶</a></h3>
<p>上記の詳細に加えて、フィールドのコードの効率と読みやすさを劇的に改善するいくつかのガイドラインがあります。</p>
<ol class="arabic simple">
<li><p>Django 独自の <code class="docutils literal notranslate"><span class="pre">ImageField</span></code> のソース ( <a class="extlink-source reference external" href="https://github.com/django/django/blob/main/django/db/models/fields/files.py">django/db/models/fields/files.py</a> ) は、上で説明したテクニックを全て組み込んでいるので、特定のファイルタイプをサポートするために <code class="docutils literal notranslate"><span class="pre">FileField</span></code> をサブクラス化する方法の良い例です。</p></li>
<li><p>できるだけファイル属性をキャッシュします。ファイルはリモートのストレージシステムに保存されている可能性があるため、それらを取得するには、必ずしも必要ではない余分な時間やコストがかかる可能性があります。一度ファイルを検索してその内容に関するデータを取得したら、そのデータをできるだけ多くキャッシュして、その情報を取得するために以後ファイルを検索する回数を減らします。</p></li>
</ol>
</section>
</section>
</section>


          </div>
        </div>
      </div>
      
        
          <div class="yui-b" id="sidebar">
            
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../contents.html">目次</a></h3>
    <ul>
<li><a class="reference internal" href="#">カスタムのモデルフィールドを作成する</a><ul>
<li><a class="reference internal" href="#introduction">はじめに</a><ul>
<li><a class="reference internal" href="#our-example-object">私たちのサンプルオブジェクト</a></li>
</ul>
</li>
<li><a class="reference internal" href="#background-theory">背景理論</a><ul>
<li><a class="reference internal" href="#database-storage">データベースストレージ</a></li>
<li><a class="reference internal" href="#what-does-a-field-class-do">フィールドクラスが行うこと</a></li>
</ul>
</li>
<li><a class="reference internal" href="#writing-a-field-subclass">フィールドサブクラスを書く</a><ul>
<li><a class="reference internal" href="#field-deconstruction">フィールドの解体</a></li>
<li><a class="reference internal" href="#field-attributes-not-affecting-database-column-definition">データベースのカラム定義に影響しないフィールド属性</a></li>
<li><a class="reference internal" href="#changing-a-custom-field-s-base-class">カスタムフィールドのベースクラスを変更する</a></li>
<li><a class="reference internal" href="#documenting-your-custom-field">カスタムフィールドのドキュメントを書く</a></li>
<li><a class="reference internal" href="#useful-methods">便利なメソッド</a><ul>
<li><a class="reference internal" href="#custom-database-types">カスタムデータベースタイプ</a></li>
<li><a class="reference internal" href="#converting-values-to-python-objects">変数を Python オブジェクトに変換する</a></li>
<li><a class="reference internal" href="#converting-python-objects-to-query-values">Python オブジェクトをクエリ変数に変換する</a></li>
<li><a class="reference internal" href="#converting-query-values-to-database-values">クエリの変数をデータベースの変数に変換する</a></li>
<li><a class="reference internal" href="#preprocessing-values-before-saving">保存する前に値を前処理する場合</a></li>
<li><a class="reference internal" href="#specifying-the-form-field-for-a-model-field">モデルフィールドのフォームフィールドの指定</a></li>
<li><a class="reference internal" href="#emulating-built-in-field-types">組み込みフィールド・タイプのエミュレート</a></li>
<li><a class="reference internal" href="#converting-field-data-for-serialization">シリアライズするためにフィールドデータを変換する場合</a></li>
</ul>
</li>
<li><a class="reference internal" href="#some-general-advice">一般的なアドバイス</a></li>
</ul>
</li>
<li><a class="reference internal" href="#writing-a-filefield-subclass"><code class="docutils literal notranslate"><span class="pre">FileField</span></code> サブクラスを書く</a><ul>
<li><a class="reference internal" href="#a-few-suggestions">いくつかの提案</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>前のトピックへ</h4>
    <p class="topless"><a href="legacy-databases.html"
                          title="前の章へ">レガシーなデータベースと Django の統合</a></p>
  </div>
  <div>
    <h4>次のトピックへ</h4>
    <p class="topless"><a href="writing-migrations.html"
                          title="次の章へ">データベースのマイグレーションの作成方法</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>このページ</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/howto/custom-model-fields.txt"
            rel="nofollow">ソースコードを表示</a></li>
    </ul>
   </div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">クイック検索</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="検索" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
              <h3>Last update:</h3>
              <p class="topless">1月 22, 2025</p>
          </div>
        
      
    </div>

    <div id="ft">
      <div class="nav">
    &laquo; <a href="legacy-databases.html" title="レガシーなデータベースと Django の統合">previous</a>
     |
    <a href="index.html" title="How-to ガイド" accesskey="U">up</a>
   |
    <a href="writing-migrations.html" title="データベースのマイグレーションの作成方法">next</a> &raquo;</div>
    </div>
  </div>

      <div class="clearer"></div>
    </div>
  </body>
</html>